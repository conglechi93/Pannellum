[{"E:\\project742022\\react\\src\\index.tsx":"1","E:\\project742022\\react\\src\\reportWebVitals.ts":"2","E:\\project742022\\react\\src\\app\\App.tsx":"3","E:\\project742022\\react\\src\\pages\\pannellum-view\\views\\index.js":"4","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\deleteInfoDialog.tsx":"5","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\categories.tsx":"6","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\snackbar.tsx":"7","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\deleteSceneDialog.tsx":"8","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\addInfoDialog.tsx":"9","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\addSceneDialog.tsx":"10","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\loadSceneDialog.tsx":"11","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\editSceneDialog.tsx":"12","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\editInfoDialog.tsx":"13","E:\\project742022\\react\\src\\pages\\pannellum-view\\views\\default-config\\index.js":"14","E:\\project742022\\react\\src\\pages\\pannellum-view\\libs\\react-pannellum\\dist\\index.js":"15","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\editSceneValidation.tsx":"16","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\deleteInfoValidation.tsx":"17","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\addInfoValidation.tsx":"18","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\deleteSceneValidation.tsx":"19","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\loadSceneValidation.tsx":"20","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\styles\\index.ts":"21","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\addSceneValidation.tsx":"22","E:\\project742022\\react\\src\\pages\\pannellum-view\\views\\app.tsx":"23","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Products.tsx":"24","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Navbar.tsx":"25","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Home.tsx":"26","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Services.tsx":"27","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\SignUp.tsx":"28","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\Cards.tsx":"29","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\Button.tsx":"30","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\HeroSection.tsx":"31","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\Footer.tsx":"32","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\CardItem.tsx":"33"},{"size":558,"mtime":1656946951615,"results":"34","hashOfConfig":"35"},{"size":440,"mtime":1656946951615,"results":"36","hashOfConfig":"35"},{"size":247,"mtime":1656999763322,"results":"37","hashOfConfig":"35"},{"size":16765,"mtime":1657002182852,"results":"38","hashOfConfig":"35"},{"size":6106,"mtime":1656946951615,"results":"39","hashOfConfig":"35"},{"size":12434,"mtime":1656946951615,"results":"40","hashOfConfig":"35"},{"size":1109,"mtime":1656946951615,"results":"41","hashOfConfig":"35"},{"size":4482,"mtime":1656946951615,"results":"42","hashOfConfig":"35"},{"size":8171,"mtime":1656946951615,"results":"43","hashOfConfig":"35"},{"size":7755,"mtime":1656946951615,"results":"44","hashOfConfig":"35"},{"size":4378,"mtime":1656946951615,"results":"45","hashOfConfig":"35"},{"size":8814,"mtime":1656946951615,"results":"46","hashOfConfig":"35"},{"size":13182,"mtime":1656946951615,"results":"47","hashOfConfig":"35"},{"size":9131,"mtime":1656946951615,"results":"48","hashOfConfig":"35"},{"size":231023,"mtime":1656946951615,"results":"49","hashOfConfig":"35"},{"size":2883,"mtime":1656946951615,"results":"50","hashOfConfig":"35"},{"size":2206,"mtime":1656946951615,"results":"51","hashOfConfig":"35"},{"size":2396,"mtime":1656946951615,"results":"52","hashOfConfig":"35"},{"size":2265,"mtime":1656946951615,"results":"53","hashOfConfig":"35"},{"size":2270,"mtime":1656946951615,"results":"54","hashOfConfig":"35"},{"size":248,"mtime":1656946951615,"results":"55","hashOfConfig":"35"},{"size":3198,"mtime":1656946951615,"results":"56","hashOfConfig":"35"},{"size":890,"mtime":1657001552472,"results":"57","hashOfConfig":"35"},{"size":165,"mtime":1656999493171,"results":"58","hashOfConfig":"35"},{"size":2184,"mtime":1657001496133,"results":"59","hashOfConfig":"35"},{"size":354,"mtime":1656999478204,"results":"60","hashOfConfig":"35"},{"size":165,"mtime":1656999500071,"results":"61","hashOfConfig":"35"},{"size":159,"mtime":1656999510845,"results":"62","hashOfConfig":"35"},{"size":1781,"mtime":1657000291552,"results":"63","hashOfConfig":"35"},{"size":711,"mtime":1656999010842,"results":"64","hashOfConfig":"35"},{"size":440,"mtime":1657000511859,"results":"65","hashOfConfig":"35"},{"size":3855,"mtime":1657000396052,"results":"66","hashOfConfig":"35"},{"size":603,"mtime":1656999584664,"results":"67","hashOfConfig":"35"},{"filePath":"68","messages":"69","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},"tm2bxi",{"filePath":"71","messages":"72","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"73","messages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"75","messages":"76","errorCount":0,"fatalErrorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"77"},{"filePath":"78","messages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"70"},{"filePath":"81","messages":"82","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"83","messages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"85","messages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87","usedDeprecatedRules":"70"},{"filePath":"88","messages":"89","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"90","usedDeprecatedRules":"70"},{"filePath":"91","messages":"92","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"93","usedDeprecatedRules":"70"},{"filePath":"94","messages":"95","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"96","usedDeprecatedRules":"70"},{"filePath":"97","messages":"98","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"99","usedDeprecatedRules":"70"},{"filePath":"100","messages":"101","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"102","usedDeprecatedRules":"70"},{"filePath":"103","messages":"104","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"105"},{"filePath":"106","messages":"107","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":1,"source":"108","usedDeprecatedRules":"105"},{"filePath":"109","messages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"111","usedDeprecatedRules":"70"},{"filePath":"112","messages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"114","messages":"115","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"116","messages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"118","messages":"119","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"120","messages":"121","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"122","messages":"123","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"124","messages":"125","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"126","messages":"127","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"128","messages":"129","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"130","messages":"131","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"132","messages":"133","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"134","messages":"135","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"136","messages":"137","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},{"filePath":"138","messages":"139","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"140"},{"filePath":"141","messages":"142","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"143","usedDeprecatedRules":"70"},{"filePath":"144","messages":"145","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"146","usedDeprecatedRules":"70"},{"filePath":"147","messages":"148","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"70"},"E:\\project742022\\react\\src\\index.tsx",[],["149","150"],"E:\\project742022\\react\\src\\reportWebVitals.ts",[],"E:\\project742022\\react\\src\\app\\App.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\views\\index.js",["151","152","153","154","155","156","157","158","159","160","161","162","163","164","165"],"import React, { useState, useEffect } from \"react\";\r\nimport clsx from \"clsx\";\r\nimport { makeStyles } from \"@material-ui/core/styles\";\r\nimport CssBaseline from \"@material-ui/core/CssBaseline\";\r\nimport Drawer from \"@material-ui/core/Drawer\";\r\nimport AppBar from \"@material-ui/core/AppBar\";\r\nimport Toolbar from \"@material-ui/core/Toolbar\";\r\nimport List from \"@material-ui/core/List\";\r\nimport Typography from \"@material-ui/core/Typography\";\r\nimport Divider from \"@material-ui/core/Divider\";\r\nimport IconButton from \"@material-ui/core/IconButton\";\r\nimport Container from \"@material-ui/core/Container\";\r\nimport MenuIcon from \"@material-ui/icons/Menu\";\r\nimport ChevronLeftIcon from \"@material-ui/icons/ChevronLeft\";\r\nimport { MainListItems } from \"../components/categories\";\r\nimport CustomizedSnackbars from \"../components/snackbar\";\r\nimport { Alert, AlertTitle } from \"@material-ui/lab\";\r\nimport AddInfoDialog from \"../components/dialogs/addInfoDialog\";\r\nimport AddSceneDialog from \"../components/dialogs/addSceneDialog\";\r\nimport DeleteInfoDialog from \"../components/dialogs/deleteInfoDialog\";\r\nimport DeleteSceneDialog from \"../components/dialogs/deleteSceneDialog\";\r\nimport LoadSceneDialog from \"../components/dialogs/loadSceneDialog\";\r\nimport EditInfoDialog from \"../components/dialogs/editInfoDialog\";\r\nimport EditSceneDialog from \"../components/dialogs/editSceneDialog\";\r\nimport { Box, Button } from \"@material-ui/core\";\r\nimport { saveAs } from \"file-saver\";\r\nimport { initialState, pinCusor } from \"./default-config\";\r\nimport ReactPannellum, {\r\n  mouseEventToCoords,\r\n  changeMouseCursor,\r\n  getAllScenes,\r\n  startAutoRotate,\r\n  stopAutoRotate,\r\n  showCompass,\r\n  addScene,\r\n  destroy,\r\n} from \"../libs/react-pannellum/dist\";\r\n\r\nconst drawerWidth = 240;\r\n\r\nconst useStyles = makeStyles((theme) => ({\r\n  root: {\r\n    display: \"flex\",\r\n  },\r\n  toolbar: {\r\n    paddingRight: 24, // keep right padding when drawer closed\r\n  },\r\n  toolbarIcon: {\r\n    display: \"flex\",\r\n    alignItems: \"center\",\r\n    justifyContent: \"flex-end\",\r\n    padding: \"0 8px\",\r\n    backgroundImage: `url(${\"https://solutions.viettel.vn/wp-content/uploads/2021/01/logo.png\"})`,\r\n    backgroundSize: \"contain\",\r\n    backgroundPosition: \"center\",\r\n    backgroundRepeat: \"no-repeat\",\r\n    ...theme.mixins.toolbar,\r\n  },\r\n  appBar: {\r\n    zIndex: theme.zIndex.drawer + 1,\r\n    backgroundColor: \"#1976d2\",\r\n    transition: theme.transitions.create([\"width\", \"margin\"], {\r\n      easing: theme.transitions.easing.sharp,\r\n      duration: theme.transitions.duration.leavingScreen,\r\n    }),\r\n  },\r\n  appBarShift: {\r\n    marginLeft: drawerWidth,\r\n    width: `calc(100% - ${drawerWidth}px)`,\r\n    transition: theme.transitions.create([\"width\", \"margin\"], {\r\n      easing: theme.transitions.easing.sharp,\r\n      duration: theme.transitions.duration.enteringScreen,\r\n    }),\r\n  },\r\n  menuButton: {\r\n    marginRight: 36,\r\n  },\r\n  menuButtonHidden: {\r\n    display: \"none\",\r\n  },\r\n  title: {\r\n    flexGrow: 1,\r\n  },\r\n  drawerPaper: {\r\n    position: \"relative\",\r\n    whiteSpace: \"nowrap\",\r\n    width: drawerWidth,\r\n    transition: theme.transitions.create(\"width\", {\r\n      easing: theme.transitions.easing.sharp,\r\n      duration: theme.transitions.duration.enteringScreen,\r\n    }),\r\n  },\r\n  drawerPaperClose: {\r\n    overflowX: \"hidden\",\r\n    transition: theme.transitions.create(\"width\", {\r\n      easing: theme.transitions.easing.sharp,\r\n      duration: theme.transitions.duration.leavingScreen,\r\n    }),\r\n    width: theme.spacing(7),\r\n    [theme.breakpoints.up(\"sm\")]: {\r\n      width: theme.spacing(9),\r\n    },\r\n  },\r\n  appBarSpacer: theme.mixins.toolbar,\r\n  content: {\r\n    flexGrow: 1,\r\n    height: \"100vh\",\r\n    overflow: \"auto\",\r\n  },\r\n  container: {\r\n    paddingTop: theme.spacing(4),\r\n    paddingBottom: theme.spacing(4),\r\n    height: \"100%\",\r\n    width: \"100%\",\r\n  },\r\n  paper: {\r\n    padding: theme.spacing(2),\r\n    display: \"flex\",\r\n    overflow: \"auto\",\r\n    flexDirection: \"column\",\r\n  },\r\n  fixedHeight: {\r\n    height: 240,\r\n  },\r\n}));\r\n\r\nconst types = [{ title: \"info\" }, { title: \"scene\" }];\r\n\r\nexport default function Mainpage() {\r\n  const classes = useStyles();\r\n  let fileReader;\r\n\r\n  const [state, setState] = useState({\r\n    isOpenDrawer: false, // use to open / close the sidebar content\r\n    openDialog: \"\", // use to open special dialog\r\n    isSelect: -1, // use to remove highlight of item of sidebar\r\n    hotSpot: {\r\n      // use to save config of hotSpot\r\n      id: \"\",\r\n      sceneId: \"\",\r\n      pitch: \"\",\r\n      type: \"\",\r\n      yaw: \"\",\r\n      text: \"\",\r\n      URL: \"\",\r\n    },\r\n    scene: {\r\n      // use to save / retrieve config of scene\r\n      sceneId: \"\",\r\n      config: {\r\n        type: \"equirectangular\",\r\n        text: \"\",\r\n        title: \"\",\r\n        author: \"\",\r\n        imageSource: \"\",\r\n      },\r\n    },\r\n    scenes: [], // use to save / retrieve array of scenes\r\n    isSceneType: false, // use to define \"scene\" type of hotspot when \"Add\"\r\n    isInfoType: false, // use to define \"info\" type of hotspot when \"Add\"\r\n    isAddInfo: false, // use to open / close \"Add Hotspot\" Dialog\r\n    isAddScene: false, // use to open / close \"Add Scene\" Dialog\r\n    isLoadScene: false, // use to open / close \"Load Scene\" Dialog\r\n    isEditInfo: false, // use to open / close \"Edit Hotspot\" Dialog\r\n    isEditScene: false,\r\n    isDeleteInfo: false, // use to open / close \"Delete Hotspot\" Dialog\r\n    isDeleteScene: false, // use to open / close \"Delete Scene\" Dialog\r\n    isLoadConfig: false,\r\n    loadState: false,\r\n    config: {\r\n      sceneFadeDuration: 1000,\r\n    }, // config for viewer\r\n    fullScenesInformation: [], // use save / retrieve all scenes information / configs of this view\r\n    snackbarAction: {\r\n      // use to show / hide notification\r\n      isOpen: false,\r\n      message: \"\",\r\n      type: \"\",\r\n    },\r\n    coordinates: {},\r\n  });\r\n\r\n  useEffect(() => {\r\n    changeMouseCursor(state);\r\n  }, [state.isAddInfo]);\r\n\r\n  useEffect(() => {\r\n    if (getAllScenes() === null) {\r\n      setState((s) => ({\r\n        ...s,\r\n        config: {\r\n          ...s.config,\r\n        },\r\n      }));\r\n    } else {\r\n      setState((s) => ({\r\n        ...s,\r\n        fullScenesInformation: getAllScenes(),\r\n      }));\r\n    }\r\n  }, [\r\n    state.isAddInfo,\r\n    state.isAddScene,\r\n    state.isLoadScene,\r\n    state.isEditInfo,\r\n    state.isEditScene,\r\n    state.isDeleteInfo,\r\n    state.isDeleteScene,\r\n  ]);\r\n\r\n  useEffect(() => {\r\n    if (state.fullScenesInformation.length)\r\n      setState((s) => ({ ...s, loadState: false }));\r\n  }, [state.fullScenesInformation.length]);\r\n\r\n  useEffect(() => {\r\n    if (state.fullScenesInformation.length) {\r\n      const array = [...state.fullScenesInformation.slice(1)];\r\n      array.map((value, index) => {\r\n        return addScene(Object.keys(value)[0], Object.values(value)[0]);\r\n      });\r\n      setState((s) => ({ ...s, isLoadConfig: false }));\r\n    }\r\n  }, [state.loadState]);\r\n\r\n  const handleDrawerOpen = () => {\r\n    setState((s) => ({ ...s, isOpenDrawer: true }));\r\n  };\r\n\r\n  const handleDrawerClose = () => {\r\n    setState((s) => ({ ...s, isOpenDrawer: false }));\r\n  };\r\n\r\n  const handleDialogClose = (index, value) => {\r\n    switch (index) {\r\n      case 0: // this case use to close \"Add Info\" dialog when click \"CANCEL\".\r\n        setState((s) => ({\r\n          ...s,\r\n          openDialog: \"\",\r\n          isSceneType: false,\r\n          isInfoType: false,\r\n        }));\r\n        break;\r\n      case 1:\r\n        setState((s) => ({\r\n          ...s,\r\n          openDialog: \"\",\r\n          isAddInfo: false,\r\n          isAddScene: false,\r\n          isDeleteInfo: false,\r\n          isDeleteScene: false,\r\n          isLoadScene: false,\r\n          isSelect: -1,\r\n          fullScenesInformation: value.fullScenesInformation,\r\n          config: {\r\n            ...s.config,\r\n            title: Object.values(value.fullScenesInformation[0])[0].title,\r\n            author: Object.values(value.fullScenesInformation[0])[0].author,\r\n          },\r\n        }));\r\n        break;\r\n      case 3: // this case use to close all dialog ( except \"Add Info\" ) when click \"CANCEL\".\r\n        value && actionSuccess(value);\r\n        setState((s) => ({\r\n          ...s,\r\n          openDialog: \"\",\r\n          isAddInfo: false,\r\n          isAddScene: false,\r\n          isEditInfo: false,\r\n          isEditScene: false,\r\n          isDeleteInfo: false,\r\n          isDeleteScene: false,\r\n          isLoadScene: false,\r\n          isSelect: -1,\r\n        }));\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n  };\r\n\r\n  const actionSuccess = (message) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      snackbarAction: {\r\n        isOpen: true,\r\n        message: message,\r\n        type: \"success\",\r\n      },\r\n    }));\r\n  };\r\n\r\n  const onCloseSnackBar = (value) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      snackbarAction: {\r\n        ...s.snackbarAction,\r\n        isOpen: false,\r\n      },\r\n    }));\r\n  };\r\n\r\n  const isAddInfo = (data, index) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      isAddInfo: data,\r\n      isSelect: index,\r\n    }));\r\n  };\r\n\r\n  const isAddScene = (data, index) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      isAddScene: data,\r\n      isSelect: index,\r\n    }));\r\n  };\r\n\r\n  const isLoadScene = (data, index) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      isLoadScene: data,\r\n      isSelect: index,\r\n    }));\r\n  };\r\n\r\n  const isEditInfo = (data, index) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      isEditInfo: data,\r\n      isSelect: index,\r\n    }));\r\n  };\r\n\r\n  const isEditScene = (data, index) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      isEditScene: data,\r\n      isSelect: index,\r\n    }));\r\n  };\r\n\r\n  const isDeleteInfo = (data, index) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      isDeleteInfo: data,\r\n      isSelect: index,\r\n    }));\r\n  };\r\n\r\n  const isDeleteScene = (data, index) => {\r\n    setState((s) => ({\r\n      ...s,\r\n      isDeleteScene: data,\r\n      isSelect: index,\r\n    }));\r\n  };\r\n\r\n  const autoRotate = (value) => {\r\n    value ? startAutoRotate() : stopAutoRotate();\r\n  };\r\n\r\n  const enableCompass = (value) => {\r\n    showCompass(value);\r\n  };\r\n\r\n  const getMouseEventToCoords = (e) => {\r\n    if (state.isAddInfo === true) {\r\n      setState((s) => ({\r\n        ...s,\r\n        openDialog: \"isAddInfo\",\r\n        hotSpot: {\r\n          ...s.hotSpot,\r\n          pitch: mouseEventToCoords(e)[0],\r\n          yaw: mouseEventToCoords(e)[1],\r\n        },\r\n        coordinates: {\r\n          pitch: mouseEventToCoords(e)[0],\r\n          yaw: mouseEventToCoords(e)[1],\r\n        },\r\n      }));\r\n    }\r\n  };\r\n\r\n  const handleFileRead = (e) => {\r\n    const content = fileReader.result;\r\n    destroy();\r\n    setState((s) => ({\r\n      ...s,\r\n      fullScenesInformation: JSON.parse(content),\r\n    }));\r\n  };\r\n\r\n  const handleFileChosen = (file) => {\r\n    if (file) {\r\n      setState((s) => ({\r\n        ...initialState,\r\n        fullScenesInformation: [],\r\n        isLoadConfig: true,\r\n        loadState: true,\r\n      }));\r\n      fileReader = new FileReader();\r\n      fileReader.onloadend = handleFileRead;\r\n      fileReader.readAsText(file);\r\n    }\r\n  };\r\n\r\n  const exportConfig = () => {\r\n    const config = JSON.stringify(getAllScenes());\r\n    const blob = new Blob([config], { type: \"text/plain;charset=utf-8\" });\r\n    saveAs(blob, \"Panorama Tour Data.txt\");\r\n  };\r\n\r\n  return (\r\n    <div\r\n      className={classes.root}\r\n      style={{\r\n        cursor: state.isAddInfo ? `url(${pinCusor}), pointer` : \"default\",\r\n      }}\r\n    >\r\n      <CssBaseline />\r\n      {/* <AppBar\r\n        position=\"absolute\"\r\n        className={clsx(\r\n          classes.appBar,\r\n          state.isOpenDrawer && classes.appBarShift\r\n        )}\r\n      >\r\n        <Toolbar className={classes.toolbar}>\r\n          <IconButton\r\n            edge=\"start\"\r\n            color=\"inherit\"\r\n            aria-label=\"open drawer\"\r\n            onClick={handleDrawerOpen}\r\n            className={clsx(\r\n              classes.menuButton,\r\n              state.isOpenDrawer && classes.menuButtonHidden\r\n            )}\r\n          >\r\n            <MenuIcon />\r\n          </IconButton>\r\n          <Typography\r\n            component=\"h1\"\r\n            variant=\"h6\"\r\n            color=\"inherit\"\r\n            noWrap\r\n            className={classes.title}\r\n          >\r\n            DEMO\r\n          </Typography>\r\n          <Box>\r\n            <Button\r\n              variant=\"contained\"\r\n              color=\"primary\"\r\n              onClick={() => exportConfig()}\r\n            >\r\n              Save\r\n            </Button>\r\n            <> </>\r\n            <input\r\n              style={{ display: \"none\" }}\r\n              id=\"contained-button-file\"\r\n              type=\"file\"\r\n              accept=\".txt\"\r\n              onChange={(e) => handleFileChosen(e.target.files[0])}\r\n            />\r\n            <label htmlFor=\"contained-button-file\">\r\n              <Button variant=\"contained\" color=\"primary\" component=\"span\">\r\n                Load\r\n              </Button>\r\n            </label>\r\n          </Box>\r\n        </Toolbar>\r\n      </AppBar> */}\r\n      <Drawer\r\n        variant=\"permanent\"\r\n        classes={{\r\n          paper: clsx(\r\n            classes.drawerPaper,\r\n            !state.isOpenDrawer && classes.drawerPaperClose\r\n          ),\r\n        }}\r\n        open={state.isOpenDrawer}\r\n      >\r\n        {/* <div className={classes.toolbarIcon}>\r\n          <IconButton onClick={handleDrawerClose}>\r\n            <ChevronLeftIcon />\r\n          </IconButton>\r\n        </div> */}\r\n        <Divider />\r\n        <List>\r\n          <MainListItems\r\n            isOpenDrawer={state.isOpenDrawer}\r\n            isSelect={state.isSelect}\r\n            isAddInfo={isAddInfo}\r\n            isAddScene={isAddScene}\r\n            isLoadScene={isLoadScene}\r\n            isEditInfo={isEditInfo}\r\n            isEditScene={isEditScene}\r\n            isDeleteInfo={isDeleteInfo}\r\n            isDeleteScene={isDeleteScene}\r\n            isAutoRotate={autoRotate}\r\n            isCompass={enableCompass}\r\n            disable={state.fullScenesInformation?.length ? false : true}\r\n          />\r\n        </List>\r\n        <Divider />\r\n      </Drawer>\r\n      <main className={classes.content}>\r\n        <div className={classes.appBarSpacer} />\r\n        <Container maxWidth=\"lg\" className={classes.container}>\r\n          {state.fullScenesInformation?.length ? (\r\n            <ReactPannellum\r\n              onMouseDown={getMouseEventToCoords}\r\n              id={Object.keys(state.fullScenesInformation[0])[0]}\r\n              sceneId={Object.keys(state.fullScenesInformation[0])[0]}\r\n              imageSource={\r\n                Object.values(state.fullScenesInformation[0])[0].imageSource\r\n              }\r\n              config={\r\n                state.isLoadConfig\r\n                  ? Object.values(state.fullScenesInformation[0])[0]\r\n                  : state.config\r\n              }\r\n            />\r\n          ) : null}\r\n          {!state.fullScenesInformation.length && (\r\n            <Alert severity=\"warning\">\r\n              <AlertTitle>Warning</AlertTitle>\r\n              No scene found, select <strong>\"Add Scene\"</strong> to add the\r\n              first scene â€” <strong>check it out!</strong>\r\n            </Alert>\r\n          )}\r\n        </Container>\r\n        <AddInfoDialog\r\n          open={state.openDialog === \"isAddInfo\"}\r\n          close={handleDialogClose}\r\n          mouseEventToCoords={state.coordinates}\r\n          fullScenesInformation={state.fullScenesInformation}\r\n        />\r\n        <AddSceneDialog\r\n          open={state.isAddScene}\r\n          close={handleDialogClose}\r\n          fullScenesInformation={state.fullScenesInformation}\r\n        />\r\n        <LoadSceneDialog\r\n          open={state.isLoadScene}\r\n          close={handleDialogClose}\r\n          fullScenesInformation={state.fullScenesInformation}\r\n        />\r\n        <EditInfoDialog\r\n          open={state.isEditInfo}\r\n          close={handleDialogClose}\r\n          fullScenesInformation={state.fullScenesInformation}\r\n        />\r\n        <EditSceneDialog\r\n          open={state.isEditScene}\r\n          close={handleDialogClose}\r\n          fullScenesInformation={state.fullScenesInformation}\r\n        />\r\n        <DeleteInfoDialog\r\n          open={state.isDeleteInfo}\r\n          close={handleDialogClose}\r\n          fullScenesInformation={state.fullScenesInformation}\r\n        />\r\n        <DeleteSceneDialog\r\n          open={state.isDeleteScene}\r\n          close={handleDialogClose}\r\n          fullScenesInformation={state.fullScenesInformation}\r\n        />\r\n        <CustomizedSnackbars\r\n          open={state.snackbarAction[\"isOpen\"]}\r\n          type={state.snackbarAction[\"type\"]}\r\n          message={state.snackbarAction[\"message\"]}\r\n          onClose={onCloseSnackBar}\r\n        />\r\n        \r\n      </main>\r\n    </div>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\deleteInfoDialog.tsx",["166"],"import React, { useState } from \"react\";\r\nimport Dialog from \"@material-ui/core/Dialog\";\r\nimport DialogActions from \"@material-ui/core/DialogActions\";\r\nimport DialogContent from \"@material-ui/core/DialogContent\";\r\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\r\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\r\nimport TextField from \"@material-ui/core/TextField\";\r\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\r\nimport { removeHotSpot } from \"../../libs/react-pannellum/dist\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport { useFormControls } from \"../validiations/deleteInfoValidation\";\r\nimport { helperTextStyles } from \"../styles\";\r\n\r\ninterface Props {\r\n  scene: {\r\n    // use to save / retrieve config of scene\r\n    sceneId: string;\r\n    config: {\r\n      type: string;\r\n      text: string;\r\n      title: string;\r\n      author: string;\r\n      imageSource: string;\r\n    };\r\n  };\r\n  hotSpot: {\r\n    // use to save config of hotSpot\r\n    id: string;\r\n    sceneId: string;\r\n    pitch: string;\r\n    type: string;\r\n    yaw: string;\r\n    text: string;\r\n    URL: string;\r\n  };\r\n}\r\n\r\nexport default function DeleteInfoDialog(props) {\r\n  const [state, setState] = useState<Props>({\r\n    scene: {\r\n      // use to save / retrieve config of scene\r\n      sceneId: \"\",\r\n      config: {\r\n        type: \"equirectangular\",\r\n        text: \"\",\r\n        title: \"\",\r\n        author: \"\",\r\n        imageSource: \"\",\r\n      },\r\n    },\r\n    hotSpot: {\r\n      // use to save config of hotSpot\r\n      id: \"\",\r\n      sceneId: \"\",\r\n      pitch: \"\",\r\n      type: \"\",\r\n      yaw: \"\",\r\n      text: \"\",\r\n      URL: \"\",\r\n    },\r\n  });\r\n\r\n  const { handleInputValue, handleFormSubmit, formIsValid, errors } =\r\n    useFormControls({\r\n      open: props.open,\r\n      sceneID: state.hotSpot[\"sceneId\"],\r\n    });\r\n\r\n  const onDeleteInfo = () => {\r\n    removeHotSpot(state.hotSpot[\"id\"], state.hotSpot[\"sceneId\"]);\r\n    props.close(3, \"Delete Hotspot Successful !\");\r\n  };\r\n\r\n  return (\r\n    <Dialog // this is Delete Info Dialog\r\n      open={props.open}\r\n      onClose={() => props.close(3)}\r\n      aria-labelledby=\"form-dialog-title\"\r\n    >\r\n      <form id=\"my-delete-info\">\r\n        <DialogTitle id=\"form-dialog-title\">Delete Info</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            To delete info, first choice scene name, then choice hotspot.\r\n          </DialogContentText>\r\n          <Autocomplete\r\n            id=\"scenes\"\r\n            options={props.fullScenesInformation}\r\n            getOptionLabel={(option: object) => Object.keys(option)[0]}\r\n            onChange={(event: any, value: any) => {\r\n              handleInputValue({\r\n                target: {\r\n                  name: \"sceneName\",\r\n                  value: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              });\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: value ? Object.values(value as object)[0] : {},\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  sceneId: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                label=\"Scene Name\"\r\n                variant=\"outlined\"\r\n                margin=\"dense\"\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                name=\"sceneName\"\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                error={errors[\"sceneName\"]?.length > 0}\r\n                onKeyPress={(e) => {\r\n                  if (e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                  }\r\n                }}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                {...(errors[\"sceneName\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"sceneName\"],\r\n                })}\r\n              />\r\n            )}\r\n          />\r\n          <Autocomplete\r\n            disabled={state.scene[\"hotSpots\"] ? false : true}\r\n            id=\"hotspot\"\r\n            options={state.scene[\"hotSpots\"] ? state.scene[\"hotSpots\"] : []}\r\n            getOptionLabel={(option) => option.id}\r\n            onChange={(event: any, value: any) => {\r\n              handleInputValue({\r\n                target: {\r\n                  name: \"hotSpotName\",\r\n                  value: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              });\r\n              setState((s) => ({\r\n                ...s,\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  id: value ? value.id.toString() : \"\",\r\n                },\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                label=\"Hotspot Name\"\r\n                variant=\"outlined\"\r\n                name=\"hotSpotName\"\r\n                error={errors[\"hotSpotName\"]?.length > 0}\r\n                onKeyPress={(e) => {\r\n                  if (e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                  }\r\n                }}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                {...(errors[\"hotSpotName\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"hotSpotName\"],\r\n                })}\r\n                margin=\"dense\"\r\n              />\r\n            )}\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={() => props.close(3)} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            disabled={!formIsValid()}\r\n            onClick={() => onDeleteInfo()}\r\n            color=\"primary\"\r\n          >\r\n            Delete\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\categories.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\snackbar.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\deleteSceneDialog.tsx",["167"],"import React, { useState } from \"react\";\r\nimport Dialog from \"@material-ui/core/Dialog\";\r\nimport DialogActions from \"@material-ui/core/DialogActions\";\r\nimport DialogContent from \"@material-ui/core/DialogContent\";\r\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\r\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\r\nimport TextField from \"@material-ui/core/TextField\";\r\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\r\nimport { removeScene } from \"../../libs/react-pannellum/dist\";\r\nimport { useFormControls } from \"../validiations/deleteSceneValidation\";\r\nimport { helperTextStyles } from \"../styles\";\r\nimport Button from \"@material-ui/core/Button\";\r\n\r\ninterface Props {\r\n  scene: {\r\n    // use to save / retrieve config of scene\r\n    sceneId: string;\r\n    config: {\r\n      type: string;\r\n      text: string;\r\n      title: string;\r\n      author: string;\r\n      imageSource: string;\r\n    };\r\n  };\r\n  hotSpot: {\r\n    // use to save config of hotSpot\r\n    id: string;\r\n    sceneId: string;\r\n    pitch: string;\r\n    type: string;\r\n    yaw: string;\r\n    text: string;\r\n    URL: string;\r\n  };\r\n}\r\n\r\nexport default function DeleteSceneDialog(props) {\r\n  const [state, setState] = useState<Props>({\r\n    scene: {\r\n      // use to save / retrieve config of scene\r\n      sceneId: \"\",\r\n      config: {\r\n        type: \"equirectangular\",\r\n        text: \"\",\r\n        title: \"\",\r\n        author: \"\",\r\n        imageSource: \"\",\r\n      },\r\n    },\r\n    hotSpot: {\r\n      // use to save config of hotSpot\r\n      id: \"\",\r\n      sceneId: \"\",\r\n      pitch: \"\",\r\n      type: \"\",\r\n      yaw: \"\",\r\n      text: \"\",\r\n      URL: \"\",\r\n    },\r\n  });\r\n\r\n  const { handleInputValue, handleFormSubmit, formIsValid, errors } =\r\n    useFormControls({\r\n      open: props.open,\r\n      sceneID: state.hotSpot[\"sceneId\"],\r\n    });\r\n\r\n  const onDeleteSene = () => {\r\n    removeScene(state.hotSpot[\"sceneId\"]);\r\n    props.close(3, \"Delete Scene Successful !\");\r\n  };\r\n\r\n  return (\r\n    <Dialog // this is Delete Info Dialog\r\n      open={props.open}\r\n      onClose={() => props.close(3)}\r\n      aria-labelledby=\"form-dialog-title\"\r\n    >\r\n      <form id=\"my-delete-scene\">\r\n        <DialogTitle id=\"form-dialog-title\">Delete Scene</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            To delete Scene, choice Scene Name. ( Note that you cannot delete\r\n            the current scene )\r\n          </DialogContentText>\r\n          <Autocomplete\r\n            id=\"scene\"\r\n            options={props.fullScenesInformation}\r\n            getOptionLabel={(option: object) => Object.keys(option)[0]}\r\n            onChange={(event, value: any) => {\r\n              handleInputValue({\r\n                target: {\r\n                  name: \"sceneName\",\r\n                  value: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              });\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: value ? Object.values(value as object)[0] : {},\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  sceneId: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                label=\"Scene Name\"\r\n                variant=\"outlined\"\r\n                margin=\"dense\"\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                name=\"sceneName\"\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                error={errors[\"sceneName\"]?.length > 0}\r\n                onKeyPress={(e) => {\r\n                  if (e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                  }\r\n                }}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                {...(errors[\"sceneName\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"sceneName\"],\r\n                })}\r\n              />\r\n            )}\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={() => props.close(3)} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            disabled={!formIsValid()}\r\n            onClick={() => onDeleteSene()}\r\n            color=\"primary\"\r\n          >\r\n            Delete\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\addInfoDialog.tsx",["168","169"],"import React, { useEffect, useState } from \"react\";\r\nimport Dialog from \"@material-ui/core/Dialog\";\r\nimport DialogActions from \"@material-ui/core/DialogActions\";\r\nimport DialogContent from \"@material-ui/core/DialogContent\";\r\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\r\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\r\nimport TextField from \"@material-ui/core/TextField\";\r\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport { addHotSpot } from \"../../libs/react-pannellum/dist\";\r\nimport { useFormControls } from \"../validiations/addInfoValidation\";\r\nimport { helperTextStyles } from \"../styles\";\r\n\r\ninterface types {\r\n  title: string;\r\n}\r\n\r\nconst types: types[] = [{ title: \"info\" }, { title: \"scene\" }];\r\n\r\ninterface Props {\r\n  hotSpot: {\r\n    id: string;\r\n    sceneId: string;\r\n    pitch: string;\r\n    type: string;\r\n    yaw: string;\r\n    text: string;\r\n    URL: string;\r\n  };\r\n  isSceneType: boolean;\r\n  isInfoType: boolean;\r\n}\r\n\r\nexport default function AddInfoDialog(props) {\r\n  const [state, setState] = useState<Props>({\r\n    hotSpot: {\r\n      id: \"\",\r\n      sceneId: \"\",\r\n      pitch: \"\",\r\n      type: \"\",\r\n      yaw: \"\",\r\n      text: \"\",\r\n      URL: \"\",\r\n    },\r\n    isSceneType: false, // use to define \"scene\" type of hotspot when \"Add\"\r\n    isInfoType: false, // use to define \"info\" type of hotspot when \"Add\"\r\n  });\r\n\r\n  useEffect(() => {\r\n    setState((s) => ({\r\n      hotSpot: {\r\n        id: \"\",\r\n        sceneId: \"\",\r\n        pitch: \"\",\r\n        type: \"\",\r\n        yaw: \"\",\r\n        text: \"\",\r\n        URL: \"\",\r\n      },\r\n      isSceneType: false, // use to define \"scene\" type of hotspot when \"Add\"\r\n      isInfoType: false, // use to define \"info\" type of hotspot when \"Add\"\r\n    }));\r\n  }, [props.open]);\r\n\r\n  const { handleInputValue, handleFormSubmit, formIsValid, errors } =\r\n    useFormControls({\r\n      open: props.open,\r\n      isInfo: state.isInfoType,\r\n      isScene: state.isSceneType,\r\n    });\r\n\r\n  const onAddInfo = () => {\r\n    addHotSpot({\r\n      pitch: props.mouseEventToCoords[\"pitch\"],\r\n      yaw: props.mouseEventToCoords[\"yaw\"],\r\n      id: state.hotSpot[\"id\"],\r\n      sceneId: state.hotSpot[\"sceneId\"],\r\n      type: state.hotSpot[\"type\"],\r\n      text: state.hotSpot[\"text\"],\r\n      URL: state.hotSpot[\"URL\"],\r\n    });\r\n    setState((s) => ({\r\n      ...s,\r\n      hotSpot: {\r\n        id: \"\",\r\n        sceneId: \"\",\r\n        pitch: \"\",\r\n        type: \"\",\r\n        yaw: \"\",\r\n        text: \"\",\r\n        URL: \"\",\r\n      },\r\n      isSceneType: false,\r\n      isInfoType: false,\r\n    }));\r\n    props.close(3, \"Add Hotspot Successful !\");\r\n  };\r\n\r\n  return (\r\n    <Dialog // this is Add Info Dialog\r\n      open={props.open}\r\n      onClose={() => props.close(0)}\r\n      aria-labelledby=\"form-dialog-title\"\r\n    >\r\n      <form id=\"my-add-info\">\r\n        <DialogTitle id=\"form-dialog-title\">Add Place Info</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            To add information for this place, enter a place name, then enter a\r\n            description (if available).\r\n          </DialogContentText>\r\n          <Autocomplete\r\n            id=\"type\"\r\n            options={types}\r\n            onSelect={handleInputValue}\r\n            getOptionLabel={(option) => option.title}\r\n            onChange={(event: any, value: any) => {\r\n              setState((s) => ({\r\n                ...s,\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  type: value && value.title.toString(),\r\n                },\r\n                isSceneType:\r\n                  value && value.title.toString() === \"scene\" ? true : false,\r\n                isInfoType:\r\n                  value && value.title.toString() === \"info\" ? true : false,\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                margin=\"dense\"\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                label=\"Type\"\r\n                variant=\"outlined\"\r\n                name=\"type\"\r\n                error={errors[\"type\"]?.length > 0}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                {...(errors[\"type\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"type\"],\r\n                })}\r\n              />\r\n            )}\r\n          />\r\n          <TextField\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"title\"\r\n            name=\"title\"\r\n            error={errors[\"title\"]?.length > 0}\r\n            label=\"Title( ID )\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onBlur={handleInputValue}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                hotSpot: { ...s.hotSpot, id: e.target.value },\r\n              }));\r\n            }}\r\n            {...(errors[\"title\"] && {\r\n              error: true,\r\n              helperText: errors[\"title\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n          {state.isSceneType && (\r\n            <Autocomplete\r\n              id=\"scenes\"\r\n              options={props.fullScenesInformation}\r\n              onSelect={handleInputValue}\r\n              getOptionLabel={(option: object) => Object.keys(option)[0]}\r\n              onChange={(event: any, value: any) =>\r\n                setState((s) => ({\r\n                  ...s,\r\n                  hotSpot: {\r\n                    ...s.hotSpot,\r\n                    sceneId: value && Object.keys(value)[0],\r\n                  },\r\n                }))\r\n              }\r\n              renderInput={(params) => (\r\n                <TextField\r\n                  {...params}\r\n                  name=\"sname\"\r\n                  style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                  FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                  label=\"Target Scene\"\r\n                  variant=\"outlined\"\r\n                  margin=\"dense\"\r\n                  error={errors[\"sname\"]?.length > 0}\r\n                  onBlur={handleInputValue}\r\n                  onChange={handleInputValue}\r\n                  {...(errors[\"sname\"] && {\r\n                    error: true,\r\n                    helperText: errors[\"sname\"],\r\n                  })}\r\n                />\r\n              )}\r\n            />\r\n          )}\r\n          <TextField\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"description\"\r\n            label=\"Description\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) =>\r\n              setState((s) => ({\r\n                ...s,\r\n                hotSpot: { ...s.hotSpot, text: e.target.value },\r\n              }))\r\n            }\r\n            multiline\r\n            rows={3}\r\n            fullWidth\r\n          />\r\n          {state.isInfoType && (\r\n            <TextField\r\n              style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n              variant=\"outlined\"\r\n              margin=\"dense\"\r\n              id=\"url\"\r\n              label=\"URL( Optional )\"\r\n              type=\"text\"\r\n              autoComplete=\"off\"\r\n              onChange={(e) =>\r\n                setState((s) => ({\r\n                  ...s,\r\n                  hotSpot: { ...s.hotSpot, URL: e.target.value },\r\n                }))\r\n              }\r\n              fullWidth\r\n            />\r\n          )}\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={() => props.close(0)} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            disabled={!formIsValid()}\r\n            onClick={() => onAddInfo()}\r\n            color=\"primary\"\r\n          >\r\n            Add\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\addSceneDialog.tsx",["170"],"import React, { useEffect, useState } from \"react\";\r\nimport Dialog from \"@material-ui/core/Dialog\";\r\nimport DialogActions from \"@material-ui/core/DialogActions\";\r\nimport DialogContent from \"@material-ui/core/DialogContent\";\r\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\r\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\r\nimport TextField from \"@material-ui/core/TextField\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport { addScene } from \"../../libs/react-pannellum/dist\";\r\nimport { defaultConfig } from \"../../views/default-config\";\r\nimport { useFormControls } from \"../validiations/addSceneValidation\";\r\nimport { helperTextStyles } from \"../styles\";\r\n\r\ninterface Props {\r\n  scene: {\r\n    // use to save / retrieve config of scene\r\n    sceneId: string;\r\n    config: {\r\n      type: string;\r\n      text: string;\r\n      title: string;\r\n      author: string;\r\n      imageSource: string;\r\n      hotSpots: Array<Object>;\r\n    };\r\n  };\r\n  fullScenesInformation: Array<any>;\r\n}\r\n\r\nexport default function AddSceneDialog(props) {\r\n  const [state, setState] = useState<Props>({\r\n    scene: {\r\n      // use to save / retrieve config of scene\r\n      sceneId: \"\",\r\n      config: {\r\n        type: \"equirectangular\",\r\n        text: \"\",\r\n        title: \"\",\r\n        author: \"\",\r\n        imageSource: \"\",\r\n        hotSpots: [],\r\n      },\r\n    },\r\n    fullScenesInformation: [],\r\n  });\r\n\r\n  useEffect(() => {\r\n    setState((s) => ({\r\n      scene: {\r\n        // use to save / retrieve config of scene\r\n        sceneId: \"\",\r\n        config: {\r\n          type: \"equirectangular\",\r\n          text: \"\",\r\n          title: \"\",\r\n          author: \"\",\r\n          imageSource: \"\",\r\n          hotSpots: [],\r\n        },\r\n      },\r\n      fullScenesInformation: [],\r\n    }));\r\n  }, [props.open]);\r\n\r\n  const { handleInputValue, handleFormSubmit, formIsValid, errors } =\r\n    useFormControls({\r\n      open: props.open,\r\n    });\r\n\r\n  const addSceneSuccess = () => {\r\n    setState((s) => ({\r\n      ...s,\r\n      snackbarAction: {\r\n        isOpen: true,\r\n        message: \"Add Scene Successful !\",\r\n        type: \"success\",\r\n      },\r\n    }));\r\n  };\r\n\r\n  const onAddScene = () => {\r\n    if (!props.fullScenesInformation?.length) {\r\n      setState((s) => ({\r\n        ...s,\r\n        fullScenesInformation: [\r\n          {\r\n            [s.scene[\"sceneId\"]]: {\r\n              ...s.scene[\"config\"],\r\n            },\r\n          },\r\n        ],\r\n      }));\r\n      props.close(1, {\r\n        ...state,\r\n        fullScenesInformation: [\r\n          {\r\n            [state.scene[\"sceneId\"]]: {\r\n              ...state.scene[\"config\"],\r\n            },\r\n          },\r\n        ],\r\n      });\r\n    } else {\r\n      addScene(state.scene.sceneId, state.scene[\"config\"], addSceneSuccess);\r\n      props.close(3, \"Add Scene Successful !\");\r\n    }\r\n  };\r\n\r\n  return (\r\n    <Dialog // this is Add Scene Dialog\r\n      open={props.open}\r\n      onClose={() => props.close(3)}\r\n      aria-labelledby=\"form-dialog-title\"\r\n    >\r\n      <form id=\"my-add-scene\">\r\n        <DialogTitle id=\"form-dialog-title\">Add Scene</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            To add scene, enter a scene id, scene name, then enter the source of\r\n            scene ( link ).\r\n          </DialogContentText>\r\n          <TextField\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            autoFocus\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"scene-id\"\r\n            label=\"Scene ID\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: {\r\n                  ...s.scene,\r\n                  sceneId: e.target.value,\r\n                },\r\n              }));\r\n            }}\r\n            name=\"sceneID\"\r\n            error={errors[\"sceneID\"]?.length > 0}\r\n            onBlur={handleInputValue}\r\n            {...(errors[\"sceneID\"] && {\r\n              error: true,\r\n              helperText: errors[\"sceneID\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n          <TextField\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"image-source\"\r\n            label=\"Image Source\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: {\r\n                  ...s.scene,\r\n                  config: {\r\n                    ...defaultConfig,\r\n                    ...s.scene[\"config\"],\r\n                    imageSource: e.target.value,\r\n                  },\r\n                },\r\n              }));\r\n            }}\r\n            name=\"imageSource\"\r\n            error={errors[\"imageSource\"]?.length > 0}\r\n            onBlur={handleInputValue}\r\n            {...(errors[\"imageSource\"] && {\r\n              error: true,\r\n              helperText: errors[\"imageSource\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n          <TextField\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"image-name\"\r\n            label=\"Scene Name\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: {\r\n                  ...s.scene,\r\n                  config: {\r\n                    ...defaultConfig,\r\n                    ...s.scene[\"config\"],\r\n                    title: e.target.value,\r\n                  },\r\n                },\r\n              }));\r\n            }}\r\n            name=\"sceneName\"\r\n            error={errors[\"sceneName\"]?.length > 0}\r\n            onBlur={handleInputValue}\r\n            {...(errors[\"sceneName\"] && {\r\n              error: true,\r\n              helperText: errors[\"sceneName\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n          <TextField\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"author-name\"\r\n            label=\"Author\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: {\r\n                  ...s.scene,\r\n                  config: {\r\n                    ...defaultConfig,\r\n                    ...s.scene[\"config\"],\r\n                    author: e.target.value,\r\n                  },\r\n                },\r\n              }));\r\n            }}\r\n            name=\"author\"\r\n            error={errors[\"author\"]?.length > 0}\r\n            onBlur={handleInputValue}\r\n            {...(errors[\"author\"] && {\r\n              error: true,\r\n              helperText: errors[\"author\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={() => props.close(3)} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            disabled={!formIsValid()}\r\n            onClick={() => onAddScene()}\r\n            color=\"primary\"\r\n          >\r\n            Add\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\loadSceneDialog.tsx",["171"],"import React, { useState } from \"react\";\r\nimport Dialog from \"@material-ui/core/Dialog\";\r\nimport DialogActions from \"@material-ui/core/DialogActions\";\r\nimport DialogContent from \"@material-ui/core/DialogContent\";\r\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\r\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\r\nimport TextField from \"@material-ui/core/TextField\";\r\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\r\nimport { loadScene } from \"../../libs/react-pannellum/dist\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport { useFormControls } from \"../validiations/loadSceneValidation\";\r\nimport { helperTextStyles } from \"../styles\";\r\n\r\ninterface Props {\r\n  scene: {\r\n    // use to save / retrieve config of scene\r\n    sceneId: string;\r\n    config: {\r\n      type: string;\r\n      text: string;\r\n      title: string;\r\n      author: string;\r\n      imageSource: string;\r\n    };\r\n  };\r\n  hotSpot: {\r\n    // use to save config of hotSpot\r\n    id: string;\r\n    sceneId: string;\r\n    pitch: string;\r\n    type: string;\r\n    yaw: string;\r\n    text: string;\r\n    URL: string;\r\n  };\r\n}\r\n\r\nexport default function LoadSceneDialog(props) {\r\n  const [state, setState] = useState<Props>({\r\n    scene: {\r\n      // use to save / retrieve config of scene\r\n      sceneId: \"\",\r\n      config: {\r\n        type: \"equirectangular\",\r\n        text: \"\",\r\n        title: \"\",\r\n        author: \"\",\r\n        imageSource: \"\",\r\n      },\r\n    },\r\n    hotSpot: {\r\n      // use to save config of hotSpot\r\n      id: \"\",\r\n      sceneId: \"\",\r\n      pitch: \"\",\r\n      type: \"\",\r\n      yaw: \"\",\r\n      text: \"\",\r\n      URL: \"\",\r\n    },\r\n  });\r\n\r\n  const { handleInputValue, handleFormSubmit, formIsValid, errors } =\r\n    useFormControls({\r\n      open: props.open,\r\n      sceneID: state.hotSpot[\"sceneId\"],\r\n    });\r\n\r\n  const onLoadScene = () => {\r\n    loadScene(state.hotSpot[\"sceneId\"]);\r\n    props.close(3);\r\n  };\r\n\r\n  return (\r\n    <Dialog // this is Delete Info Dialog\r\n      open={props.open}\r\n      onClose={() => props.close(3)}\r\n      aria-labelledby=\"form-dialog-title\"\r\n    >\r\n      <form id=\"my-load-scene\">\r\n        <DialogTitle id=\"form-dialog-title\">Load Scene</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            To Load Scene, choice Scene Name.\r\n          </DialogContentText>\r\n          <Autocomplete\r\n            id=\"scenes\"\r\n            options={props.fullScenesInformation}\r\n            getOptionLabel={(option: object) => Object.keys(option)[0]}\r\n            onChange={(event: any, value: any) => {\r\n              handleInputValue({\r\n                target: {\r\n                  name: \"sceneName\",\r\n                  value: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              });\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: value ? Object.values(value as object)[0] : {},\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  sceneId: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                label=\"Scene Name\"\r\n                variant=\"outlined\"\r\n                margin=\"dense\"\r\n                name=\"sceneName\"\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                style={{ marginTop: \"15px\", marginBottom: \"11px\" }}\r\n                error={errors[\"sceneName\"]?.length > 0}\r\n                onKeyPress={(e) => {\r\n                  if (e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                  }\r\n                }}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                {...(errors[\"sceneName\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"sceneName\"],\r\n                })}\r\n              />\r\n            )}\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={() => props.close(3)} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            disabled={!formIsValid()}\r\n            onClick={() => onLoadScene()}\r\n            color=\"primary\"\r\n          >\r\n            Load\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\editSceneDialog.tsx",["172"],"import React, { useEffect, useState } from \"react\";\r\nimport Dialog from \"@material-ui/core/Dialog\";\r\nimport DialogActions from \"@material-ui/core/DialogActions\";\r\nimport DialogContent from \"@material-ui/core/DialogContent\";\r\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\r\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\r\nimport TextField from \"@material-ui/core/TextField\";\r\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\r\nimport {\r\n  addScene,\r\n  getCurrentScene,\r\n  loadScene,\r\n  getAllScenes,\r\n} from \"../../libs/react-pannellum/dist\";\r\nimport { useFormControls } from \"../validiations/editSceneValidation\";\r\nimport { helperTextStyles } from \"../styles\";\r\nimport { defaultConfig } from \"../../views/default-config\";\r\nimport Button from \"@material-ui/core/Button\";\r\n\r\ninterface Props {\r\n  scene: {\r\n    // use to save / retrieve config of scene\r\n    type: string;\r\n    text: string;\r\n    title: string;\r\n    author: string;\r\n    imageSource: string;\r\n    config: object;\r\n  };\r\n  hotSpot: {\r\n    // use to save config of hotSpot\r\n    id: string;\r\n    sceneId: string;\r\n    pitch: string;\r\n    type: string;\r\n    yaw: string;\r\n    text: string;\r\n    URL: string;\r\n  };\r\n}\r\n\r\nexport default function EditSceneDialog(props) {\r\n  const [state, setState] = useState<Props>({\r\n    scene: {\r\n      // use to save / retrieve config of scene\r\n      type: \"equirectangular\",\r\n      text: \"\",\r\n      title: \"\",\r\n      author: \"\",\r\n      imageSource: \"\",\r\n      config: {},\r\n    },\r\n    hotSpot: {\r\n      // use to save config of hotSpot\r\n      id: \"\",\r\n      sceneId: \"\",\r\n      pitch: \"\",\r\n      type: \"\",\r\n      yaw: \"\",\r\n      text: \"\",\r\n      URL: \"\",\r\n    },\r\n  });\r\n\r\n  useEffect(() => {\r\n    setState({\r\n      scene: {\r\n        // use to save / retrieve config of scene\r\n        type: \"equirectangular\",\r\n        text: \"\",\r\n        title: \"\",\r\n        author: \"\",\r\n        imageSource: \"\",\r\n        config: {},\r\n      },\r\n      hotSpot: {\r\n        // use to save config of hotSpot\r\n        id: \"\",\r\n        sceneId: \"\",\r\n        pitch: \"\",\r\n        type: \"\",\r\n        yaw: \"\",\r\n        text: \"\",\r\n        URL: \"\",\r\n      },\r\n    });\r\n    console.log(getAllScenes());\r\n  }, [props.open]);\r\n\r\n  const { handleInputValue, handleFormSubmit, formIsValid, errors } =\r\n    useFormControls({\r\n      open: props.open,\r\n      sceneID: state.hotSpot[\"sceneId\"],\r\n    });\r\n\r\n  const onEditScene = () => {\r\n    addScene(state.hotSpot[\"sceneId\"], state.scene[\"config\"]);\r\n    if (state.hotSpot[\"sceneId\"] === getCurrentScene()) {\r\n      loadScene(state.hotSpot[\"sceneId\"]);\r\n    }\r\n    props.close(3, \"Edit Scene Successful !\");\r\n  };\r\n\r\n  return (\r\n    <Dialog // this is Delete Info Dialog\r\n      open={props.open}\r\n      onClose={() => props.close(3)}\r\n      aria-labelledby=\"form-dialog-title\"\r\n    >\r\n      <form id=\"my-delete-scene\">\r\n        <DialogTitle id=\"form-dialog-title\">Edit Scene</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            To Edit Scene, choice Scene Name.\r\n          </DialogContentText>\r\n          <Autocomplete\r\n            id=\"scene\"\r\n            options={props.fullScenesInformation}\r\n            getOptionLabel={(option: object) => Object.keys(option)[0]}\r\n            onChange={(event, value: any) => {\r\n              handleInputValue({\r\n                target: {\r\n                  name: \"sceneName\",\r\n                  value: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              });\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: value ? Object.values(value as object)[0] : {},\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  sceneId: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              }));\r\n            }}\r\n            fullWidth\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                label=\"Scene ID\"\r\n                variant=\"outlined\"\r\n                margin=\"dense\"\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                name=\"sceneID\"\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                error={errors[\"sceneID\"]?.length > 0}\r\n                onKeyPress={(e) => {\r\n                  if (e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                  }\r\n                }}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                {...(errors[\"sceneID\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"sceneID\"],\r\n                })}\r\n                fullWidth\r\n              />\r\n            )}\r\n          />\r\n          <TextField\r\n            disabled={state.hotSpot[\"sceneId\"] ? false : true}\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            key={`img${state.scene[\"imageSource\"]}`}\r\n            defaultValue={state.scene[\"imageSource\"]}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"image-source\"\r\n            label=\"Image Source\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: {\r\n                  ...s.scene,\r\n                  config: {\r\n                    ...defaultConfig,\r\n                    ...s.scene[\"config\"],\r\n                    imageSource: e.target.value || state.scene[\"imageSource\"],\r\n                  },\r\n                },\r\n              }));\r\n            }}\r\n            name=\"imageSource\"\r\n            error={errors[\"imageSource\"]?.length > 0}\r\n            onBlur={handleInputValue}\r\n            {...(errors[\"imageSource\"] && {\r\n              error: true,\r\n              helperText: errors[\"imageSource\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n          <TextField\r\n            disabled={state.hotSpot[\"sceneId\"] ? false : true}\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            key={`title${state.scene[\"title\"]}`}\r\n            defaultValue={state.scene[\"title\"]}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"image-name\"\r\n            label=\"Scene Name\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: {\r\n                  ...s.scene,\r\n                  config: {\r\n                    ...defaultConfig,\r\n                    ...s.scene[\"config\"],\r\n                    title: e.target.value,\r\n                  },\r\n                },\r\n              }));\r\n            }}\r\n            name=\"sceneName\"\r\n            error={errors[\"sceneName\"]?.length > 0}\r\n            onBlur={handleInputValue}\r\n            {...(errors[\"sceneName\"] && {\r\n              error: true,\r\n              helperText: errors[\"sceneName\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n          <TextField\r\n            disabled={state.hotSpot[\"sceneId\"] ? false : true}\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            FormHelperTextProps={{ classes: helperTextStyles() }}\r\n            key={`author${state.scene[\"author\"]}`}\r\n            defaultValue={state.scene[\"author\"]}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"author-name\"\r\n            label=\"Author\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) => {\r\n              handleInputValue(e);\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: {\r\n                  ...s.scene,\r\n                  config: {\r\n                    ...defaultConfig,\r\n                    ...s.scene[\"config\"],\r\n                    author: e.target.value,\r\n                  },\r\n                },\r\n              }));\r\n            }}\r\n            name=\"author\"\r\n            error={errors[\"author\"]?.length > 0}\r\n            onBlur={handleInputValue}\r\n            {...(errors[\"author\"] && {\r\n              error: true,\r\n              helperText: errors[\"author\"],\r\n            })}\r\n            fullWidth\r\n          />\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={() => props.close(3)} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            disabled={!formIsValid()}\r\n            onClick={() => onEditScene()}\r\n            color=\"primary\"\r\n          >\r\n            Edit\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\dialogs\\editInfoDialog.tsx",["173","174","175"],"import React, { useEffect, useState } from \"react\";\r\nimport Dialog from \"@material-ui/core/Dialog\";\r\nimport DialogActions from \"@material-ui/core/DialogActions\";\r\nimport DialogContent from \"@material-ui/core/DialogContent\";\r\nimport DialogContentText from \"@material-ui/core/DialogContentText\";\r\nimport DialogTitle from \"@material-ui/core/DialogTitle\";\r\nimport TextField from \"@material-ui/core/TextField\";\r\nimport Autocomplete from \"@material-ui/lab/Autocomplete\";\r\nimport {\r\n  addHotSpot,\r\n  removeHotSpot,\r\n  getAllScenes,\r\n} from \"../../libs/react-pannellum/dist\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport { useFormControls } from \"../validiations/deleteInfoValidation\";\r\nimport { helperTextStyles } from \"../styles\";\r\n\r\ninterface types {\r\n  title: string;\r\n}\r\n\r\nconst types: types[] = [{ title: \"info\" }, { title: \"scene\" }];\r\n\r\nexport default function EditInfoDialog(props) {\r\n  const [state, setState] = useState({\r\n    scene: {\r\n      // use to save / retrieve config of scene\r\n      sceneId: \"\",\r\n      hotSpot: [],\r\n      config: {\r\n        type: \"equirectangular\",\r\n        text: \"\",\r\n        title: \"\",\r\n        author: \"\",\r\n        imageSource: \"\",\r\n      },\r\n    },\r\n    hotSpot: {\r\n      // use to save config of hotSpot\r\n      id: \"\",\r\n      sceneId: \"\",\r\n      pitch: \"\",\r\n      type: \"\",\r\n      yaw: \"\",\r\n      text: \"\",\r\n      URL: \"\",\r\n    },\r\n    isSceneType: false, // use to define \"scene\" type of hotspot when \"Add\"\r\n    isInfoType: false, // use to define \"info\" type of hotspot when \"Add\"\r\n  });\r\n\r\n  useEffect(() => {\r\n    console.log(getAllScenes());\r\n  }, [state.hotSpot[\"id\"]]);\r\n\r\n  useEffect(() => {\r\n    setState({\r\n      scene: {\r\n        // use to save / retrieve config of scene\r\n        sceneId: \"\",\r\n        hotSpot: [],\r\n        config: {\r\n          type: \"equirectangular\",\r\n          text: \"\",\r\n          title: \"\",\r\n          author: \"\",\r\n          imageSource: \"\",\r\n        },\r\n      },\r\n      hotSpot: {\r\n        // use to save config of hotSpot\r\n        id: \"\",\r\n        sceneId: \"\",\r\n        pitch: \"\",\r\n        type: \"\",\r\n        yaw: \"\",\r\n        text: \"\",\r\n        URL: \"\",\r\n      },\r\n      isSceneType: false, // use to define \"scene\" type of hotspot when \"Add\"\r\n      isInfoType: false, // use to define \"info\" type of hotspot when \"Add\"\r\n    });\r\n  }, [props.open]);\r\n\r\n  const { handleInputValue, handleFormSubmit, formIsValid, errors } =\r\n    useFormControls({\r\n      open: props.open,\r\n      sceneID: state.hotSpot[\"sceneId\"],\r\n    });\r\n\r\n  const onEditInfo = () => {\r\n    removeHotSpot(state.hotSpot[\"id\"], state.hotSpot[\"sceneId\"]);\r\n    addHotSpot({\r\n      pitch: state.scene[\"hotSpots\"]?.find(\r\n        (value) => value?.id === state.hotSpot[\"id\"]\r\n      )[\"pitch\"],\r\n      yaw: state.scene[\"hotSpots\"]?.find(\r\n        (value) => value?.id === state.hotSpot[\"id\"]\r\n      )[\"yaw\"],\r\n      id: state.hotSpot[\"id\"],\r\n      sceneId: state.hotSpot[\"sceneId\"],\r\n      type:\r\n        state.hotSpot[\"type\"] ||\r\n        state.scene[\"hotSpots\"]?.find(\r\n          (value) => value?.id === state.hotSpot[\"id\"]\r\n        )[\"type\"],\r\n      text:\r\n        state.hotSpot[\"text\"] ||\r\n        state.scene[\"hotSpots\"]?.find(\r\n          (value) => value?.id === state.hotSpot[\"id\"]\r\n        )[\"text\"],\r\n      URL: state.hotSpot[\"URL\"],\r\n    });\r\n    props.close(3, \"Edit Hotspot Successful !\");\r\n  };\r\n\r\n  return (\r\n    <Dialog // this is Delete Info Dialog\r\n      open={props.open}\r\n      onClose={() => props.close(3)}\r\n      aria-labelledby=\"form-dialog-title\"\r\n    >\r\n      <form id=\"my-delete-info\">\r\n        <DialogTitle id=\"form-dialog-title\">Edit Info</DialogTitle>\r\n        <DialogContent>\r\n          <DialogContentText>\r\n            To Edit Info, first choice Scene ID, then choice hotspot ID.\r\n          </DialogContentText>\r\n          <Autocomplete\r\n            id=\"scenes\"\r\n            options={props.fullScenesInformation}\r\n            getOptionLabel={(option: object) => Object.keys(option)[0]}\r\n            onChange={(event: any, value: any) => {\r\n              handleInputValue({\r\n                target: {\r\n                  name: \"sceneName\",\r\n                  value: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              });\r\n              setState((s) => ({\r\n                ...s,\r\n                scene: value ? Object.values(value as object)[0] : {},\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  sceneId: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                label=\"Scene Name\"\r\n                variant=\"outlined\"\r\n                margin=\"dense\"\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                name=\"sceneName\"\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                error={errors[\"sceneName\"]?.length > 0}\r\n                onKeyPress={(e) => {\r\n                  if (e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                  }\r\n                }}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                {...(errors[\"sceneName\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"sceneName\"],\r\n                })}\r\n              />\r\n            )}\r\n          />\r\n          <Autocomplete\r\n            disabled={state.scene[\"hotSpots\"] ? false : true}\r\n            id=\"hotspot\"\r\n            options={state.scene[\"hotSpots\"] ? state.scene[\"hotSpots\"] : []}\r\n            getOptionLabel={(option) => option.id}\r\n            onChange={(event: any, value: any) => {\r\n              if (\r\n                state.hotSpot[\"id\"] &&\r\n                state.scene[\"hotSpots\"]?.find(\r\n                  (value) => value?.id === state.hotSpot[\"id\"]\r\n                )[\"type\"] === \"info\"\r\n              ) {\r\n                setState((s) => ({ ...s, isInfoType: true }));\r\n              } else {\r\n                setState((s) => ({ ...s, isSceneType: true }));\r\n              }\r\n              handleInputValue({\r\n                target: {\r\n                  name: \"hotSpotName\",\r\n                  value: value ? Object.keys(value as object)[0] : \"\",\r\n                },\r\n              });\r\n              setState((s) => ({\r\n                ...s,\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  id: value ? value.id.toString() : \"\",\r\n                },\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                label=\"Hotspot Name\"\r\n                variant=\"outlined\"\r\n                name=\"hotSpotName\"\r\n                error={errors[\"hotSpotName\"]?.length > 0}\r\n                onKeyPress={(e) => {\r\n                  if (e.key === \"Enter\") {\r\n                    e.preventDefault();\r\n                  }\r\n                }}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                {...(errors[\"hotSpotName\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"hotSpotName\"],\r\n                })}\r\n                margin=\"dense\"\r\n              />\r\n            )}\r\n          />\r\n          <Autocomplete\r\n            disabled={state.hotSpot[\"id\"] ? false : true}\r\n            id=\"type\"\r\n            key={`type${\r\n              state.hotSpot[\"id\"] &&\r\n              state.scene[\"hotSpots\"]?.find(\r\n                (value) => value?.id === state.hotSpot[\"id\"]\r\n              )[\"type\"]\r\n            }`}\r\n            defaultValue={{\r\n              title:\r\n                state.hotSpot[\"id\"] &&\r\n                state.scene[\"hotSpots\"]?.find(\r\n                  (value) => value?.id === state.hotSpot[\"id\"]\r\n                )[\"type\"],\r\n            }}\r\n            options={types}\r\n            onSelect={handleInputValue}\r\n            getOptionLabel={(option) => option.title}\r\n            onChange={(event: any, value: any) => {\r\n              setState((s) => ({\r\n                ...s,\r\n                hotSpot: {\r\n                  ...s.hotSpot,\r\n                  type: value && value.title.toString(),\r\n                },\r\n                isSceneType:\r\n                  value && value.title.toString() === \"scene\" ? true : false,\r\n                isInfoType:\r\n                  value && value.title.toString() === \"info\" ? true : false,\r\n              }));\r\n            }}\r\n            renderInput={(params) => (\r\n              <TextField\r\n                {...params}\r\n                style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                margin=\"dense\"\r\n                FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                label=\"Type\"\r\n                variant=\"outlined\"\r\n                name=\"type\"\r\n                error={errors[\"type\"]?.length > 0}\r\n                onBlur={handleInputValue}\r\n                onChange={handleInputValue}\r\n                {...(errors[\"type\"] && {\r\n                  error: true,\r\n                  helperText: errors[\"type\"],\r\n                })}\r\n              />\r\n            )}\r\n          />\r\n          {state.isSceneType && (\r\n            <Autocomplete\r\n              disabled={state.hotSpot[\"id\"] ? false : true}\r\n              id=\"scenes\"\r\n              key={`scn${\r\n                state.hotSpot[\"id\"] &&\r\n                state.scene[\"hotSpots\"]?.find(\r\n                  (value) => value?.id === state.hotSpot[\"id\"]\r\n                )[\"sceneId\"]\r\n              }`}\r\n              defaultValue={{\r\n                [state.hotSpot[\"id\"] &&\r\n                state.scene[\"hotSpots\"]?.find(\r\n                  (value) => value?.id === state.hotSpot[\"id\"]\r\n                )[\"sceneId\"]]: \"\",\r\n              }}\r\n              options={props.fullScenesInformation}\r\n              onSelect={handleInputValue}\r\n              getOptionLabel={(option: object) => Object.keys(option)[0]}\r\n              onChange={(event: any, value: any) =>\r\n                setState((s) => ({\r\n                  ...s,\r\n                  hotSpot: {\r\n                    ...s.hotSpot,\r\n                    sceneId: value && Object.keys(value)[0],\r\n                  },\r\n                }))\r\n              }\r\n              renderInput={(params) => (\r\n                <TextField\r\n                  {...params}\r\n                  name=\"sname\"\r\n                  style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n                  FormHelperTextProps={{ classes: helperTextStyles() }}\r\n                  label=\"Scene Name\"\r\n                  variant=\"outlined\"\r\n                  margin=\"dense\"\r\n                  error={errors[\"sname\"]?.length > 0}\r\n                  onBlur={handleInputValue}\r\n                  onChange={handleInputValue}\r\n                  {...(errors[\"sname\"] && {\r\n                    error: true,\r\n                    helperText: errors[\"sname\"],\r\n                  })}\r\n                />\r\n              )}\r\n            />\r\n          )}\r\n          <TextField\r\n            disabled={state.hotSpot[\"id\"] ? false : true}\r\n            key={`des${\r\n              state.hotSpot[\"id\"] &&\r\n              state.scene[\"hotSpots\"]?.find(\r\n                (value) => value?.id === state.hotSpot[\"id\"]!\r\n              )[\"text\"]\r\n            }`}\r\n            defaultValue={\r\n              state.hotSpot[\"id\"] &&\r\n              state.scene[\"hotSpots\"]?.find(\r\n                (value) => value?.id === state.hotSpot[\"id\"]!\r\n              )[\"text\"]\r\n            }\r\n            style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n            variant=\"outlined\"\r\n            margin=\"dense\"\r\n            id=\"description\"\r\n            label=\"Description\"\r\n            type=\"text\"\r\n            autoComplete=\"off\"\r\n            onChange={(e) =>\r\n              setState((s) => ({\r\n                ...s,\r\n                hotSpot: { ...s.hotSpot, text: e.target.value },\r\n              }))\r\n            }\r\n            multiline\r\n            rows={3}\r\n            fullWidth\r\n          />\r\n          {state.isInfoType && (\r\n            <TextField\r\n              style={{ marginTop: \"15px\", marginBottom: \"10px\" }}\r\n              variant=\"outlined\"\r\n              margin=\"dense\"\r\n              id=\"url\"\r\n              label=\"URL( Optional )\"\r\n              type=\"text\"\r\n              autoComplete=\"off\"\r\n              onChange={(e) =>\r\n                setState((s) => ({\r\n                  ...s,\r\n                  hotSpot: { ...s.hotSpot, URL: e.target.value },\r\n                }))\r\n              }\r\n              fullWidth\r\n            />\r\n          )}\r\n        </DialogContent>\r\n        <DialogActions>\r\n          <Button onClick={() => props.close(3)} color=\"primary\">\r\n            Cancel\r\n          </Button>\r\n          <Button\r\n            disabled={!formIsValid()}\r\n            onClick={() => onEditInfo()}\r\n            color=\"primary\"\r\n          >\r\n            Edit\r\n          </Button>\r\n        </DialogActions>\r\n      </form>\r\n    </Dialog>\r\n  );\r\n}\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\views\\default-config\\index.js",[],["176","177"],"E:\\project742022\\react\\src\\pages\\pannellum-view\\libs\\react-pannellum\\dist\\index.js",["178","179","180","181","182"],"(\"use strict\");\r\n\r\n// Object.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nvar React = require(\"react\");\r\nvar PropTypes = require(\"prop-types\");\r\n\r\nfunction _interopDefaultLegacy(e) {\r\n  return e && typeof e === \"object\" && \"default\" in e ? e : { default: e };\r\n}\r\n\r\nvar React__default = /*#__PURE__*/ _interopDefaultLegacy(React);\r\nvar PropTypes__default = /*#__PURE__*/ _interopDefaultLegacy(PropTypes);\r\n\r\nfunction _classCallCheck(instance, Constructor) {\r\n  if (!(instance instanceof Constructor)) {\r\n    throw new TypeError(\"Cannot call a class as a function\");\r\n  }\r\n}\r\n\r\nfunction _defineProperties(target, props) {\r\n  for (var i = 0; i < props.length; i++) {\r\n    var descriptor = props[i];\r\n    descriptor.enumerable = descriptor.enumerable || false;\r\n    descriptor.configurable = true;\r\n    if (\"value\" in descriptor) descriptor.writable = true;\r\n    Object.defineProperty(target, descriptor.key, descriptor);\r\n  }\r\n}\r\n\r\nfunction _createClass(Constructor, protoProps, staticProps) {\r\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\r\n  if (staticProps) _defineProperties(Constructor, staticProps);\r\n  return Constructor;\r\n}\r\n\r\nfunction _defineProperty(obj, key, value) {\r\n  if (key in obj) {\r\n    Object.defineProperty(obj, key, {\r\n      value: value,\r\n      enumerable: true,\r\n      configurable: true,\r\n      writable: true,\r\n    });\r\n  } else {\r\n    obj[key] = value;\r\n  }\r\n\r\n  return obj;\r\n}\r\n\r\nfunction ownKeys(object, enumerableOnly) {\r\n  var keys = Object.keys(object);\r\n\r\n  if (Object.getOwnPropertySymbols) {\r\n    var symbols = Object.getOwnPropertySymbols(object);\r\n    if (enumerableOnly)\r\n      symbols = symbols.filter(function (sym) {\r\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\r\n      });\r\n    keys.push.apply(keys, symbols);\r\n  }\r\n\r\n  return keys;\r\n}\r\n\r\nfunction _objectSpread2(target) {\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    var source = arguments[i] != null ? arguments[i] : {};\r\n\r\n    if (i % 2) {\r\n      ownKeys(Object(source), true).forEach(function (key) {\r\n        _defineProperty(target, key, source[key]);\r\n      });\r\n    } else if (Object.getOwnPropertyDescriptors) {\r\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\r\n    } else {\r\n      ownKeys(Object(source)).forEach(function (key) {\r\n        Object.defineProperty(\r\n          target,\r\n          key,\r\n          Object.getOwnPropertyDescriptor(source, key)\r\n        );\r\n      });\r\n    }\r\n  }\r\n\r\n  return target;\r\n}\r\n\r\nfunction _inherits(subClass, superClass) {\r\n  if (typeof superClass !== \"function\" && superClass !== null) {\r\n    throw new TypeError(\"Super expression must either be null or a function\");\r\n  }\r\n\r\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\r\n    constructor: {\r\n      value: subClass,\r\n      writable: true,\r\n      configurable: true,\r\n    },\r\n  });\r\n  if (superClass) _setPrototypeOf(subClass, superClass);\r\n}\r\n\r\nfunction _getPrototypeOf(o) {\r\n  _getPrototypeOf = Object.setPrototypeOf\r\n    ? Object.getPrototypeOf\r\n    : function _getPrototypeOf(o) {\r\n        return o.__proto__ || Object.getPrototypeOf(o);\r\n      };\r\n  return _getPrototypeOf(o);\r\n}\r\n\r\nfunction _setPrototypeOf(o, p) {\r\n  _setPrototypeOf =\r\n    Object.setPrototypeOf ||\r\n    function _setPrototypeOf(o, p) {\r\n      o.__proto__ = p;\r\n      return o;\r\n    };\r\n\r\n  return _setPrototypeOf(o, p);\r\n}\r\n\r\nfunction _isNativeReflectConstruct() {\r\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\r\n  if (Reflect.construct.sham) return false;\r\n  if (typeof Proxy === \"function\") return true;\r\n\r\n  try {\r\n    Boolean.prototype.valueOf.call(\r\n      Reflect.construct(Boolean, [], function () {})\r\n    );\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction _assertThisInitialized(self) {\r\n  if (self === void 0) {\r\n    throw new ReferenceError(\r\n      \"this hasn't been initialised - super() hasn't been called\"\r\n    );\r\n  }\r\n\r\n  return self;\r\n}\r\n\r\nfunction _possibleConstructorReturn(self, call) {\r\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\r\n    return call;\r\n  }\r\n\r\n  return _assertThisInitialized(self);\r\n}\r\n\r\nfunction _createSuper(Derived) {\r\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\r\n\r\n  return function _createSuperInternal() {\r\n    var Super = _getPrototypeOf(Derived),\r\n      result;\r\n\r\n    if (hasNativeReflectConstruct) {\r\n      var NewTarget = _getPrototypeOf(this).constructor;\r\n\r\n      result = Reflect.construct(Super, arguments, NewTarget);\r\n    } else {\r\n      result = Super.apply(this, arguments);\r\n    }\r\n\r\n    return _possibleConstructorReturn(this, result);\r\n  };\r\n}\r\n\r\n/*eslint-disable*/\r\nvar libpannellum = (function (window, document, undefined$1) {\r\n  if (!window || !document) return;\r\n\r\n  function Renderer(container) {\r\n    var canvas = document.createElement(\"canvas\");\r\n    canvas.style.width = canvas.style.height = \"100%\";\r\n    container.appendChild(canvas);\r\n    var program, gl, vs, fs;\r\n    var fallbackImgSize;\r\n    var world;\r\n    var vtmps;\r\n    var pose;\r\n    var image, imageType, dynamic;\r\n    var texCoordBuffer, cubeVertBuf, cubeVertTexCoordBuf, cubeVertIndBuf;\r\n    var globalParams;\r\n    /**\r\n     * Initialize renderer.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @param {Image|Array|Object} image - Input image; format varies based on\r\n     *      `imageType`. For `equirectangular`, this is an image; for\r\n     *      `cubemap`, this is an array of images for the cube faces in the\r\n     *      order [+z, +x, -z, -x, +y, -y]; for `multires`, this is a\r\n     *      configuration object.\r\n     * @param {string} imageType - The type of the image: `equirectangular`,\r\n     *      `cubemap`, or `multires`.\r\n     * @param {boolean} dynamic - Whether or not the image is dynamic (e.g. video).\r\n     * @param {number} haov - Initial horizontal angle of view.\r\n     * @param {number} vaov - Initial vertical angle of view.\r\n     * @param {number} voffset - Initial vertical offset angle.\r\n     * @param {function} callback - Load callback function.\r\n     * @param {Object} [params] - Other configuration parameters (`horizonPitch`, `horizonRoll`, `backgroundColor`).\r\n     */\r\n\r\n    this.init = function (\r\n      _image,\r\n      _imageType,\r\n      _dynamic,\r\n      haov,\r\n      vaov,\r\n      voffset,\r\n      callback,\r\n      params\r\n    ) {\r\n      // Default argument for image type\r\n      if (_imageType === undefined$1) _imageType = \"equirectangular\";\r\n\r\n      if (\r\n        _imageType != \"equirectangular\" &&\r\n        _imageType != \"cubemap\" &&\r\n        _imageType != \"multires\"\r\n      ) {\r\n        console.log(\"Error: invalid image type specified!\");\r\n        throw {\r\n          type: \"config error\",\r\n        };\r\n      }\r\n\r\n      imageType = _imageType;\r\n      image = _image;\r\n      dynamic = _dynamic;\r\n      globalParams = params || {}; // Clear old data\r\n\r\n      if (program) {\r\n        if (vs) {\r\n          gl.detachShader(program, vs);\r\n          gl.deleteShader(vs);\r\n        }\r\n\r\n        if (fs) {\r\n          gl.detachShader(program, fs);\r\n          gl.deleteShader(fs);\r\n        }\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\r\n        if (program.texture) gl.deleteTexture(program.texture);\r\n        if (program.nodeCache)\r\n          for (var i = 0; i < program.nodeCache.length; i++) {\r\n            gl.deleteTexture(program.nodeCache[i].texture);\r\n          }\r\n        gl.deleteProgram(program);\r\n        program = undefined$1;\r\n      }\r\n\r\n      pose = undefined$1;\r\n      var s;\r\n      var faceMissing = false;\r\n      var cubeImgWidth;\r\n\r\n      if (imageType == \"cubemap\") {\r\n        for (s = 0; s < 6; s++) {\r\n          if (image[s].width > 0) {\r\n            if (cubeImgWidth === undefined$1) cubeImgWidth = image[s].width;\r\n            if (cubeImgWidth != image[s].width)\r\n              console.log(\r\n                \"Cube faces have inconsistent widths: \" +\r\n                  cubeImgWidth +\r\n                  \" vs. \" +\r\n                  image[s].width\r\n              );\r\n          } else faceMissing = true;\r\n        }\r\n      }\r\n\r\n      function fillMissingFaces(imgSize) {\r\n        if (faceMissing) {\r\n          // Fill any missing fallback/cubemap faces with background\r\n          var nbytes = imgSize * imgSize * 4; // RGB, plus non-functional alpha\r\n\r\n          var imageArray = new Uint8ClampedArray(nbytes);\r\n          var rgb = params.backgroundColor ? params.backgroundColor : [0, 0, 0];\r\n          rgb[0] *= 255;\r\n          rgb[1] *= 255;\r\n          rgb[2] *= 255; // Maybe filling could be done faster, see e.g. https://stackoverflow.com/questions/1295584/most-efficient-way-to-create-a-zero-filled-javascript-array\r\n\r\n          for (var i = 0; i < nbytes; i++) {\r\n            imageArray[i++] = rgb[0];\r\n            imageArray[i++] = rgb[1];\r\n            imageArray[i++] = rgb[2];\r\n          }\r\n\r\n          var backgroundSquare = new ImageData(imageArray, imgSize, imgSize);\r\n\r\n          for (s = 0; s < 6; s++) {\r\n            if (image[s].width == 0) image[s] = backgroundSquare;\r\n          }\r\n        }\r\n      } // This awful browser specific test exists because iOS 8/9 and IE 11\r\n      // don't display non-power-of-two cubemap textures but also don't\r\n      // throw an error (tested on an iPhone 5c / iOS 8.1.3 / iOS 9.2 /\r\n      // iOS 10.3.1).\r\n      // Therefore, the WebGL context is never created for these browsers for\r\n      // NPOT cubemaps, and the CSS 3D transform fallback renderer is used\r\n      // instead.\r\n\r\n      if (\r\n        !(\r\n          imageType == \"cubemap\" &&\r\n          (cubeImgWidth & (cubeImgWidth - 1)) !== 0 &&\r\n          (navigator.userAgent\r\n            .toLowerCase()\r\n            .match(/(iphone|ipod|ipad).* os 8_/) ||\r\n            navigator.userAgent\r\n              .toLowerCase()\r\n              .match(/(iphone|ipod|ipad).* os 9_/) ||\r\n            navigator.userAgent\r\n              .toLowerCase()\r\n              .match(/(iphone|ipod|ipad).* os 10_/) ||\r\n            navigator.userAgent.match(/Trident.*rv[ :]*11\\./))\r\n        )\r\n      ) {\r\n        // Enable WebGL on canvas\r\n        if (!gl)\r\n          gl = canvas.getContext(\"experimental-webgl\", {\r\n            alpha: false,\r\n            depth: false,\r\n          });\r\n        if (gl && gl.getError() == 1286) handleWebGLError1286();\r\n      } // If there is no WebGL, fall back to CSS 3D transform renderer.\r\n      // This will discard the image loaded so far and load the fallback image.\r\n      // While browser specific tests are usually frowned upon, the\r\n      // fallback viewer only really works with WebKit/Blink and IE 10/11\r\n      // (it doesn't work properly in Firefox).\r\n\r\n      if (\r\n        !gl &&\r\n        ((imageType == \"multires\" && image.hasOwnProperty(\"fallbackPath\")) ||\r\n          imageType == \"cubemap\") &&\r\n        (\"WebkitAppearance\" in document.documentElement.style ||\r\n          navigator.userAgent.match(/Trident.*rv[ :]*11\\./) ||\r\n          navigator.appVersion.indexOf(\"MSIE 10\") !== -1)\r\n      ) {\r\n        // Remove old world if it exists\r\n        if (world) {\r\n          container.removeChild(world);\r\n        } // Initialize renderer\r\n\r\n        world = document.createElement(\"div\");\r\n        world.className = \"pnlm-world\"; // Add images\r\n\r\n        var path;\r\n\r\n        if (image.basePath) {\r\n          path = image.basePath + image.fallbackPath;\r\n        } else {\r\n          path = image.fallbackPath;\r\n        }\r\n\r\n        var sides = [\"f\", \"r\", \"b\", \"l\", \"u\", \"d\"];\r\n        var loaded = 0;\r\n\r\n        var onLoad = function onLoad() {\r\n          // Draw image on canvas\r\n          var faceCanvas = document.createElement(\"canvas\");\r\n          faceCanvas.className = \"pnlm-face pnlm-\" + sides[this.side] + \"face\";\r\n          world.appendChild(faceCanvas);\r\n          var faceContext = faceCanvas.getContext(\"2d\");\r\n          faceCanvas.style.width = this.width + 4 + \"px\";\r\n          faceCanvas.style.height = this.height + 4 + \"px\";\r\n          faceCanvas.width = this.width + 4;\r\n          faceCanvas.height = this.height + 4;\r\n          faceContext.drawImage(this, 2, 2);\r\n          var imgData = faceContext.getImageData(\r\n            0,\r\n            0,\r\n            faceCanvas.width,\r\n            faceCanvas.height\r\n          );\r\n          var data = imgData.data; // Duplicate edge pixels\r\n\r\n          var i;\r\n          var j;\r\n\r\n          for (i = 2; i < faceCanvas.width - 2; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[(i + faceCanvas.width) * 4 + j] =\r\n                data[(i + faceCanvas.width * 2) * 4 + j];\r\n              data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j] =\r\n                data[(i + faceCanvas.width * (faceCanvas.height - 3)) * 4 + j];\r\n            }\r\n          }\r\n\r\n          for (i = 2; i < faceCanvas.height - 2; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[(i * faceCanvas.width + 1) * 4 + j] =\r\n                data[(i * faceCanvas.width + 2) * 4 + j];\r\n              data[((i + 1) * faceCanvas.width - 2) * 4 + j] =\r\n                data[((i + 1) * faceCanvas.width - 3) * 4 + j];\r\n            }\r\n          }\r\n\r\n          for (j = 0; j < 4; j++) {\r\n            data[(faceCanvas.width + 1) * 4 + j] =\r\n              data[(faceCanvas.width * 2 + 2) * 4 + j];\r\n            data[(faceCanvas.width * 2 - 2) * 4 + j] =\r\n              data[(faceCanvas.width * 3 - 3) * 4 + j];\r\n            data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j] =\r\n              data[(faceCanvas.width * (faceCanvas.height - 3) + 2) * 4 + j];\r\n            data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j] =\r\n              data[(faceCanvas.width * (faceCanvas.height - 2) - 3) * 4 + j];\r\n          }\r\n\r\n          for (i = 1; i < faceCanvas.width - 1; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[i * 4 + j] = data[(i + faceCanvas.width) * 4 + j];\r\n              data[(i + faceCanvas.width * (faceCanvas.height - 1)) * 4 + j] =\r\n                data[(i + faceCanvas.width * (faceCanvas.height - 2)) * 4 + j];\r\n            }\r\n          }\r\n\r\n          for (i = 1; i < faceCanvas.height - 1; i++) {\r\n            for (j = 0; j < 4; j++) {\r\n              data[i * faceCanvas.width * 4 + j] =\r\n                data[(i * faceCanvas.width + 1) * 4 + j];\r\n              data[((i + 1) * faceCanvas.width - 1) * 4 + j] =\r\n                data[((i + 1) * faceCanvas.width - 2) * 4 + j];\r\n            }\r\n          }\r\n\r\n          for (j = 0; j < 4; j++) {\r\n            data[j] = data[(faceCanvas.width + 1) * 4 + j];\r\n            data[(faceCanvas.width - 1) * 4 + j] =\r\n              data[(faceCanvas.width * 2 - 2) * 4 + j];\r\n            data[faceCanvas.width * (faceCanvas.height - 1) * 4 + j] =\r\n              data[(faceCanvas.width * (faceCanvas.height - 2) + 1) * 4 + j];\r\n            data[(faceCanvas.width * faceCanvas.height - 1) * 4 + j] =\r\n              data[(faceCanvas.width * (faceCanvas.height - 1) - 2) * 4 + j];\r\n          } // Draw image width duplicated edge pixels on canvas\r\n\r\n          faceContext.putImageData(imgData, 0, 0);\r\n          incLoaded.call(this);\r\n        };\r\n\r\n        var incLoaded = function incLoaded() {\r\n          if (this.width > 0) {\r\n            if (fallbackImgSize === undefined$1) fallbackImgSize = this.width;\r\n            if (fallbackImgSize != this.width)\r\n              console.log(\r\n                \"Fallback faces have inconsistent widths: \" +\r\n                  fallbackImgSize +\r\n                  \" vs. \" +\r\n                  this.width\r\n              );\r\n          } else faceMissing = true;\r\n\r\n          loaded++;\r\n\r\n          if (loaded == 6) {\r\n            fallbackImgSize = this.width;\r\n            container.appendChild(world);\r\n            callback();\r\n          }\r\n        };\r\n\r\n        faceMissing = false;\r\n\r\n        for (s = 0; s < 6; s++) {\r\n          var faceImg = new Image();\r\n          faceImg.crossOrigin = globalParams.crossOrigin\r\n            ? globalParams.crossOrigin\r\n            : \"anonymous\";\r\n          faceImg.side = s;\r\n          faceImg.onload = onLoad;\r\n          faceImg.onerror = incLoaded; // ignore missing face to support partial fallback image\r\n\r\n          if (imageType == \"multires\") {\r\n            faceImg.src = path.replace(\"%s\", sides[s]) + \".\" + image.extension;\r\n          } else {\r\n            faceImg.src = image[s].src;\r\n          }\r\n        }\r\n\r\n        fillMissingFaces(fallbackImgSize);\r\n        return;\r\n      } else if (!gl) {\r\n        console.log(\"Error: no WebGL support detected!\");\r\n        throw {\r\n          type: \"no webgl\",\r\n        };\r\n      }\r\n\r\n      if (imageType == \"cubemap\") fillMissingFaces(cubeImgWidth);\r\n\r\n      if (image.basePath) {\r\n        image.fullpath = image.basePath + image.path;\r\n      } else {\r\n        image.fullpath = image.path;\r\n      }\r\n\r\n      image.invTileResolution = 1 / image.tileResolution;\r\n      var vertices = createCube();\r\n      vtmps = [];\r\n\r\n      for (s = 0; s < 6; s++) {\r\n        vtmps[s] = vertices.slice(s * 12, s * 12 + 12);\r\n        vertices = createCube();\r\n      } // Make sure image isn't too big\r\n\r\n      var maxWidth = 0;\r\n\r\n      if (imageType == \"equirectangular\") {\r\n        maxWidth = gl.getParameter(gl.MAX_TEXTURE_SIZE);\r\n\r\n        if (Math.max(image.width / 2, image.height) > maxWidth) {\r\n          console.log(\r\n            \"Error: The image is too big; it's \" +\r\n              image.width +\r\n              \"px wide, \" +\r\n              \"but this device's maximum supported size is \" +\r\n              maxWidth * 2 +\r\n              \"px.\"\r\n          );\r\n          throw {\r\n            type: \"webgl size error\",\r\n            width: image.width,\r\n            maxWidth: maxWidth * 2,\r\n          };\r\n        }\r\n      } else if (imageType == \"cubemap\") {\r\n        if (cubeImgWidth > gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE)) {\r\n          console.log(\r\n            \"Error: The image is too big; it's \" +\r\n              cubeImgWidth +\r\n              \"px wide, \" +\r\n              \"but this device's maximum supported size is \" +\r\n              maxWidth +\r\n              \"px.\"\r\n          );\r\n          throw {\r\n            type: \"webgl size error\",\r\n            width: cubeImgWidth,\r\n            maxWidth: maxWidth,\r\n          };\r\n        }\r\n      } // Store horizon pitch and roll if applicable\r\n\r\n      if (\r\n        params !== undefined$1 &&\r\n        (params.horizonPitch !== undefined$1 ||\r\n          params.horizonRoll !== undefined$1)\r\n      )\r\n        pose = [\r\n          params.horizonPitch == undefined$1 ? 0 : params.horizonPitch,\r\n          params.horizonRoll == undefined$1 ? 0 : params.horizonRoll,\r\n        ]; // Set 2d texture binding\r\n\r\n      var glBindType = gl.TEXTURE_2D; // Create viewport for entire canvas\r\n\r\n      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); // Check precision support\r\n\r\n      if (gl.getShaderPrecisionFormat) {\r\n        var precision = gl.getShaderPrecisionFormat(\r\n          gl.FRAGMENT_SHADER,\r\n          gl.HIGH_FLOAT\r\n        );\r\n\r\n        if (precision && precision.precision < 1) {\r\n          // `highp` precision not supported; https://stackoverflow.com/a/33308927\r\n          fragEquiCubeBase = fragEquiCubeBase.replace(\"highp\", \"mediump\");\r\n        }\r\n      } // Create vertex shader\r\n\r\n      vs = gl.createShader(gl.VERTEX_SHADER);\r\n      var vertexSrc = v;\r\n\r\n      if (imageType == \"multires\") {\r\n        vertexSrc = vMulti;\r\n      }\r\n\r\n      gl.shaderSource(vs, vertexSrc);\r\n      gl.compileShader(vs); // Create fragment shader\r\n\r\n      fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n      var fragmentSrc = fragEquirectangular;\r\n\r\n      if (imageType == \"cubemap\") {\r\n        glBindType = gl.TEXTURE_CUBE_MAP;\r\n        fragmentSrc = fragCube;\r\n      } else if (imageType == \"multires\") {\r\n        fragmentSrc = fragMulti;\r\n      }\r\n\r\n      gl.shaderSource(fs, fragmentSrc);\r\n      gl.compileShader(fs); // Link WebGL program\r\n\r\n      program = gl.createProgram();\r\n      gl.attachShader(program, vs);\r\n      gl.attachShader(program, fs);\r\n      gl.linkProgram(program); // Log errors\r\n\r\n      if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))\r\n        console.log(gl.getShaderInfoLog(vs));\r\n      if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))\r\n        console.log(gl.getShaderInfoLog(fs));\r\n      if (!gl.getProgramParameter(program, gl.LINK_STATUS))\r\n        console.log(gl.getProgramInfoLog(program)); // Use WebGL program\r\n\r\n      gl.useProgram(program);\r\n      program.drawInProgress = false; // Set background clear color (does not apply to cubemap/fallback image)\r\n\r\n      var color = params.backgroundColor ? params.backgroundColor : [0, 0, 0];\r\n      gl.clearColor(color[0], color[1], color[2], 1.0);\r\n      gl.clear(gl.COLOR_BUFFER_BIT); // Look up texture coordinates location\r\n\r\n      program.texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\");\r\n      gl.enableVertexAttribArray(program.texCoordLocation);\r\n\r\n      if (imageType != \"multires\") {\r\n        // Provide texture coordinates for rectangle\r\n        if (!texCoordBuffer) texCoordBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\r\n        gl.bufferData(\r\n          gl.ARRAY_BUFFER,\r\n          new Float32Array([-1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1]),\r\n          gl.STATIC_DRAW\r\n        );\r\n        gl.vertexAttribPointer(\r\n          program.texCoordLocation,\r\n          2,\r\n          gl.FLOAT,\r\n          false,\r\n          0,\r\n          0\r\n        ); // Pass aspect ratio\r\n\r\n        program.aspectRatio = gl.getUniformLocation(program, \"u_aspectRatio\");\r\n        gl.uniform1f(\r\n          program.aspectRatio,\r\n          gl.drawingBufferWidth / gl.drawingBufferHeight\r\n        ); // Locate psi, theta, focal length, horizontal extent, vertical extent, and vertical offset\r\n\r\n        program.psi = gl.getUniformLocation(program, \"u_psi\");\r\n        program.theta = gl.getUniformLocation(program, \"u_theta\");\r\n        program.f = gl.getUniformLocation(program, \"u_f\");\r\n        program.h = gl.getUniformLocation(program, \"u_h\");\r\n        program.v = gl.getUniformLocation(program, \"u_v\");\r\n        program.vo = gl.getUniformLocation(program, \"u_vo\");\r\n        program.rot = gl.getUniformLocation(program, \"u_rot\"); // Pass horizontal extent, vertical extent, and vertical offset\r\n\r\n        gl.uniform1f(program.h, haov / (Math.PI * 2.0));\r\n        gl.uniform1f(program.v, vaov / Math.PI);\r\n        gl.uniform1f(program.vo, (voffset / Math.PI) * 2); // Set background color\r\n\r\n        if (imageType == \"equirectangular\") {\r\n          program.backgroundColor = gl.getUniformLocation(\r\n            program,\r\n            \"u_backgroundColor\"\r\n          );\r\n          gl.uniform4fv(program.backgroundColor, color.concat([1]));\r\n        } // Create texture\r\n\r\n        program.texture = gl.createTexture();\r\n        gl.bindTexture(glBindType, program.texture); // Upload images to texture depending on type\r\n\r\n        if (imageType == \"cubemap\") {\r\n          // Load all six sides of the cube map\r\n          gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_POSITIVE_X,\r\n            0,\r\n            gl.RGB,\r\n            gl.RGB,\r\n            gl.UNSIGNED_BYTE,\r\n            image[1]\r\n          );\r\n          gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_NEGATIVE_X,\r\n            0,\r\n            gl.RGB,\r\n            gl.RGB,\r\n            gl.UNSIGNED_BYTE,\r\n            image[3]\r\n          );\r\n          gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_POSITIVE_Y,\r\n            0,\r\n            gl.RGB,\r\n            gl.RGB,\r\n            gl.UNSIGNED_BYTE,\r\n            image[4]\r\n          );\r\n          gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,\r\n            0,\r\n            gl.RGB,\r\n            gl.RGB,\r\n            gl.UNSIGNED_BYTE,\r\n            image[5]\r\n          );\r\n          gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_POSITIVE_Z,\r\n            0,\r\n            gl.RGB,\r\n            gl.RGB,\r\n            gl.UNSIGNED_BYTE,\r\n            image[0]\r\n          );\r\n          gl.texImage2D(\r\n            gl.TEXTURE_CUBE_MAP_NEGATIVE_Z,\r\n            0,\r\n            gl.RGB,\r\n            gl.RGB,\r\n            gl.UNSIGNED_BYTE,\r\n            image[2]\r\n          );\r\n        } else {\r\n          if (image.width <= maxWidth) {\r\n            gl.uniform1i(gl.getUniformLocation(program, \"u_splitImage\"), 0); // Upload image to the texture\r\n\r\n            gl.texImage2D(\r\n              glBindType,\r\n              0,\r\n              gl.RGB,\r\n              gl.RGB,\r\n              gl.UNSIGNED_BYTE,\r\n              image\r\n            );\r\n          } else {\r\n            // Image needs to be split into two parts due to texture size limits\r\n            gl.uniform1i(gl.getUniformLocation(program, \"u_splitImage\"), 1); // Draw image on canvas\r\n\r\n            var cropCanvas = document.createElement(\"canvas\");\r\n            cropCanvas.width = image.width / 2;\r\n            cropCanvas.height = image.height;\r\n            var cropContext = cropCanvas.getContext(\"2d\");\r\n            cropContext.drawImage(image, 0, 0); // Upload first half of image to the texture\r\n\r\n            var cropImage = cropContext.getImageData(\r\n              0,\r\n              0,\r\n              image.width / 2,\r\n              image.height\r\n            );\r\n            gl.texImage2D(\r\n              glBindType,\r\n              0,\r\n              gl.RGB,\r\n              gl.RGB,\r\n              gl.UNSIGNED_BYTE,\r\n              cropImage\r\n            ); // Create and bind texture for second half of image\r\n\r\n            program.texture2 = gl.createTexture();\r\n            gl.activeTexture(gl.TEXTURE1);\r\n            gl.bindTexture(glBindType, program.texture2);\r\n            gl.uniform1i(gl.getUniformLocation(program, \"u_image1\"), 1); // Upload second half of image to the texture\r\n\r\n            cropContext.drawImage(image, -image.width / 2, 0);\r\n            cropImage = cropContext.getImageData(\r\n              0,\r\n              0,\r\n              image.width / 2,\r\n              image.height\r\n            );\r\n            gl.texImage2D(\r\n              glBindType,\r\n              0,\r\n              gl.RGB,\r\n              gl.RGB,\r\n              gl.UNSIGNED_BYTE,\r\n              cropImage\r\n            ); // Set parameters for rendering any size\r\n\r\n            gl.texParameteri(glBindType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(glBindType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(glBindType, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n            gl.texParameteri(glBindType, gl.TEXTURE_MAG_FILTER, gl.LINEAR); // Reactivate first texture unit\r\n\r\n            gl.activeTexture(gl.TEXTURE0);\r\n          }\r\n        } // Set parameters for rendering any size\r\n\r\n        gl.texParameteri(glBindType, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(glBindType, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(glBindType, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n        gl.texParameteri(glBindType, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n      } else {\r\n        // Look up vertex coordinates location\r\n        program.vertPosLocation = gl.getAttribLocation(program, \"a_vertCoord\");\r\n        gl.enableVertexAttribArray(program.vertPosLocation); // Create buffers\r\n\r\n        if (!cubeVertBuf) cubeVertBuf = gl.createBuffer();\r\n        if (!cubeVertTexCoordBuf) cubeVertTexCoordBuf = gl.createBuffer();\r\n        if (!cubeVertIndBuf) cubeVertIndBuf = gl.createBuffer(); // Bind texture coordinate buffer and pass coordinates to WebGL\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);\r\n        gl.bufferData(\r\n          gl.ARRAY_BUFFER,\r\n          new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),\r\n          gl.STATIC_DRAW\r\n        ); // Bind square index buffer and pass indicies to WebGL\r\n\r\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertIndBuf);\r\n        gl.bufferData(\r\n          gl.ELEMENT_ARRAY_BUFFER,\r\n          new Uint16Array([0, 1, 2, 0, 2, 3]),\r\n          gl.STATIC_DRAW\r\n        ); // Find uniforms\r\n\r\n        program.perspUniform = gl.getUniformLocation(program, \"u_perspMatrix\");\r\n        program.cubeUniform = gl.getUniformLocation(program, \"u_cubeMatrix\"); //program.colorUniform = gl.getUniformLocation(program, 'u_color');\r\n\r\n        program.level = -1;\r\n        program.currentNodes = [];\r\n        program.nodeCache = [];\r\n        program.nodeCacheTimestamp = 0;\r\n      } // Check if there was an error\r\n\r\n      var err = gl.getError();\r\n\r\n      if (err !== 0) {\r\n        console.log(\"Error: Something went wrong with WebGL!\", err);\r\n        throw {\r\n          type: \"webgl error\",\r\n        };\r\n      }\r\n\r\n      callback();\r\n    };\r\n    /**\r\n     * Destroy renderer.\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\r\n\r\n    this.destroy = function () {\r\n      if (container !== undefined$1) {\r\n        if (canvas !== undefined$1 && container.contains(canvas)) {\r\n          container.removeChild(canvas);\r\n        }\r\n\r\n        if (world !== undefined$1 && container.contains(world)) {\r\n          container.removeChild(world);\r\n        }\r\n      }\r\n\r\n      if (gl) {\r\n        // The spec says this is only supposed to simulate losing the WebGL\r\n        // context, but in practice it tends to actually free the memory.\r\n        var extension = gl.getExtension(\"WEBGL_lose_context\");\r\n        if (extension) extension.loseContext();\r\n      }\r\n    };\r\n    /**\r\n     * Resize renderer (call after resizing container).\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\r\n\r\n    this.resize = function () {\r\n      var pixelRatio = window.devicePixelRatio || 1;\r\n      canvas.width = canvas.clientWidth * pixelRatio;\r\n      canvas.height = canvas.clientHeight * pixelRatio;\r\n\r\n      if (gl) {\r\n        if (gl.getError() == 1286) handleWebGLError1286();\r\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\r\n\r\n        if (imageType != \"multires\") {\r\n          gl.uniform1f(\r\n            program.aspectRatio,\r\n            canvas.clientWidth / canvas.clientHeight\r\n          );\r\n        }\r\n      }\r\n    }; // Initialize canvas size\r\n\r\n    this.resize();\r\n    /**\r\n     * Set renderer horizon pitch and roll.\r\n     * @memberof Renderer\r\n     * @instance\r\n     */\r\n\r\n    this.setPose = function (horizonPitch, horizonRoll) {\r\n      pose = [horizonPitch, horizonRoll];\r\n    };\r\n    /**\r\n     * Render new view of panorama.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @param {number} pitch - Pitch to render at (in radians).\r\n     * @param {number} yaw - Yaw to render at (in radians).\r\n     * @param {number} hfov - Horizontal field of view to render with (in radians).\r\n     * @param {Object} [params] - Extra configuration parameters.\r\n     * @param {number} [params.roll] - Camera roll (in radians).\r\n     * @param {boolean} [params.returnImage] - Return rendered image?\r\n     */\r\n\r\n    this.render = function (pitch, yaw, hfov, params) {\r\n      var focal,\r\n        i,\r\n        s,\r\n        roll = 0;\r\n      if (params === undefined$1) params = {};\r\n      if (params.roll) roll = params.roll; // Apply pitch and roll transformation if applicable\r\n\r\n      if (pose !== undefined$1) {\r\n        var horizonPitch = pose[0],\r\n          horizonRoll = pose[1]; // Calculate new pitch and yaw\r\n\r\n        var orig_pitch = pitch,\r\n          orig_yaw = yaw,\r\n          x =\r\n            Math.cos(horizonRoll) * Math.sin(pitch) * Math.sin(horizonPitch) +\r\n            Math.cos(pitch) *\r\n              (Math.cos(horizonPitch) * Math.cos(yaw) +\r\n                Math.sin(horizonRoll) * Math.sin(horizonPitch) * Math.sin(yaw)),\r\n          y =\r\n            -Math.sin(pitch) * Math.sin(horizonRoll) +\r\n            Math.cos(pitch) * Math.cos(horizonRoll) * Math.sin(yaw),\r\n          z =\r\n            Math.cos(horizonRoll) * Math.cos(horizonPitch) * Math.sin(pitch) +\r\n            Math.cos(pitch) *\r\n              (-Math.cos(yaw) * Math.sin(horizonPitch) +\r\n                Math.cos(horizonPitch) * Math.sin(horizonRoll) * Math.sin(yaw));\r\n        pitch = Math.asin(Math.max(Math.min(z, 1), -1));\r\n        yaw = Math.atan2(y, x); // Calculate roll\r\n\r\n        var v = [\r\n            Math.cos(orig_pitch) *\r\n              (Math.sin(horizonRoll) *\r\n                Math.sin(horizonPitch) *\r\n                Math.cos(orig_yaw) -\r\n                Math.cos(horizonPitch) * Math.sin(orig_yaw)),\r\n            Math.cos(orig_pitch) * Math.cos(horizonRoll) * Math.cos(orig_yaw),\r\n            Math.cos(orig_pitch) *\r\n              (Math.cos(horizonPitch) *\r\n                Math.sin(horizonRoll) *\r\n                Math.cos(orig_yaw) +\r\n                Math.sin(orig_yaw) * Math.sin(horizonPitch)),\r\n          ],\r\n          w = [\r\n            -Math.cos(pitch) * Math.sin(yaw),\r\n            Math.cos(pitch) * Math.cos(yaw),\r\n          ];\r\n        var roll_adj = Math.acos(\r\n          Math.max(\r\n            Math.min(\r\n              (v[0] * w[0] + v[1] * w[1]) /\r\n                (Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]) *\r\n                  Math.sqrt(w[0] * w[0] + w[1] * w[1])),\r\n              1\r\n            ),\r\n            -1\r\n          )\r\n        );\r\n        if (v[2] < 0) roll_adj = 2 * Math.PI - roll_adj;\r\n        roll += roll_adj;\r\n      } // If no WebGL\r\n\r\n      if (!gl && (imageType == \"multires\" || imageType == \"cubemap\")) {\r\n        // Determine face transforms\r\n        s = fallbackImgSize / 2;\r\n        var transforms = {\r\n          f:\r\n            \"translate3d(-\" + (s + 2) + \"px, -\" + (s + 2) + \"px, -\" + s + \"px)\",\r\n          b:\r\n            \"translate3d(\" +\r\n            (s + 2) +\r\n            \"px, -\" +\r\n            (s + 2) +\r\n            \"px, \" +\r\n            s +\r\n            \"px) rotateX(180deg) rotateZ(180deg)\",\r\n          u:\r\n            \"translate3d(-\" +\r\n            (s + 2) +\r\n            \"px, -\" +\r\n            s +\r\n            \"px, \" +\r\n            (s + 2) +\r\n            \"px) rotateX(270deg)\",\r\n          d:\r\n            \"translate3d(-\" +\r\n            (s + 2) +\r\n            \"px, \" +\r\n            s +\r\n            \"px, -\" +\r\n            (s + 2) +\r\n            \"px) rotateX(90deg)\",\r\n          l:\r\n            \"translate3d(-\" +\r\n            s +\r\n            \"px, -\" +\r\n            (s + 2) +\r\n            \"px, \" +\r\n            (s + 2) +\r\n            \"px) rotateX(180deg) rotateY(90deg) rotateZ(180deg)\",\r\n          r:\r\n            \"translate3d(\" +\r\n            s +\r\n            \"px, -\" +\r\n            (s + 2) +\r\n            \"px, -\" +\r\n            (s + 2) +\r\n            \"px) rotateY(270deg)\",\r\n        };\r\n        focal = 1 / Math.tan(hfov / 2);\r\n        var zoom = (focal * canvas.clientWidth) / 2 + \"px\";\r\n        var transform =\r\n          \"perspective(\" +\r\n          zoom +\r\n          \") translateZ(\" +\r\n          zoom +\r\n          \") rotateX(\" +\r\n          pitch +\r\n          \"rad) rotateY(\" +\r\n          yaw +\r\n          \"rad) \"; // Apply face transforms\r\n\r\n        var faces = Object.keys(transforms);\r\n\r\n        for (i = 0; i < 6; i++) {\r\n          var face = world.querySelector(\".pnlm-\" + faces[i] + \"face\");\r\n          if (!face) continue; // ignore missing face to support partial cubemap/fallback image\r\n\r\n          face.style.webkitTransform = transform + transforms[faces[i]];\r\n          face.style.transform = transform + transforms[faces[i]];\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if (imageType != \"multires\") {\r\n        // Calculate focal length from vertical field of view\r\n        var vfov =\r\n          2 *\r\n          Math.atan(\r\n            Math.tan(hfov * 0.5) /\r\n              (gl.drawingBufferWidth / gl.drawingBufferHeight)\r\n          );\r\n        focal = 1 / Math.tan(vfov * 0.5); // Pass psi, theta, roll, and focal length\r\n\r\n        gl.uniform1f(program.psi, yaw);\r\n        gl.uniform1f(program.theta, pitch);\r\n        gl.uniform1f(program.rot, roll);\r\n        gl.uniform1f(program.f, focal);\r\n\r\n        if (dynamic === true) {\r\n          // Update texture if dynamic\r\n          if (imageType == \"equirectangular\") {\r\n            gl.bindTexture(gl.TEXTURE_2D, program.texture);\r\n            gl.texImage2D(\r\n              gl.TEXTURE_2D,\r\n              0,\r\n              gl.RGB,\r\n              gl.RGB,\r\n              gl.UNSIGNED_BYTE,\r\n              image\r\n            );\r\n          }\r\n        } // Draw using current buffer\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, 6);\r\n      } else {\r\n        // Create perspective matrix\r\n        var perspMatrix = makePersp(\r\n          hfov,\r\n          gl.drawingBufferWidth / gl.drawingBufferHeight,\r\n          0.1,\r\n          100.0\r\n        ); // Find correct zoom level\r\n\r\n        checkZoom(hfov); // Create rotation matrix\r\n\r\n        var matrix = identityMatrix3();\r\n        matrix = rotateMatrix(matrix, -roll, \"z\");\r\n        matrix = rotateMatrix(matrix, -pitch, \"x\");\r\n        matrix = rotateMatrix(matrix, yaw, \"y\");\r\n        matrix = makeMatrix4(matrix); // Set matrix uniforms\r\n\r\n        gl.uniformMatrix4fv(\r\n          program.perspUniform,\r\n          false,\r\n          new Float32Array(transposeMatrix4(perspMatrix))\r\n        );\r\n        gl.uniformMatrix4fv(\r\n          program.cubeUniform,\r\n          false,\r\n          new Float32Array(transposeMatrix4(matrix))\r\n        ); // Find current nodes\r\n\r\n        var rotPersp = rotatePersp(perspMatrix, matrix);\r\n        program.nodeCache.sort(multiresNodeSort);\r\n\r\n        if (\r\n          program.nodeCache.length > 200 &&\r\n          program.nodeCache.length > program.currentNodes.length + 50\r\n        ) {\r\n          // Remove older nodes from cache\r\n          var removed = program.nodeCache.splice(\r\n            200,\r\n            program.nodeCache.length - 200\r\n          );\r\n\r\n          for (var j = 0; j < removed.length; j++) {\r\n            // Explicitly delete textures\r\n            gl.deleteTexture(removed[j].texture);\r\n          }\r\n        }\r\n\r\n        program.currentNodes = [];\r\n        var sides = [\"f\", \"b\", \"u\", \"d\", \"l\", \"r\"];\r\n\r\n        for (s = 0; s < 6; s++) {\r\n          var ntmp = new MultiresNode(\r\n            vtmps[s],\r\n            sides[s],\r\n            1,\r\n            0,\r\n            0,\r\n            image.fullpath\r\n          );\r\n          testMultiresNode(rotPersp, ntmp, pitch, yaw);\r\n        }\r\n\r\n        program.currentNodes.sort(multiresNodeRenderSort); // Unqueue any pending requests for nodes that are no longer visible\r\n\r\n        for (i = pendingTextureRequests.length - 1; i >= 0; i--) {\r\n          if (\r\n            program.currentNodes.indexOf(pendingTextureRequests[i].node) === -1\r\n          ) {\r\n            pendingTextureRequests[i].node.textureLoad = false;\r\n            pendingTextureRequests.splice(i, 1);\r\n          }\r\n        } // Allow one request to be pending, so that we can create a texture buffer for that in advance of loading actually beginning\r\n\r\n        if (pendingTextureRequests.length === 0) {\r\n          for (i = 0; i < program.currentNodes.length; i++) {\r\n            var node = program.currentNodes[i];\r\n\r\n            if (!node.texture && !node.textureLoad) {\r\n              node.textureLoad = true;\r\n              setTimeout(processNextTile, 0, node); // Only process one tile per frame to improve responsiveness\r\n\r\n              break;\r\n            }\r\n          }\r\n        } // Draw tiles\r\n\r\n        multiresDraw();\r\n      }\r\n\r\n      if (params.returnImage !== undefined$1) {\r\n        return canvas.toDataURL(\"image/png\");\r\n      }\r\n    };\r\n    /**\r\n     * Check if images are loading.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @returns {boolean} Whether or not images are loading.\r\n     */\r\n\r\n    this.isLoading = function () {\r\n      if (gl && imageType == \"multires\") {\r\n        for (var i = 0; i < program.currentNodes.length; i++) {\r\n          if (!program.currentNodes[i].textureLoaded) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n\r\n      return false;\r\n    };\r\n    /**\r\n     * Retrieve renderer's canvas.\r\n     * @memberof Renderer\r\n     * @instance\r\n     * @returns {HTMLElement} Renderer's canvas.\r\n     */\r\n\r\n    this.getCanvas = function () {\r\n      return canvas;\r\n    };\r\n    /**\r\n     * Sorting method for multires nodes.\r\n     * @private\r\n     * @param {MultiresNode} a - First node.\r\n     * @param {MultiresNode} b - Second node.\r\n     * @returns {number} Base tiles first, then higher timestamp first.\r\n     */\r\n\r\n    function multiresNodeSort(a, b) {\r\n      // Base tiles are always first\r\n      if (a.level == 1 && b.level != 1) {\r\n        return -1;\r\n      }\r\n\r\n      if (b.level == 1 && a.level != 1) {\r\n        return 1;\r\n      } // Higher timestamp first\r\n\r\n      return b.timestamp - a.timestamp;\r\n    }\r\n    /**\r\n     * Sorting method for multires node rendering.\r\n     * @private\r\n     * @param {MultiresNode} a - First node.\r\n     * @param {MultiresNode} b - Second node.\r\n     * @returns {number} Lower zoom levels first, then closest to center first.\r\n     */\r\n\r\n    function multiresNodeRenderSort(a, b) {\r\n      // Lower zoom levels first\r\n      if (a.level != b.level) {\r\n        return a.level - b.level;\r\n      } // Lower distance from center first\r\n\r\n      return a.diff - b.diff;\r\n    }\r\n    /**\r\n     * Draws multires nodes.\r\n     * @private\r\n     */\r\n\r\n    function multiresDraw() {\r\n      if (!program.drawInProgress) {\r\n        program.drawInProgress = true;\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n        for (var i = 0; i < program.currentNodes.length; i++) {\r\n          if (program.currentNodes[i].textureLoaded > 1) {\r\n            //var color = program.currentNodes[i].color;\r\n            //gl.uniform4f(program.colorUniform, color[0], color[1], color[2], 1.0);\r\n            // Bind vertex buffer and pass vertices to WebGL\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertBuf);\r\n            gl.bufferData(\r\n              gl.ARRAY_BUFFER,\r\n              new Float32Array(program.currentNodes[i].vertices),\r\n              gl.STATIC_DRAW\r\n            );\r\n            gl.vertexAttribPointer(\r\n              program.vertPosLocation,\r\n              3,\r\n              gl.FLOAT,\r\n              false,\r\n              0,\r\n              0\r\n            ); // Prep for texture\r\n\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertTexCoordBuf);\r\n            gl.vertexAttribPointer(\r\n              program.texCoordLocation,\r\n              2,\r\n              gl.FLOAT,\r\n              false,\r\n              0,\r\n              0\r\n            ); // Bind texture and draw tile\r\n\r\n            gl.bindTexture(gl.TEXTURE_2D, program.currentNodes[i].texture); // Bind program.currentNodes[i].texture to TEXTURE0\r\n\r\n            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\r\n          }\r\n        }\r\n\r\n        program.drawInProgress = false;\r\n      }\r\n    }\r\n    /**\r\n     * Creates new multires node.\r\n     * @constructor\r\n     * @private\r\n     * @param {number[]} vertices - Node's verticies.\r\n     * @param {string} side - Node's cube face.\r\n     * @param {number} level - Node's zoom level.\r\n     * @param {number} x - Node's x position.\r\n     * @param {number} y - Node's y position.\r\n     * @param {string} path - Node's path.\r\n     */\r\n\r\n    function MultiresNode(vertices, side, level, x, y, path) {\r\n      this.vertices = vertices;\r\n      this.side = side;\r\n      this.level = level;\r\n      this.x = x;\r\n      this.y = y;\r\n      this.path = path\r\n        .replace(\"%s\", side)\r\n        .replace(\"%l\", level)\r\n        .replace(\"%x\", x)\r\n        .replace(\"%y\", y);\r\n    }\r\n    /**\r\n     * Test if multires node is visible. If it is, add it to current nodes,\r\n     * load its texture, and load appropriate child nodes.\r\n     * @private\r\n     * @param {number[]} rotPersp - Rotated perspective matrix.\r\n     * @param {MultiresNode} node - Multires node to check.\r\n     * @param {number} pitch - Pitch to check at.\r\n     * @param {number} yaw - Yaw to check at.\r\n     * @param {number} hfov - Horizontal field of view to check at.\r\n     */\r\n\r\n    function testMultiresNode(rotPersp, node, pitch, yaw, hfov) {\r\n      if (checkSquareInView(rotPersp, node.vertices)) {\r\n        // Calculate central angle between center of view and center of tile\r\n        var v = node.vertices;\r\n        var x = v[0] + v[3] + v[6] + v[9];\r\n        var y = v[1] + v[4] + v[7] + v[10];\r\n        var z = v[2] + v[5] + v[8] + v[11];\r\n        var r = Math.sqrt(x * x + y * y + z * z);\r\n        var theta = Math.asin(z / r);\r\n        var phi = Math.atan2(y, x);\r\n        var ydiff = phi - yaw;\r\n        ydiff +=\r\n          ydiff > Math.PI ? -2 * Math.PI : ydiff < -Math.PI ? 2 * Math.PI : 0;\r\n        ydiff = Math.abs(ydiff);\r\n        node.diff = Math.acos(\r\n          Math.sin(pitch) * Math.sin(theta) +\r\n            Math.cos(pitch) * Math.cos(theta) * Math.cos(ydiff)\r\n        ); // Add node to current nodes and load texture if needed\r\n\r\n        var inCurrent = false;\r\n\r\n        for (var k = 0; k < program.nodeCache.length; k++) {\r\n          if (program.nodeCache[k].path == node.path) {\r\n            inCurrent = true;\r\n            program.nodeCache[k].timestamp = program.nodeCacheTimestamp++;\r\n            program.nodeCache[k].diff = node.diff;\r\n            program.currentNodes.push(program.nodeCache[k]);\r\n            break;\r\n          }\r\n        }\r\n\r\n        if (!inCurrent) {\r\n          //node.color = [Math.random(), Math.random(), Math.random()];\r\n          node.timestamp = program.nodeCacheTimestamp++;\r\n          program.currentNodes.push(node);\r\n          program.nodeCache.push(node);\r\n        } // TODO: Test error\r\n        // Create child nodes\r\n\r\n        if (node.level < program.level) {\r\n          var cubeSize =\r\n            image.cubeResolution * Math.pow(2, node.level - image.maxLevel);\r\n          var numTiles = Math.ceil(cubeSize * image.invTileResolution) - 1;\r\n          var doubleTileSize = (cubeSize % image.tileResolution) * 2;\r\n          var lastTileSize = (cubeSize * 2) % image.tileResolution;\r\n\r\n          if (lastTileSize === 0) {\r\n            lastTileSize = image.tileResolution;\r\n          }\r\n\r\n          if (doubleTileSize === 0) {\r\n            doubleTileSize = image.tileResolution * 2;\r\n          }\r\n\r\n          var f = 0.5;\r\n\r\n          if (node.x == numTiles || node.y == numTiles) {\r\n            f =\r\n              1.0 -\r\n              image.tileResolution / (image.tileResolution + lastTileSize);\r\n          }\r\n\r\n          var i = 1.0 - f;\r\n          var children = [];\r\n          var vtmp, ntmp;\r\n          var f1 = f,\r\n            f2 = f,\r\n            f3 = f,\r\n            i1 = i,\r\n            i2 = i,\r\n            i3 = i; // Handle non-symmetric tiles\r\n\r\n          if (lastTileSize < image.tileResolution) {\r\n            if (node.x == numTiles && node.y != numTiles) {\r\n              f2 = 0.5;\r\n              i2 = 0.5;\r\n\r\n              if (node.side == \"d\" || node.side == \"u\") {\r\n                f3 = 0.5;\r\n                i3 = 0.5;\r\n              }\r\n            } else if (node.x != numTiles && node.y == numTiles) {\r\n              f1 = 0.5;\r\n              i1 = 0.5;\r\n\r\n              if (node.side == \"l\" || node.side == \"r\") {\r\n                f3 = 0.5;\r\n                i3 = 0.5;\r\n              }\r\n            }\r\n          } // Handle small tiles that have fewer than four children\r\n\r\n          if (doubleTileSize <= image.tileResolution) {\r\n            if (node.x == numTiles) {\r\n              f1 = 0;\r\n              i1 = 1;\r\n\r\n              if (node.side == \"l\" || node.side == \"r\") {\r\n                f3 = 0;\r\n                i3 = 1;\r\n              }\r\n            }\r\n\r\n            if (node.y == numTiles) {\r\n              f2 = 0;\r\n              i2 = 1;\r\n\r\n              if (node.side == \"d\" || node.side == \"u\") {\r\n                f3 = 0;\r\n                i3 = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          vtmp = [\r\n            v[0],\r\n            v[1],\r\n            v[2],\r\n            v[0] * f1 + v[3] * i1,\r\n            v[1] * f + v[4] * i,\r\n            v[2] * f3 + v[5] * i3,\r\n            v[0] * f1 + v[6] * i1,\r\n            v[1] * f2 + v[7] * i2,\r\n            v[2] * f3 + v[8] * i3,\r\n            v[0] * f + v[9] * i,\r\n            v[1] * f2 + v[10] * i2,\r\n            v[2] * f3 + v[11] * i3,\r\n          ];\r\n          ntmp = new MultiresNode(\r\n            vtmp,\r\n            node.side,\r\n            node.level + 1,\r\n            node.x * 2,\r\n            node.y * 2,\r\n            image.fullpath\r\n          );\r\n          children.push(ntmp);\r\n\r\n          if (!(node.x == numTiles && doubleTileSize <= image.tileResolution)) {\r\n            vtmp = [\r\n              v[0] * f1 + v[3] * i1,\r\n              v[1] * f + v[4] * i,\r\n              v[2] * f3 + v[5] * i3,\r\n              v[3],\r\n              v[4],\r\n              v[5],\r\n              v[3] * f + v[6] * i,\r\n              v[4] * f2 + v[7] * i2,\r\n              v[5] * f3 + v[8] * i3,\r\n              v[0] * f1 + v[6] * i1,\r\n              v[1] * f2 + v[7] * i2,\r\n              v[2] * f3 + v[8] * i3,\r\n            ];\r\n            ntmp = new MultiresNode(\r\n              vtmp,\r\n              node.side,\r\n              node.level + 1,\r\n              node.x * 2 + 1,\r\n              node.y * 2,\r\n              image.fullpath\r\n            );\r\n            children.push(ntmp);\r\n          }\r\n\r\n          if (\r\n            !(node.x == numTiles && doubleTileSize <= image.tileResolution) &&\r\n            !(node.y == numTiles && doubleTileSize <= image.tileResolution)\r\n          ) {\r\n            vtmp = [\r\n              v[0] * f1 + v[6] * i1,\r\n              v[1] * f2 + v[7] * i2,\r\n              v[2] * f3 + v[8] * i3,\r\n              v[3] * f + v[6] * i,\r\n              v[4] * f2 + v[7] * i2,\r\n              v[5] * f3 + v[8] * i3,\r\n              v[6],\r\n              v[7],\r\n              v[8],\r\n              v[9] * f1 + v[6] * i1,\r\n              v[10] * f + v[7] * i,\r\n              v[11] * f3 + v[8] * i3,\r\n            ];\r\n            ntmp = new MultiresNode(\r\n              vtmp,\r\n              node.side,\r\n              node.level + 1,\r\n              node.x * 2 + 1,\r\n              node.y * 2 + 1,\r\n              image.fullpath\r\n            );\r\n            children.push(ntmp);\r\n          }\r\n\r\n          if (!(node.y == numTiles && doubleTileSize <= image.tileResolution)) {\r\n            vtmp = [\r\n              v[0] * f + v[9] * i,\r\n              v[1] * f2 + v[10] * i2,\r\n              v[2] * f3 + v[11] * i3,\r\n              v[0] * f1 + v[6] * i1,\r\n              v[1] * f2 + v[7] * i2,\r\n              v[2] * f3 + v[8] * i3,\r\n              v[9] * f1 + v[6] * i1,\r\n              v[10] * f + v[7] * i,\r\n              v[11] * f3 + v[8] * i3,\r\n              v[9],\r\n              v[10],\r\n              v[11],\r\n            ];\r\n            ntmp = new MultiresNode(\r\n              vtmp,\r\n              node.side,\r\n              node.level + 1,\r\n              node.x * 2,\r\n              node.y * 2 + 1,\r\n              image.fullpath\r\n            );\r\n            children.push(ntmp);\r\n          }\r\n\r\n          for (var j = 0; j < children.length; j++) {\r\n            testMultiresNode(rotPersp, children[j], pitch, yaw);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Creates cube vertex array.\r\n     * @private\r\n     * @returns {number[]} Cube vertex array.\r\n     */\r\n\r\n    function createCube() {\r\n      return [\r\n        -1,\r\n        1,\r\n        -1,\r\n        1,\r\n        1,\r\n        -1,\r\n        1,\r\n        -1,\r\n        -1,\r\n        -1,\r\n        -1,\r\n        -1, // Front face\r\n        1,\r\n        1,\r\n        1,\r\n        -1,\r\n        1,\r\n        1,\r\n        -1,\r\n        -1,\r\n        1,\r\n        1,\r\n        -1,\r\n        1, // Back face\r\n        -1,\r\n        1,\r\n        1,\r\n        1,\r\n        1,\r\n        1,\r\n        1,\r\n        1,\r\n        -1,\r\n        -1,\r\n        1,\r\n        -1, // Up face\r\n        -1,\r\n        -1,\r\n        -1,\r\n        1,\r\n        -1,\r\n        -1,\r\n        1,\r\n        -1,\r\n        1,\r\n        -1,\r\n        -1,\r\n        1, // Down face\r\n        -1,\r\n        1,\r\n        1,\r\n        -1,\r\n        1,\r\n        -1,\r\n        -1,\r\n        -1,\r\n        -1,\r\n        -1,\r\n        -1,\r\n        1, // Left face\r\n        1,\r\n        1,\r\n        -1,\r\n        1,\r\n        1,\r\n        1,\r\n        1,\r\n        -1,\r\n        1,\r\n        1,\r\n        -1,\r\n        -1, // Right face\r\n      ];\r\n    }\r\n    /**\r\n     * Creates 3x3 identity matrix.\r\n     * @private\r\n     * @returns {number[]} Identity matrix.\r\n     */\r\n\r\n    function identityMatrix3() {\r\n      return [1, 0, 0, 0, 1, 0, 0, 0, 1];\r\n    }\r\n    /**\r\n     * Rotates a 3x3 matrix.\r\n     * @private\r\n     * @param {number[]} m - Matrix to rotate.\r\n     * @param {number[]} angle - Angle to rotate by in radians.\r\n     * @param {string} axis - Axis to rotate about (`x`, `y`, or `z`).\r\n     * @returns {number[]} Rotated matrix.\r\n     */\r\n\r\n    function rotateMatrix(m, angle, axis) {\r\n      var s = Math.sin(angle);\r\n      var c = Math.cos(angle);\r\n\r\n      if (axis == \"x\") {\r\n        return [\r\n          m[0],\r\n          c * m[1] + s * m[2],\r\n          c * m[2] - s * m[1],\r\n          m[3],\r\n          c * m[4] + s * m[5],\r\n          c * m[5] - s * m[4],\r\n          m[6],\r\n          c * m[7] + s * m[8],\r\n          c * m[8] - s * m[7],\r\n        ];\r\n      }\r\n\r\n      if (axis == \"y\") {\r\n        return [\r\n          c * m[0] - s * m[2],\r\n          m[1],\r\n          c * m[2] + s * m[0],\r\n          c * m[3] - s * m[5],\r\n          m[4],\r\n          c * m[5] + s * m[3],\r\n          c * m[6] - s * m[8],\r\n          m[7],\r\n          c * m[8] + s * m[6],\r\n        ];\r\n      }\r\n\r\n      if (axis == \"z\") {\r\n        return [\r\n          c * m[0] + s * m[1],\r\n          c * m[1] - s * m[0],\r\n          m[2],\r\n          c * m[3] + s * m[4],\r\n          c * m[4] - s * m[3],\r\n          m[5],\r\n          c * m[6] + s * m[7],\r\n          c * m[7] - s * m[6],\r\n          m[8],\r\n        ];\r\n      }\r\n    }\r\n    /**\r\n     * Turns a 3x3 matrix into a 4x4 matrix.\r\n     * @private\r\n     * @param {number[]} m - Input matrix.\r\n     * @returns {number[]} Expanded matrix.\r\n     */\r\n\r\n    function makeMatrix4(m) {\r\n      return [\r\n        m[0],\r\n        m[1],\r\n        m[2],\r\n        0,\r\n        m[3],\r\n        m[4],\r\n        m[5],\r\n        0,\r\n        m[6],\r\n        m[7],\r\n        m[8],\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        1,\r\n      ];\r\n    }\r\n    /**\r\n     * Transposes a 4x4 matrix.\r\n     * @private\r\n     * @param {number[]} m - Input matrix.\r\n     * @returns {number[]} Transposed matrix.\r\n     */\r\n\r\n    function transposeMatrix4(m) {\r\n      return [\r\n        m[0],\r\n        m[4],\r\n        m[8],\r\n        m[12],\r\n        m[1],\r\n        m[5],\r\n        m[9],\r\n        m[13],\r\n        m[2],\r\n        m[6],\r\n        m[10],\r\n        m[14],\r\n        m[3],\r\n        m[7],\r\n        m[11],\r\n        m[15],\r\n      ];\r\n    }\r\n    /**\r\n     * Creates a perspective matrix.\r\n     * @private\r\n     * @param {number} hfov - Desired horizontal field of view.\r\n     * @param {number} aspect - Desired aspect ratio.\r\n     * @param {number} znear - Near distance.\r\n     * @param {number} zfar - Far distance.\r\n     * @returns {number[]} Generated perspective matrix.\r\n     */\r\n\r\n    function makePersp(hfov, aspect, znear, zfar) {\r\n      var fovy =\r\n        2 *\r\n        Math.atan(\r\n          (Math.tan(hfov / 2) * gl.drawingBufferHeight) / gl.drawingBufferWidth\r\n        );\r\n      var f = 1 / Math.tan(fovy / 2);\r\n      return [\r\n        f / aspect,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        f,\r\n        0,\r\n        0,\r\n        0,\r\n        0,\r\n        (zfar + znear) / (znear - zfar),\r\n        (2 * zfar * znear) / (znear - zfar),\r\n        0,\r\n        0,\r\n        -1,\r\n        0,\r\n      ];\r\n    }\r\n    /**\r\n     * Processes a loaded texture image into a WebGL texture.\r\n     * @private\r\n     * @param {Image} img - Input image.\r\n     * @param {WebGLTexture} tex - Texture to bind image to.\r\n     */\r\n\r\n    function processLoadedTexture(img, tex) {\r\n      gl.bindTexture(gl.TEXTURE_2D, tex);\r\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, img);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n      gl.bindTexture(gl.TEXTURE_2D, null);\r\n    }\r\n\r\n    var pendingTextureRequests = []; // Based on http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html\r\n\r\n    var loadTexture = (function () {\r\n      var cacheTop = 4; // Maximum number of concurrents loads\r\n\r\n      var textureImageCache = {};\r\n      var crossOrigin;\r\n\r\n      function TextureImageLoader() {\r\n        var self = this;\r\n        this.texture = this.callback = null;\r\n        this.image = new Image();\r\n        this.image.crossOrigin = crossOrigin ? crossOrigin : \"anonymous\";\r\n\r\n        var loadFn = function loadFn() {\r\n          if (self.image.width > 0 && self.image.height > 0) {\r\n            // ignore missing tile to supporting partial image\r\n            processLoadedTexture(self.image, self.texture);\r\n            self.callback(self.texture, true);\r\n          } else {\r\n            self.callback(self.texture, false);\r\n          }\r\n\r\n          releaseTextureImageLoader(self);\r\n        };\r\n\r\n        this.image.addEventListener(\"load\", loadFn);\r\n        this.image.addEventListener(\"error\", loadFn); // ignore missing tile file to support partial image, otherwise retry loop causes high CPU load\r\n      }\r\n\r\n      TextureImageLoader.prototype.loadTexture = function (\r\n        src,\r\n        texture,\r\n        callback\r\n      ) {\r\n        this.texture = texture;\r\n        this.callback = callback;\r\n        this.image.src = src;\r\n      };\r\n\r\n      function PendingTextureRequest(node, src, texture, callback) {\r\n        this.node = node;\r\n        this.src = src;\r\n        this.texture = texture;\r\n        this.callback = callback;\r\n      }\r\n\r\n      function releaseTextureImageLoader(til) {\r\n        if (pendingTextureRequests.length) {\r\n          var req = pendingTextureRequests.shift();\r\n          til.loadTexture(req.src, req.texture, req.callback);\r\n        } else textureImageCache[cacheTop++] = til;\r\n      }\r\n\r\n      for (var i = 0; i < cacheTop; i++) {\r\n        textureImageCache[i] = new TextureImageLoader();\r\n      }\r\n\r\n      return function (node, src, callback, _crossOrigin) {\r\n        crossOrigin = _crossOrigin;\r\n        var texture = gl.createTexture();\r\n        if (cacheTop)\r\n          textureImageCache[--cacheTop].loadTexture(src, texture, callback);\r\n        else\r\n          pendingTextureRequests.push(\r\n            new PendingTextureRequest(node, src, texture, callback)\r\n          );\r\n        return texture;\r\n      };\r\n    })();\r\n    /**\r\n     * Loads image and creates texture for a multires node / tile.\r\n     * @private\r\n     * @param {MultiresNode} node - Input node.\r\n     */\r\n\r\n    function processNextTile(node) {\r\n      loadTexture(\r\n        node,\r\n        node.path + \".\" + image.extension,\r\n        function (texture, loaded) {\r\n          node.texture = texture;\r\n          node.textureLoaded = loaded ? 2 : 1;\r\n        },\r\n        globalParams.crossOrigin\r\n      );\r\n    }\r\n    /**\r\n     * Finds and applies optimal multires zoom level.\r\n     * @private\r\n     * @param {number} hfov - Horizontal field of view to check at.\r\n     */\r\n\r\n    function checkZoom(hfov) {\r\n      // Find optimal level\r\n      var newLevel = 1;\r\n\r\n      while (\r\n        newLevel < image.maxLevel &&\r\n        gl.drawingBufferWidth >\r\n          image.tileResolution *\r\n            Math.pow(2, newLevel - 1) *\r\n            Math.tan(hfov / 2) *\r\n            0.707\r\n      ) {\r\n        newLevel++;\r\n      } // Apply change\r\n\r\n      program.level = newLevel;\r\n    }\r\n    /**\r\n     * Rotates perspective matrix.\r\n     * @private\r\n     * @param {number[]} p - Perspective matrix.\r\n     * @param {number[]} r - Rotation matrix.\r\n     * @returns {number[]} Rotated matrix.\r\n     */\r\n\r\n    function rotatePersp(p, r) {\r\n      return [\r\n        p[0] * r[0],\r\n        p[0] * r[1],\r\n        p[0] * r[2],\r\n        0,\r\n        p[5] * r[4],\r\n        p[5] * r[5],\r\n        p[5] * r[6],\r\n        0,\r\n        p[10] * r[8],\r\n        p[10] * r[9],\r\n        p[10] * r[10],\r\n        p[11],\r\n        -r[8],\r\n        -r[9],\r\n        -r[10],\r\n        0,\r\n      ];\r\n    }\r\n    /**\r\n     * Applies rotated perspective matrix to a 3-vector\r\n     * (last element is inverted).\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Input 3-vector.\r\n     * @returns {number[]} Resulting 4-vector.\r\n     */\r\n\r\n    function applyRotPerspToVec(m, v) {\r\n      return [\r\n        m[0] * v[0] + m[1] * v[1] + m[2] * v[2],\r\n        m[4] * v[0] + m[5] * v[1] + m[6] * v[2],\r\n        m[11] + m[8] * v[0] + m[9] * v[1] + m[10] * v[2],\r\n        1 / (m[12] * v[0] + m[13] * v[1] + m[14] * v[2]),\r\n      ];\r\n    }\r\n    /**\r\n     * Checks if a vertex is visible.\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Input vertex.\r\n     * @returns {number} 1 or -1 if the vertex is or is not visible,\r\n     *      respectively.\r\n     */\r\n\r\n    function checkInView(m, v) {\r\n      var vpp = applyRotPerspToVec(m, v);\r\n      var winX = vpp[0] * vpp[3];\r\n      var winY = vpp[1] * vpp[3];\r\n      var winZ = vpp[2] * vpp[3];\r\n      var ret = [0, 0, 0];\r\n      if (winX < -1) ret[0] = -1;\r\n      if (winX > 1) ret[0] = 1;\r\n      if (winY < -1) ret[1] = -1;\r\n      if (winY > 1) ret[1] = 1;\r\n      if (winZ < -1 || winZ > 1) ret[2] = 1;\r\n      return ret;\r\n    }\r\n    /**\r\n     * Checks if a square (tile) is visible.\r\n     * @private\r\n     * @param {number[]} m - Rotated perspective matrix.\r\n     * @param {number[]} v - Square's vertex array.\r\n     * @returns {boolean} Whether or not the square is visible.\r\n     */\r\n\r\n    function checkSquareInView(m, v) {\r\n      var check1 = checkInView(m, v.slice(0, 3));\r\n      var check2 = checkInView(m, v.slice(3, 6));\r\n      var check3 = checkInView(m, v.slice(6, 9));\r\n      var check4 = checkInView(m, v.slice(9, 12));\r\n      var testX = check1[0] + check2[0] + check3[0] + check4[0];\r\n      if (testX == -4 || testX == 4) return false;\r\n      var testY = check1[1] + check2[1] + check3[1] + check4[1];\r\n      if (testY == -4 || testY == 4) return false;\r\n      var testZ = check1[2] + check2[2] + check3[2] + check4[2];\r\n      return testZ != 4;\r\n    }\r\n    /**\r\n     * On iOS (iPhone 5c, iOS 10.3), this WebGL error occurs when the canvas is\r\n     * too big. Unfortuately, there's no way to test for this beforehand, so we\r\n     * reduce the canvas size if this error is thrown.\r\n     * @private\r\n     */\r\n\r\n    function handleWebGLError1286() {\r\n      console.log(\"Reducing canvas size due to error 1286!\");\r\n      canvas.width = Math.round(canvas.width / 2);\r\n      canvas.height = Math.round(canvas.height / 2);\r\n    }\r\n  } // Vertex shader for equirectangular and cube\r\n\r\n  var v = [\r\n    \"attribute vec2 a_texCoord;\",\r\n    \"varying vec2 v_texCoord;\",\r\n    \"void main() {\", // Set position\r\n    \"gl_Position = vec4(a_texCoord, 0.0, 1.0);\", // Pass the coordinates to the fragment shader\r\n    \"v_texCoord = a_texCoord;\",\r\n    \"}\",\r\n  ].join(\"\"); // Vertex shader for multires\r\n\r\n  var vMulti = [\r\n    \"attribute vec3 a_vertCoord;\",\r\n    \"attribute vec2 a_texCoord;\",\r\n    \"uniform mat4 u_cubeMatrix;\",\r\n    \"uniform mat4 u_perspMatrix;\",\r\n    \"varying mediump vec2 v_texCoord;\",\r\n    \"void main(void) {\", // Set position\r\n    \"gl_Position = u_perspMatrix * u_cubeMatrix * vec4(a_vertCoord, 1.0);\", // Pass the coordinates to the fragment shader\r\n    \"v_texCoord = a_texCoord;\",\r\n    \"}\",\r\n  ].join(\"\"); // Fragment shader\r\n\r\n  var fragEquiCubeBase = [\r\n    \"precision highp float;\", // mediump looks bad on some mobile devices\r\n    \"uniform float u_aspectRatio;\",\r\n    \"uniform float u_psi;\",\r\n    \"uniform float u_theta;\",\r\n    \"uniform float u_f;\",\r\n    \"uniform float u_h;\",\r\n    \"uniform float u_v;\",\r\n    \"uniform float u_vo;\",\r\n    \"uniform float u_rot;\",\r\n    \"const float PI = 3.14159265358979323846264;\", // Texture\r\n    \"uniform sampler2D u_image0;\",\r\n    \"uniform sampler2D u_image1;\",\r\n    \"uniform bool u_splitImage;\",\r\n    \"uniform samplerCube u_imageCube;\", // Coordinates passed in from vertex shader\r\n    \"varying vec2 v_texCoord;\", // Background color (display for partial panoramas)\r\n    \"uniform vec4 u_backgroundColor;\",\r\n    \"void main() {\", // Map canvas/camera to sphere\r\n    \"float x = v_texCoord.x * u_aspectRatio;\",\r\n    \"float y = v_texCoord.y;\",\r\n    \"float sinrot = sin(u_rot);\",\r\n    \"float cosrot = cos(u_rot);\",\r\n    \"float rot_x = x * cosrot - y * sinrot;\",\r\n    \"float rot_y = x * sinrot + y * cosrot;\",\r\n    \"float sintheta = sin(u_theta);\",\r\n    \"float costheta = cos(u_theta);\",\r\n    \"float a = u_f * costheta - rot_y * sintheta;\",\r\n    \"float root = sqrt(rot_x * rot_x + a * a);\",\r\n    \"float lambda = atan(rot_x / root, a / root) + u_psi;\",\r\n    \"float phi = atan((rot_y * costheta + u_f * sintheta) / root);\",\r\n  ].join(\"\\n\"); // Fragment shader\r\n\r\n  var fragCube =\r\n    fragEquiCubeBase +\r\n    [\r\n      // Look up color from texture\r\n      \"float cosphi = cos(phi);\",\r\n      \"gl_FragColor = textureCube(u_imageCube, vec3(cosphi*sin(lambda), sin(phi), cosphi*cos(lambda)));\",\r\n      \"}\",\r\n    ].join(\"\\n\"); // Fragment shader\r\n\r\n  var fragEquirectangular =\r\n    fragEquiCubeBase +\r\n    [\r\n      // Wrap image\r\n      \"lambda = mod(lambda + PI, PI * 2.0) - PI;\", // Map texture to sphere\r\n      \"vec2 coord = vec2(lambda / PI, phi / (PI / 2.0));\", // Look up color from texture\r\n      // Map from [-1,1] to [0,1] and flip y-axis\r\n      \"if(coord.x < -u_h || coord.x > u_h || coord.y < -u_v + u_vo || coord.y > u_v + u_vo)\",\r\n      \"gl_FragColor = u_backgroundColor;\",\r\n      \"else {\",\r\n      \"if(u_splitImage) {\", // Image was split into two textures to work around texture size limits\r\n      \"if(coord.x < 0.0)\",\r\n      \"gl_FragColor = texture2D(u_image0, vec2((coord.x + u_h) / u_h, (-coord.y + u_v + u_vo) / (u_v * 2.0)));\",\r\n      \"else\",\r\n      \"gl_FragColor = texture2D(u_image1, vec2((coord.x + u_h) / u_h - 1.0, (-coord.y + u_v + u_vo) / (u_v * 2.0)));\",\r\n      \"} else {\",\r\n      \"gl_FragColor = texture2D(u_image0, vec2((coord.x + u_h) / (u_h * 2.0), (-coord.y + u_v + u_vo) / (u_v * 2.0)));\",\r\n      \"}\",\r\n      \"}\",\r\n      \"}\",\r\n    ].join(\"\\n\"); // Fragment shader\r\n\r\n  var fragMulti = [\r\n    \"varying mediump vec2 v_texCoord;\",\r\n    \"uniform sampler2D u_sampler;\", //'uniform mediump vec4 u_color;',\r\n    \"void main(void) {\", // Look up color from texture\r\n    \"gl_FragColor = texture2D(u_sampler, v_texCoord);\", //    'gl_FragColor = u_color;',\r\n    \"}\",\r\n  ].join(\"\");\r\n  return {\r\n    renderer: function renderer(container, image, imagetype, dynamic) {\r\n      return new Renderer(container, image, imagetype, dynamic);\r\n    },\r\n  };\r\n})(\r\n  typeof window === \"undefined\" ? null : window,\r\n  typeof document === \"undefined\" ? null : document\r\n);\r\n\r\nvar pannellum = (function (window, document, undefined$1) {\r\n  function Viewer(container, initialConfig) {\r\n    var _this = this; // Declare variables\r\n\r\n    let config,\r\n      renderer,\r\n      dLastPitch,\r\n      dLastYaw,\r\n      dLastHfov,\r\n      preview,\r\n      isAdd = {},\r\n      dTimeLookAtHotSpot = 600,\r\n      dTimeZoomInHotSpot = 1500,\r\n      dTimeZoomInAfterLoad = 500,\r\n      dTimeToLoad = 1500,\r\n      isUserInteracting = false,\r\n      latestInteraction = Date.now(),\r\n      onPointerDownPointerX = 0,\r\n      onPointerDownPointerY = 0,\r\n      onPointerDownPointerDist = -1,\r\n      onPointerDownYaw = 0,\r\n      onPointerDownPitch = 0,\r\n      keysDown = new Array(10),\r\n      fullscreenActive = false,\r\n      loaded,\r\n      error = false,\r\n      listenersAdded = false,\r\n      panoImage,\r\n      prevTime,\r\n      speed = {\r\n        yaw: 0,\r\n        pitch: 0,\r\n        hfov: 0,\r\n      },\r\n      animating = false,\r\n      orientation = false,\r\n      orientationYawOffset = 0,\r\n      autoRotateStart,\r\n      autoRotateSpeed = 0,\r\n      origHfov,\r\n      origPitch,\r\n      animatedMove = {},\r\n      externalEventListeners = {},\r\n      specifiedPhotoSphereExcludes = [],\r\n      update = false,\r\n      // Should we update when still to render dynamic content\r\n      eps = 1e-6,\r\n      hotspotsCreated = false,\r\n      destroyed = false;\r\n    var defaultConfig = {\r\n      hfov: 100,\r\n      minHfov: 50,\r\n      multiResMinHfov: false,\r\n      maxHfov: 120,\r\n      pitch: 0,\r\n      minPitch: -90,\r\n      maxPitch: 90,\r\n      yaw: 0,\r\n      minYaw: -180,\r\n      maxYaw: 180,\r\n      roll: 0,\r\n      haov: 360,\r\n      vaov: 180,\r\n      vOffset: 0,\r\n      autoRotate: false,\r\n      autoRotateInactivityDelay: -1,\r\n      autoRotateStopDelay: 0,\r\n      type: \"equirectangular\",\r\n      northOffset: 0,\r\n      showFullscreenCtrl: true,\r\n      dynamic: false,\r\n      dynamicUpdate: false,\r\n      doubleClickZoom: true,\r\n      keyboardZoom: true,\r\n      mouseZoom: true,\r\n      showZoomCtrl: true,\r\n      autoLoad: false,\r\n      showControls: true,\r\n      orientationOnByDefault: false,\r\n      hotSpotDebug: false,\r\n      backgroundColor: [0, 0, 0],\r\n      avoidShowingBackground: false,\r\n      animationTimingFunction: timingFunction,\r\n      draggable: true,\r\n      disableKeyboardCtrl: false,\r\n      crossOrigin: \"anonymous\",\r\n      touchPanSpeedCoeffFactor: 1,\r\n      capturedKeyNumbers: [\r\n        16, 17, 27, 37, 38, 39, 40, 61, 65, 68, 83, 87, 107, 109, 173, 187, 189,\r\n      ],\r\n      friction: 0.15,\r\n    }; // Translatable / configurable strings\r\n    // Some strings contain '%s', which is a placeholder for inserted values\r\n    // When setting strings in external configuration, `\\n` should be used instead of `<br>` to insert line breaks\r\n\r\n    defaultConfig.uiText = {\r\n      // Labels\r\n      loadButtonLabel: \"Click to<br>Load<br>Panorama\",\r\n      loadingLabel: \"Loading...\",\r\n      bylineLabel: \"by %s\",\r\n      // One substitution: author\r\n      // Errors\r\n      noPanoramaError: \"No panorama image was specified.\",\r\n      fileAccessError: \"The file %s could not be accessed.\",\r\n      // One substitution: file URL\r\n      malformedURLError: \"There is something wrong with the panorama URL.\",\r\n      iOS8WebGLError:\r\n        \"Due to iOS 8's broken WebGL implementation, only \" +\r\n        \"progressive encoded JPEGs work for your device (this \" +\r\n        \"panorama uses standard encoding).\",\r\n      genericWebGLError:\r\n        \"Your browser does not have the necessary WebGL support to display this panorama.\",\r\n      textureSizeError:\r\n        \"This panorama is too big for your device! It's \" +\r\n        \"%spx wide, but your device only supports images up to \" +\r\n        \"%spx wide. Try another device.\" +\r\n        \" (If you're the author, try scaling down the image.)\",\r\n      // Two substitutions: image width, max image width\r\n      unknownError: \"Unknown error. Check developer console.\",\r\n    }; // Initialize container\r\n\r\n    container =\r\n      typeof container === \"string\"\r\n        ? document.getElementById(container)\r\n        : container;\r\n    container.classList.add(\"pnlm-container\");\r\n    container.tabIndex = 0; // Create container for ui\r\n\r\n    var uiContainer = document.createElement(\"div\");\r\n    uiContainer.className = \"pnlm-ui\";\r\n    container.appendChild(uiContainer); // Create container for renderer\r\n\r\n    var renderContainer = document.createElement(\"div\");\r\n    renderContainer.className = \"pnlm-render-container\";\r\n    container.appendChild(renderContainer);\r\n    var dragFix = document.createElement(\"div\");\r\n    dragFix.className = \"pnlm-dragfix\";\r\n    uiContainer.appendChild(dragFix); // Display about information on right click\r\n\r\n    var aboutMsg = document.createElement(\"span\");\r\n    aboutMsg.className = \"pnlm-about-msg\";\r\n    aboutMsg.innerHTML =\r\n      '<a href=\"https://solutions.viettel.vn/vi\" target=\"_blank\">Viettel Solution</a>';\r\n    uiContainer.appendChild(aboutMsg);\r\n    dragFix.addEventListener(\"contextmenu\", aboutMessage); // Create info display\r\n\r\n    var infoDisplay = {}; // Hot spot debug indicator\r\n\r\n    var hotSpotDebugIndicator = document.createElement(\"div\");\r\n    hotSpotDebugIndicator.className =\r\n      \"pnlm-sprite pnlm-hot-spot-debug-indicator\";\r\n    uiContainer.appendChild(hotSpotDebugIndicator); // Panorama info\r\n\r\n    infoDisplay.container = document.createElement(\"div\");\r\n    infoDisplay.container.className = \"pnlm-panorama-info\";\r\n    infoDisplay.title = document.createElement(\"div\");\r\n    infoDisplay.title.className = \"pnlm-title-box\";\r\n    infoDisplay.container.appendChild(infoDisplay.title);\r\n    infoDisplay.description = document.createElement(\"div\");\r\n    infoDisplay.description.className = \"pnlm-description-box\";\r\n    infoDisplay.container.appendChild(infoDisplay.description);\r\n    infoDisplay.author = document.createElement(\"div\");\r\n    infoDisplay.author.className = \"pnlm-author-box\";\r\n    infoDisplay.container.appendChild(infoDisplay.author);\r\n    uiContainer.appendChild(infoDisplay.container); // Load box\r\n\r\n    infoDisplay.load = {};\r\n    infoDisplay.load.box = document.createElement(\"div\");\r\n    infoDisplay.load.box.className = \"pnlm-load-box\";\r\n    infoDisplay.load.boxp = document.createElement(\"p\");\r\n    infoDisplay.load.box.appendChild(infoDisplay.load.boxp);\r\n    infoDisplay.load.lbox = document.createElement(\"div\");\r\n    infoDisplay.load.lbox.className = \"pnlm-lbox\";\r\n    infoDisplay.load.lbox.innerHTML = '<div class=\"pnlm-loading\"></div>';\r\n    infoDisplay.load.box.appendChild(infoDisplay.load.lbox);\r\n    infoDisplay.load.lbar = document.createElement(\"div\");\r\n    infoDisplay.load.lbar.className = \"pnlm-lbar\";\r\n    infoDisplay.load.lbarFill = document.createElement(\"div\");\r\n    infoDisplay.load.lbarFill.className = \"pnlm-lbar-fill\";\r\n    infoDisplay.load.lbar.appendChild(infoDisplay.load.lbarFill);\r\n    infoDisplay.load.box.appendChild(infoDisplay.load.lbar);\r\n    infoDisplay.load.msg = document.createElement(\"p\");\r\n    infoDisplay.load.msg.className = \"pnlm-lmsg\";\r\n    infoDisplay.load.box.appendChild(infoDisplay.load.msg);\r\n    uiContainer.appendChild(infoDisplay.load.box); // Error message\r\n\r\n    infoDisplay.errorMsg = document.createElement(\"div\");\r\n    infoDisplay.errorMsg.className = \"pnlm-error-msg pnlm-info-box\";\r\n    uiContainer.appendChild(infoDisplay.errorMsg); // Create controls\r\n\r\n    var controls = {};\r\n    controls.container = document.createElement(\"div\");\r\n    controls.container.className = \"pnlm-controls-container\";\r\n    uiContainer.appendChild(controls.container); // Load button\r\n\r\n    controls.load = document.createElement(\"div\");\r\n    controls.load.className = \"pnlm-load-button\";\r\n    controls.load.addEventListener(\"click\", function () {\r\n      processOptions();\r\n      load();\r\n    });\r\n    uiContainer.appendChild(controls.load); // Zoom controls\r\n\r\n    controls.zoom = document.createElement(\"div\");\r\n    controls.zoom.className = \"pnlm-zoom-controls pnlm-controls\";\r\n    controls.zoomIn = document.createElement(\"div\");\r\n    controls.zoomIn.className = \"pnlm-zoom-in pnlm-sprite pnlm-control\";\r\n    controls.zoomIn.addEventListener(\"click\", zoomIn);\r\n    controls.zoom.appendChild(controls.zoomIn);\r\n    controls.zoomOut = document.createElement(\"div\");\r\n    controls.zoomOut.className = \"pnlm-zoom-out pnlm-sprite pnlm-control\";\r\n    controls.zoomOut.addEventListener(\"click\", zoomOut);\r\n    controls.zoom.appendChild(controls.zoomOut);\r\n    controls.container.appendChild(controls.zoom); // Fullscreen toggle\r\n\r\n    controls.fullscreen = document.createElement(\"div\");\r\n    controls.fullscreen.addEventListener(\"click\", toggleFullscreen);\r\n    controls.fullscreen.className =\r\n      \"pnlm-fullscreen-toggle-button pnlm-sprite pnlm-fullscreen-toggle-button-inactive pnlm-controls pnlm-control\";\r\n    if (\r\n      document.fullscreenEnabled ||\r\n      document.mozFullScreenEnabled ||\r\n      document.webkitFullscreenEnabled ||\r\n      document.msFullscreenEnabled\r\n    )\r\n      controls.container.appendChild(controls.fullscreen); // Device orientation toggle\r\n\r\n    controls.orientation = document.createElement(\"div\");\r\n    controls.orientation.addEventListener(\"click\", function (e) {\r\n      if (orientation) stopOrientation();\r\n      else startOrientation();\r\n    });\r\n    controls.orientation.addEventListener(\"mousedown\", function (e) {\r\n      e.stopPropagation();\r\n    });\r\n    controls.orientation.addEventListener(\"touchstart\", function (e) {\r\n      e.stopPropagation();\r\n    });\r\n    controls.orientation.addEventListener(\"pointerdown\", function (e) {\r\n      e.stopPropagation();\r\n    });\r\n    controls.orientation.className =\r\n      \"pnlm-orientation-button pnlm-orientation-button-inactive pnlm-sprite pnlm-controls pnlm-control\";\r\n    var orientationSupport = false;\r\n\r\n    if (\r\n      window.DeviceOrientationEvent &&\r\n      location.protocol === \"https:\" &&\r\n      navigator.userAgent.toLowerCase().indexOf(\"mobi\") >= 0\r\n    ) {\r\n      // This user agent check is here because there's no way to check if a\r\n      // device has an inertia measurement unit. We used to be able to check if a\r\n      // DeviceOrientationEvent had non-null values, but with iOS 13 requiring a\r\n      // permission prompt to access such events, this is no longer possible.\r\n      controls.container.appendChild(controls.orientation);\r\n      orientationSupport = true;\r\n    } // Compass\r\n\r\n    var compass = document.createElement(\"div\");\r\n    compass.className = \"pnlm-compass pnlm-controls pnlm-control\";\r\n    uiContainer.appendChild(compass); // Load and process configuration\r\n\r\n    if (initialConfig.firstScene) {\r\n      // Activate first scene if specified in URL\r\n      mergeConfig(initialConfig.firstScene);\r\n    } else if (\r\n      initialConfig[\"default\"] &&\r\n      initialConfig[\"default\"].firstScene\r\n    ) {\r\n      // Activate first scene if specified in file\r\n      mergeConfig(initialConfig[\"default\"].firstScene);\r\n    } else {\r\n      mergeConfig(null);\r\n    }\r\n\r\n    processOptions(true);\r\n    /**\r\n     * Initializes viewer.\r\n     * @private\r\n     */\r\n\r\n    function init() {\r\n      // Display an error for IE 9 as it doesn't work but also doesn't otherwise\r\n      // show an error (older versions don't work at all)\r\n      // Based on: http://stackoverflow.com/a/10965203\r\n      var div = document.createElement(\"div\");\r\n      div.innerHTML = \"<!--[if lte IE 9]><i></i><![endif]-->\";\r\n\r\n      if (div.getElementsByTagName(\"i\").length === 1) {\r\n        anError();\r\n        return;\r\n      }\r\n\r\n      origHfov = config.hfov;\r\n      origPitch = config.pitch;\r\n      var i, p;\r\n\r\n      if (config.type === \"cubemap\") {\r\n        panoImage = [];\r\n\r\n        for (i = 0; i < 6; i++) {\r\n          panoImage.push(new Image());\r\n          panoImage[i].crossOrigin = config.crossOrigin;\r\n        }\r\n\r\n        infoDisplay.load.lbox.style.display = \"block\";\r\n        infoDisplay.load.lbar.style.display = \"none\";\r\n      } else if (config.type === \"multires\") {\r\n        var c = JSON.parse(JSON.stringify(config.multiRes)); // Deep copy\r\n        // Avoid \"undefined\" in path, check (optional) multiRes.basePath, too\r\n        // Use only multiRes.basePath if it's an absolute URL\r\n\r\n        if (\r\n          config.basePath &&\r\n          config.multiRes.basePath &&\r\n          !/^(?:[a-z]+:)?\\/\\//i.test(config.multiRes.basePath)\r\n        ) {\r\n          c.basePath = config.basePath + config.multiRes.basePath;\r\n        } else if (config.multiRes.basePath) {\r\n          c.basePath = config.multiRes.basePath;\r\n        } else if (config.basePath) {\r\n          c.basePath = config.basePath;\r\n        }\r\n\r\n        panoImage = c;\r\n      } else {\r\n        if (config.dynamic === true) {\r\n          panoImage = config.imageSource;\r\n        } else {\r\n          if (config.imageSource === undefined$1) {\r\n            anError(config.uiText.noPanoramaError);\r\n            return;\r\n          }\r\n\r\n          panoImage = new Image();\r\n        }\r\n      } // Configure image loading\r\n\r\n      if (config.type === \"cubemap\") {\r\n        // Quick loading counter for synchronous loading\r\n        var itemsToLoad = 6;\r\n\r\n        var onLoad = function onLoad() {\r\n          itemsToLoad--;\r\n\r\n          if (itemsToLoad === 0) {\r\n            onImageLoad();\r\n          }\r\n        };\r\n\r\n        var onError = function onError(e) {\r\n          var a = document.createElement(\"a\");\r\n          a.href = e.target.src;\r\n          a.innerHTML = a.href;\r\n          anError(config.uiText.fileAccessError.replace(\"%s\", a.outerHTML));\r\n        };\r\n\r\n        for (i = 0; i < panoImage.length; i++) {\r\n          panoImage[i].onload = onLoad;\r\n          panoImage[i].onerror = onError;\r\n          p = config.cubeMap[i];\r\n\r\n          if (p === \"null\") {\r\n            // support partial cubemap image with explicitly empty faces\r\n            console.log(\r\n              \"Will use background instead of missing cubemap face \" + i\r\n            );\r\n            onLoad();\r\n          } else {\r\n            if (config.basePath && !absoluteURL(p)) {\r\n              p = config.basePath + p;\r\n            }\r\n\r\n            panoImage[i].onload = onLoad;\r\n            panoImage[i].onerror = onError;\r\n            panoImage[i].src = sanitizeURL(p); //panoImage[i].src = encodeURI(p);\r\n          }\r\n        }\r\n      } else if (config.type === \"multires\") {\r\n        onImageLoad();\r\n      } else {\r\n        p = \"\";\r\n\r\n        if (config.basePath) {\r\n          p = config.basePath;\r\n        }\r\n\r\n        if (config.dynamic !== true) {\r\n          // Still image\r\n          p = absoluteURL(config.imageSource)\r\n            ? config.imageSource\r\n            : p + config.imageSource;\r\n\r\n          panoImage.onload = function () {\r\n            window.URL.revokeObjectURL(this.src); // Clean up\r\n\r\n            onImageLoad();\r\n          };\r\n\r\n          var xhr = new XMLHttpRequest();\r\n\r\n          xhr.onloadend = function () {\r\n            if (xhr.status != 200) {\r\n              // Display error if image can't be loaded\r\n              var a = document.createElement(\"a\");\r\n              a.href = p;\r\n              a.textContent = a.href;\r\n              anError(config.uiText.fileAccessError.replace(\"%s\", a.outerHTML));\r\n            }\r\n\r\n            var img = this.response;\r\n            parseGPanoXMP(img);\r\n            infoDisplay.load.msg.innerHTML = \"\";\r\n          };\r\n\r\n          xhr.onprogress = function (e) {\r\n            if (e.lengthComputable) {\r\n              // Display progress\r\n              var percent = (e.loaded / e.total) * 100;\r\n              infoDisplay.load.lbarFill.style.width = percent + \"%\";\r\n              var unit, numerator, denominator;\r\n\r\n              if (e.total > 1e6) {\r\n                unit = \"MB\";\r\n                numerator = (e.loaded / 1e6).toFixed(2);\r\n                denominator = (e.total / 1e6).toFixed(2);\r\n              } else if (e.total > 1e3) {\r\n                unit = \"kB\";\r\n                numerator = (e.loaded / 1e3).toFixed(1);\r\n                denominator = (e.total / 1e3).toFixed(1);\r\n              } else {\r\n                unit = \"B\";\r\n                numerator = e.loaded;\r\n                denominator = e.total;\r\n              }\r\n\r\n              infoDisplay.load.msg.innerHTML =\r\n                numerator + \" / \" + denominator + \" \" + unit;\r\n            } else {\r\n              // Display loading spinner\r\n              infoDisplay.load.lbox.style.display = \"block\";\r\n              infoDisplay.load.lbar.style.display = \"none\";\r\n            }\r\n          };\r\n\r\n          try {\r\n            xhr.open(\"GET\", p, true);\r\n          } catch (e) {\r\n            // Malformed URL\r\n            anError(config.uiText.malformedURLError);\r\n          }\r\n\r\n          xhr.responseType = \"blob\";\r\n          xhr.setRequestHeader(\"Accept\", \"image/*,*/*;q=0.9\");\r\n          xhr.withCredentials = config.crossOrigin === \"use-credentials\";\r\n          xhr.send();\r\n        }\r\n      }\r\n\r\n      if (config.draggable) uiContainer.classList.add(\"pnlm-grab\");\r\n      uiContainer.classList.remove(\"pnlm-grabbing\"); // Properly handle switching to dynamic scenes\r\n\r\n      update = config.dynamicUpdate === true;\r\n\r\n      if (config.dynamic && update) {\r\n        panoImage = config.panorama;\r\n        onImageLoad();\r\n      }\r\n    }\r\n    /**\r\n     * Test if URL is absolute or relative.\r\n     * @private\r\n     * @param {string} url - URL to test\r\n     * @returns {boolean} True if absolute, else false\r\n     */\r\n\r\n    function absoluteURL(url) {\r\n      // From http://stackoverflow.com/a/19709846\r\n      return (\r\n        new RegExp(\"^(?:[a-z]+:)?//\", \"i\").test(url) ||\r\n        url[0] === \"/\" ||\r\n        url.slice(0, 5) === \"blob:\"\r\n      );\r\n    }\r\n    /**\r\n     * Create renderer and initialize event listeners once image is loaded.\r\n     * @private\r\n     */\r\n\r\n    function onImageLoad() {\r\n      if (!renderer) renderer = new libpannellum.renderer(renderContainer); // Only add event listeners once\r\n\r\n      if (!listenersAdded) {\r\n        listenersAdded = true;\r\n        dragFix.addEventListener(\"mousedown\", onDocumentMouseDown, false);\r\n        document.addEventListener(\"mousemove\", onDocumentMouseMove, false);\r\n        document.addEventListener(\"mouseup\", onDocumentMouseUp, false);\r\n\r\n        if (config.mouseZoom) {\r\n          uiContainer.addEventListener(\r\n            \"mousewheel\",\r\n            onDocumentMouseWheel,\r\n            false\r\n          );\r\n          uiContainer.addEventListener(\r\n            \"DOMMouseScroll\",\r\n            onDocumentMouseWheel,\r\n            false\r\n          );\r\n        }\r\n\r\n        if (config.doubleClickZoom) {\r\n          dragFix.addEventListener(\"dblclick\", onDocumentDoubleClick, false);\r\n        }\r\n\r\n        container.addEventListener(\r\n          \"mozfullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        container.addEventListener(\r\n          \"webkitfullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        container.addEventListener(\r\n          \"msfullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        container.addEventListener(\r\n          \"fullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        window.addEventListener(\"resize\", onDocumentResize, false);\r\n        window.addEventListener(\"orientationchange\", onDocumentResize, false);\r\n\r\n        if (!config.disableKeyboardCtrl) {\r\n          container.addEventListener(\"keydown\", onDocumentKeyPress, false);\r\n          container.addEventListener(\"keyup\", onDocumentKeyUp, false);\r\n          container.addEventListener(\"blur\", clearKeys, false);\r\n        }\r\n\r\n        document.addEventListener(\"mouseleave\", onDocumentMouseUp, false);\r\n\r\n        if (\r\n          document.documentElement.style.pointerAction === \"\" &&\r\n          document.documentElement.style.touchAction === \"\"\r\n        ) {\r\n          dragFix.addEventListener(\"pointerdown\", onDocumentPointerDown, false);\r\n          dragFix.addEventListener(\"pointermove\", onDocumentPointerMove, false);\r\n          dragFix.addEventListener(\"pointerup\", onDocumentPointerUp, false);\r\n          dragFix.addEventListener(\"pointerleave\", onDocumentPointerUp, false);\r\n        } else {\r\n          dragFix.addEventListener(\"touchstart\", onDocumentTouchStart, false);\r\n          dragFix.addEventListener(\"touchmove\", onDocumentTouchMove, false);\r\n          dragFix.addEventListener(\"touchend\", onDocumentTouchEnd, false);\r\n        } // Deal with MS pointer events\r\n\r\n        if (window.navigator.pointerEnabled)\r\n          container.style.touchAction = \"none\";\r\n      }\r\n\r\n      renderInit();\r\n      setHfov(config.hfov); // possibly adapt hfov after configuration and canvas is complete; prevents empty space on top or bottom by zomming out too much\r\n\r\n      setTimeout(function () {}, 500);\r\n    }\r\n    /**\r\n     * Parses Google Photo Sphere XMP Metadata.\r\n     * https://developers.google.com/photo-sphere/metadata/\r\n     * @private\r\n     * @param {Image} image - Image to read XMP metadata from.\r\n     */\r\n\r\n    function parseGPanoXMP(image) {\r\n      var reader = new FileReader();\r\n      reader.addEventListener(\"loadend\", function () {\r\n        var img = reader.result; // This awful browser specific test exists because iOS 8 does not work\r\n        // with non-progressive encoded JPEGs.\r\n\r\n        if (\r\n          navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/)\r\n        ) {\r\n          var flagIndex = img.indexOf(\"\\xff\\xc2\");\r\n          if (flagIndex < 0 || flagIndex > 65536)\r\n            anError(config.uiText.iOS8WebGLError);\r\n        }\r\n\r\n        var start = img.indexOf(\"<x:xmpmeta\");\r\n\r\n        if (start > -1 && config.ignoreGPanoXMP !== true) {\r\n          var xmpData = img.substring(start, img.indexOf(\"</x:xmpmeta>\") + 12); // Extract the requested tag from the XMP data\r\n\r\n          var getTag = function getTag(tag) {\r\n            var result;\r\n\r\n            if (xmpData.indexOf(tag + '=\"') >= 0) {\r\n              result = xmpData.substring(\r\n                xmpData.indexOf(tag + '=\"') + tag.length + 2\r\n              );\r\n              result = result.substring(0, result.indexOf('\"'));\r\n            } else if (xmpData.indexOf(tag + \">\") >= 0) {\r\n              result = xmpData.substring(\r\n                xmpData.indexOf(tag + \">\") + tag.length + 1\r\n              );\r\n              result = result.substring(0, result.indexOf(\"<\"));\r\n            }\r\n\r\n            if (result !== undefined$1) {\r\n              return Number(result);\r\n            }\r\n\r\n            return null;\r\n          }; // Relevant XMP data\r\n\r\n          var xmp = {\r\n            fullWidth: getTag(\"GPano:FullPanoWidthPixels\"),\r\n            croppedWidth: getTag(\"GPano:CroppedAreaImageWidthPixels\"),\r\n            fullHeight: getTag(\"GPano:FullPanoHeightPixels\"),\r\n            croppedHeight: getTag(\"GPano:CroppedAreaImageHeightPixels\"),\r\n            topPixels: getTag(\"GPano:CroppedAreaTopPixels\"),\r\n            heading: getTag(\"GPano:PoseHeadingDegrees\"),\r\n            horizonPitch: getTag(\"GPano:PosePitchDegrees\"),\r\n            horizonRoll: getTag(\"GPano:PoseRollDegrees\"),\r\n          };\r\n\r\n          if (\r\n            xmp.fullWidth !== null &&\r\n            xmp.croppedWidth !== null &&\r\n            xmp.fullHeight !== null &&\r\n            xmp.croppedHeight !== null &&\r\n            xmp.topPixels !== null\r\n          ) {\r\n            // Set up viewer using GPano XMP data\r\n            if (specifiedPhotoSphereExcludes.indexOf(\"haov\") < 0)\r\n              config.haov = (xmp.croppedWidth / xmp.fullWidth) * 360;\r\n            if (specifiedPhotoSphereExcludes.indexOf(\"vaov\") < 0)\r\n              config.vaov = (xmp.croppedHeight / xmp.fullHeight) * 180;\r\n            if (specifiedPhotoSphereExcludes.indexOf(\"vOffset\") < 0)\r\n              config.vOffset =\r\n                ((xmp.topPixels + xmp.croppedHeight / 2) / xmp.fullHeight -\r\n                  0.5) *\r\n                -180;\r\n\r\n            if (\r\n              xmp.heading !== null &&\r\n              specifiedPhotoSphereExcludes.indexOf(\"northOffset\") < 0\r\n            ) {\r\n              // TODO: make sure this works correctly for partial panoramas\r\n              config.northOffset = xmp.heading;\r\n\r\n              if (config.compass !== false) {\r\n                config.compass = true;\r\n              }\r\n            }\r\n\r\n            if (xmp.horizonPitch !== null && xmp.horizonRoll !== null) {\r\n              if (specifiedPhotoSphereExcludes.indexOf(\"horizonPitch\") < 0)\r\n                config.horizonPitch = xmp.horizonPitch;\r\n              if (specifiedPhotoSphereExcludes.indexOf(\"horizonRoll\") < 0)\r\n                config.horizonRoll = xmp.horizonRoll;\r\n            } // TODO: add support for initial view settings\r\n          }\r\n        } // Load panorama\r\n\r\n        panoImage.src = window.URL.createObjectURL(image);\r\n      });\r\n      if (reader.readAsBinaryString !== undefined$1)\r\n        reader.readAsBinaryString(image);\r\n      else reader.readAsText(image);\r\n    }\r\n    /**\r\n     * Displays an error message.\r\n     * @private\r\n     * @param {string} errorMsg - Error message to display. If not specified, a\r\n     *      generic WebGL error is displayed.\r\n     */\r\n\r\n    function anError(errorMsg) {\r\n      if (errorMsg === undefined$1) errorMsg = config.uiText.genericWebGLError;\r\n      infoDisplay.errorMsg.innerHTML = \"<p>\" + errorMsg + \"</p>\";\r\n      controls.load.style.display = \"none\";\r\n      infoDisplay.load.box.style.display = \"none\";\r\n      infoDisplay.errorMsg.style.display = \"table\";\r\n      error = true;\r\n      loaded = undefined$1;\r\n      renderContainer.style.display = \"none\";\r\n      fireEvent(\"error\", errorMsg);\r\n    }\r\n    /**\r\n     * Hides error message display.\r\n     * @private\r\n     */\r\n\r\n    function clearError() {\r\n      if (error) {\r\n        infoDisplay.load.box.style.display = \"none\";\r\n        infoDisplay.errorMsg.style.display = \"none\";\r\n        error = false;\r\n        renderContainer.style.display = \"block\";\r\n        fireEvent(\"errorcleared\");\r\n      }\r\n    }\r\n    /**\r\n     * Displays about message.\r\n     * @private\r\n     * @param {MouseEvent} event - Right click location\r\n     */\r\n\r\n    function aboutMessage(event) {\r\n      var pos = mousePosition(event);\r\n      aboutMsg.style.left = pos.x + \"px\";\r\n      aboutMsg.style.top = pos.y + \"px\";\r\n      clearTimeout(aboutMessage.t1);\r\n      clearTimeout(aboutMessage.t2);\r\n      aboutMsg.style.display = \"block\";\r\n      aboutMsg.style.opacity = 1;\r\n      aboutMessage.t1 = setTimeout(function () {\r\n        aboutMsg.style.opacity = 0;\r\n      }, 2000);\r\n      aboutMessage.t2 = setTimeout(function () {\r\n        aboutMsg.style.display = \"none\";\r\n      }, 2500);\r\n      event.preventDefault();\r\n    }\r\n    /**\r\n     * Calculate mouse position relative to top left of viewer container.\r\n     * @private\r\n     * @param {MouseEvent} event - Mouse event to use in calculation\r\n     * @returns {Object} Calculated X and Y coordinates\r\n     */\r\n\r\n    function mousePosition(event) {\r\n      var bounds = container.getBoundingClientRect();\r\n      var pos = {}; // pageX / pageY needed for iOS\r\n\r\n      pos.x = (event.clientX || event.pageX) - bounds.left;\r\n      pos.y = (event.clientY || event.pageY) - bounds.top;\r\n      return pos;\r\n    }\r\n    /**\r\n     * Event handler for mouse clicks. Initializes panning. Prints center and click\r\n     * location coordinates when hot spot debugging is enabled.\r\n     * @private\r\n     * @param {MouseEvent} event - Document mouse down event.\r\n     */\r\n\r\n    function onDocumentMouseDown(event) {\r\n      // Override default action\r\n      event.preventDefault(); // But not all of it\r\n\r\n      container.focus(); // Only do something if the panorama is loaded\r\n\r\n      if (!loaded || !config.draggable) {\r\n        fireEvent(\"mousedown\", event);\r\n        return;\r\n      } // Calculate mouse position relative to top left of viewer container\r\n\r\n      var pos = mousePosition(event); // Log pitch / yaw of mouse click when debugging / placing hot spots\r\n\r\n      if (config.hotSpotDebug) {\r\n        var coords = mouseEventToCoords(event);\r\n        console.log(\r\n          \"Pitch: \" +\r\n            coords[0] +\r\n            \", Yaw: \" +\r\n            coords[1] +\r\n            \", Center Pitch: \" +\r\n            config.pitch +\r\n            \", Center Yaw: \" +\r\n            config.yaw +\r\n            \", HFOV: \" +\r\n            config.hfov\r\n        );\r\n      } // Turn off auto-rotation if enabled\r\n\r\n      stopAnimation();\r\n      stopOrientation();\r\n      config.roll = 0;\r\n      speed.hfov = 0;\r\n      isUserInteracting = true;\r\n      latestInteraction = Date.now();\r\n      onPointerDownPointerX = pos.x;\r\n      onPointerDownPointerY = pos.y;\r\n      onPointerDownYaw = config.yaw;\r\n      onPointerDownPitch = config.pitch;\r\n      uiContainer.classList.add(\"pnlm-grabbing\");\r\n      uiContainer.classList.remove(\"pnlm-grab\");\r\n      fireEvent(\"mousedown\", event);\r\n      animateInit();\r\n    }\r\n    /**\r\n     * Event handler for double clicks. Zooms in at clicked location\r\n     * @private\r\n     * @param {MouseEvent} event - Document mouse down event.\r\n     */\r\n\r\n    function onDocumentDoubleClick(event) {\r\n      if (config.minHfov === config.hfov) {\r\n        _this.setHfov(origHfov, 1000);\r\n      } else {\r\n        var coords = mouseEventToCoords(event);\r\n\r\n        _this.lookAt(coords[0], coords[1], config.minHfov, 1000);\r\n      }\r\n    }\r\n\r\n    function changeMouseCursor(event) {\r\n      isAdd = { ...event };\r\n      if (isAdd.isAddInfo === true || isAdd.isAddScene === true) {\r\n        config.draggable = false;\r\n        uiContainer.classList.remove(\"pnlm-grab\");\r\n        uiContainer.classList.add(\"pnlm-custom\");\r\n      } else {\r\n        config.draggable = true;\r\n        uiContainer.classList.add(\"pnlm-grab\");\r\n        uiContainer.classList.remove(\"pnlm-custom\");\r\n      }\r\n    }\r\n    /**\r\n     * Calculate panorama pitch and yaw from location of mouse event.\r\n     * @private\r\n     * @param {MouseEvent} event - Document mouse down event.\r\n     * @returns {number[]} [pitch, yaw]\r\n     */\r\n\r\n    function mouseEventToCoords(event) {\r\n      var pos = mousePosition(event);\r\n      var canvas = renderer.getCanvas();\r\n      var canvasWidth = canvas.clientWidth,\r\n        canvasHeight = canvas.clientHeight;\r\n      var x = (pos.x / canvasWidth) * 2 - 1;\r\n      var y = ((1 - (pos.y / canvasHeight) * 2) * canvasHeight) / canvasWidth;\r\n      var focal = 1 / Math.tan((config.hfov * Math.PI) / 360);\r\n      var s = Math.sin((config.pitch * Math.PI) / 180);\r\n      var c = Math.cos((config.pitch * Math.PI) / 180);\r\n      var a = focal * c - y * s;\r\n      var root = Math.sqrt(x * x + a * a);\r\n      var pitch = (Math.atan((y * c + focal * s) / root) * 180) / Math.PI;\r\n      var yaw = (Math.atan2(x / root, a / root) * 180) / Math.PI + config.yaw;\r\n      if (yaw < -180) yaw += 360;\r\n      if (yaw > 180) yaw -= 360;\r\n      return [pitch, yaw];\r\n    }\r\n    /**\r\n     * Event handler for mouse moves. Pans center of view.\r\n     * @private\r\n     * @param {MouseEvent} event - Document mouse move event.\r\n     */\r\n\r\n    function onDocumentMouseMove(event) {\r\n      if (isUserInteracting && loaded) {\r\n        latestInteraction = Date.now();\r\n        var canvas = renderer.getCanvas();\r\n        var canvasWidth = canvas.clientWidth,\r\n          canvasHeight = canvas.clientHeight;\r\n        var pos = mousePosition(event); //TODO: This still isn't quite right\r\n\r\n        var yaw =\r\n          ((((Math.atan((onPointerDownPointerX / canvasWidth) * 2 - 1) -\r\n            Math.atan((pos.x / canvasWidth) * 2 - 1)) *\r\n            180) /\r\n            Math.PI) *\r\n            config.hfov) /\r\n            90 +\r\n          onPointerDownYaw;\r\n        speed.yaw = ((yaw - config.yaw) % 360) * 0.2;\r\n        config.yaw = yaw;\r\n        var vfov =\r\n          (2 *\r\n            Math.atan(\r\n              (Math.tan((config.hfov / 360) * Math.PI) * canvasHeight) /\r\n                canvasWidth\r\n            ) *\r\n            180) /\r\n          Math.PI;\r\n        var pitch =\r\n          ((((Math.atan((pos.y / canvasHeight) * 2 - 1) -\r\n            Math.atan((onPointerDownPointerY / canvasHeight) * 2 - 1)) *\r\n            180) /\r\n            Math.PI) *\r\n            vfov) /\r\n            90 +\r\n          onPointerDownPitch;\r\n        speed.pitch = (pitch - config.pitch) * 0.2;\r\n        config.pitch = pitch;\r\n      }\r\n    }\r\n    /**\r\n     * Event handler for mouse up events. Stops panning.\r\n     * @private\r\n     */\r\n\r\n    function onDocumentMouseUp(event) {\r\n      if (!isUserInteracting) {\r\n        return;\r\n      }\r\n\r\n      isUserInteracting = false;\r\n\r\n      if (Date.now() - latestInteraction > 15) {\r\n        // Prevents jump when user rapidly moves mouse, stops, and then\r\n        // releases the mouse button\r\n        speed.pitch = speed.yaw = 0;\r\n      }\r\n\r\n      uiContainer.classList.add(\"pnlm-grab\");\r\n      uiContainer.classList.remove(\"pnlm-grabbing\");\r\n      latestInteraction = Date.now();\r\n      fireEvent(\"mouseup\", event);\r\n    }\r\n    /**\r\n     * Event handler for touches. Initializes panning if one touch or zooming if\r\n     * two touches.\r\n     * @private\r\n     * @param {TouchEvent} event - Document touch start event.\r\n     */\r\n\r\n    function onDocumentTouchStart(event) {\r\n      // Only do something if the panorama is loaded\r\n      if (!loaded || !config.draggable) {\r\n        return;\r\n      } // Turn off auto-rotation if enabled\r\n\r\n      stopAnimation();\r\n      stopOrientation();\r\n      config.roll = 0;\r\n      speed.hfov = 0; // Calculate touch position relative to top left of viewer container\r\n\r\n      var pos0 = mousePosition(event.targetTouches[0]);\r\n      onPointerDownPointerX = pos0.x;\r\n      onPointerDownPointerY = pos0.y;\r\n\r\n      if (event.targetTouches.length === 2) {\r\n        // Down pointer is the center of the two fingers\r\n        var pos1 = mousePosition(event.targetTouches[1]);\r\n        onPointerDownPointerX += (pos1.x - pos0.x) * 0.5;\r\n        onPointerDownPointerY += (pos1.y - pos0.y) * 0.5;\r\n        onPointerDownPointerDist = Math.sqrt(\r\n          (pos0.x - pos1.x) * (pos0.x - pos1.x) +\r\n            (pos0.y - pos1.y) * (pos0.y - pos1.y)\r\n        );\r\n      }\r\n\r\n      isUserInteracting = true;\r\n      latestInteraction = Date.now();\r\n      onPointerDownYaw = config.yaw;\r\n      onPointerDownPitch = config.pitch;\r\n      fireEvent(\"touchstart\", event);\r\n      animateInit();\r\n    }\r\n    /**\r\n     * Event handler for touch movements. Pans center of view if one touch or\r\n     * adjusts zoom if two touches.\r\n     * @private\r\n     * @param {TouchEvent} event - Document touch move event.\r\n     */\r\n\r\n    function onDocumentTouchMove(event) {\r\n      if (!config.draggable) {\r\n        return;\r\n      } // Override default action\r\n\r\n      event.preventDefault();\r\n\r\n      if (loaded) {\r\n        latestInteraction = Date.now();\r\n      }\r\n\r\n      if (isUserInteracting && loaded) {\r\n        var pos0 = mousePosition(event.targetTouches[0]);\r\n        var clientX = pos0.x;\r\n        var clientY = pos0.y;\r\n\r\n        if (\r\n          event.targetTouches.length === 2 &&\r\n          onPointerDownPointerDist != -1\r\n        ) {\r\n          var pos1 = mousePosition(event.targetTouches[1]);\r\n          clientX += (pos1.x - pos0.x) * 0.5;\r\n          clientY += (pos1.y - pos0.y) * 0.5;\r\n          var clientDist = Math.sqrt(\r\n            (pos0.x - pos1.x) * (pos0.x - pos1.x) +\r\n              (pos0.y - pos1.y) * (pos0.y - pos1.y)\r\n          );\r\n          setHfov(config.hfov + (onPointerDownPointerDist - clientDist) * 0.1);\r\n          onPointerDownPointerDist = clientDist;\r\n        } // The smaller the config.hfov value (the more zoomed-in the user is), the faster\r\n        // yaw/pitch are perceived to change on one-finger touchmove (panning) events and vice versa.\r\n        // To improve usability at both small and large zoom levels (config.hfov values)\r\n        // we introduce a dynamic pan speed coefficient.\r\n        //\r\n        // Currently this seems to *roughly* keep initial drag/pan start position close to\r\n        // the user's finger while panning regardless of zoom level / config.hfov value.\r\n\r\n        var touchmovePanSpeedCoeff =\r\n          (config.hfov / 360) * config.touchPanSpeedCoeffFactor;\r\n        var yaw =\r\n          (onPointerDownPointerX - clientX) * touchmovePanSpeedCoeff +\r\n          onPointerDownYaw;\r\n        speed.yaw = ((yaw - config.yaw) % 360) * 0.2;\r\n        config.yaw = yaw;\r\n        var pitch =\r\n          (clientY - onPointerDownPointerY) * touchmovePanSpeedCoeff +\r\n          onPointerDownPitch;\r\n        speed.pitch = (pitch - config.pitch) * 0.2;\r\n        config.pitch = pitch;\r\n      }\r\n    }\r\n    /**\r\n     * Event handler for end of touches. Stops panning and/or zooming.\r\n     * @private\r\n     */\r\n\r\n    function onDocumentTouchEnd() {\r\n      isUserInteracting = false;\r\n\r\n      if (Date.now() - latestInteraction > 150) {\r\n        speed.pitch = speed.yaw = 0;\r\n      }\r\n\r\n      onPointerDownPointerDist = -1;\r\n      latestInteraction = Date.now();\r\n      fireEvent(\"touchend\", event);\r\n    }\r\n\r\n    var pointerIDs = [],\r\n      pointerCoordinates = [];\r\n    /**\r\n     * Event handler for touch starts in IE / Edge.\r\n     * @private\r\n     * @param {PointerEvent} event - Document pointer down event.\r\n     */\r\n\r\n    function onDocumentPointerDown(event) {\r\n      if (event.pointerType === \"touch\") {\r\n        // Only do something if the panorama is loaded\r\n        if (!loaded || !config.draggable) return;\r\n        pointerIDs.push(event.pointerId);\r\n        pointerCoordinates.push({\r\n          clientX: event.clientX,\r\n          clientY: event.clientY,\r\n        });\r\n        event.targetTouches = pointerCoordinates;\r\n        onDocumentTouchStart(event);\r\n        event.preventDefault();\r\n      }\r\n    }\r\n    /**\r\n     * Event handler for touch moves in IE / Edge.\r\n     * @private\r\n     * @param {PointerEvent} event - Document pointer move event.\r\n     */\r\n\r\n    function onDocumentPointerMove(event) {\r\n      if (event.pointerType === \"touch\") {\r\n        if (!config.draggable) return;\r\n\r\n        for (var i = 0; i < pointerIDs.length; i++) {\r\n          if (event.pointerId === pointerIDs[i]) {\r\n            pointerCoordinates[i].clientX = event.clientX;\r\n            pointerCoordinates[i].clientY = event.clientY;\r\n            event.targetTouches = pointerCoordinates;\r\n            onDocumentTouchMove(event);\r\n            event.preventDefault();\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Event handler for touch ends in IE / Edge.\r\n     * @private\r\n     * @param {PointerEvent} event - Document pointer up event.\r\n     */\r\n\r\n    function onDocumentPointerUp(event) {\r\n      if (event.pointerType === \"touch\") {\r\n        var defined = false;\r\n\r\n        for (var i = 0; i < pointerIDs.length; i++) {\r\n          if (event.pointerId === pointerIDs[i]) pointerIDs[i] = undefined$1;\r\n          if (pointerIDs[i]) defined = true;\r\n        }\r\n\r\n        if (!defined) {\r\n          pointerIDs = [];\r\n          pointerCoordinates = [];\r\n          onDocumentTouchEnd();\r\n        }\r\n\r\n        event.preventDefault();\r\n      }\r\n    }\r\n    /**\r\n     * Event handler for mouse wheel. Changes zoom.\r\n     * @private\r\n     * @param {WheelEvent} event - Document mouse wheel event.\r\n     */\r\n\r\n    function onDocumentMouseWheel(event) {\r\n      // Only do something if the panorama is loaded and mouse wheel zoom is enabled\r\n      if (\r\n        !loaded ||\r\n        (config.mouseZoom === \"fullscreenonly\" && !fullscreenActive)\r\n      ) {\r\n        return;\r\n      }\r\n\r\n      event.preventDefault(); // Turn off auto-rotation if enabled\r\n\r\n      stopAnimation();\r\n      latestInteraction = Date.now();\r\n\r\n      if (event.wheelDeltaY) {\r\n        // WebKit\r\n        setHfov(config.hfov - event.wheelDeltaY * 0.05);\r\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\r\n      } else if (event.wheelDelta) {\r\n        // Opera / Explorer 9\r\n        setHfov(config.hfov - event.wheelDelta * 0.05);\r\n        speed.hfov = event.wheelDelta < 0 ? 1 : -1;\r\n      } else if (event.detail) {\r\n        // Firefox\r\n        setHfov(config.hfov + event.detail * 1.5);\r\n        speed.hfov = event.detail > 0 ? 1 : -1;\r\n      }\r\n\r\n      animateInit();\r\n    }\r\n    /**\r\n     * Event handler for key presses. Updates list of currently pressed keys.\r\n     * @private\r\n     * @param {KeyboardEvent} event - Document key press event.\r\n     */\r\n\r\n    function onDocumentKeyPress(event) {\r\n      // Turn off auto-rotation if enabled\r\n      stopAnimation();\r\n      latestInteraction = Date.now();\r\n      stopOrientation();\r\n      config.roll = 0; // Record key pressed\r\n\r\n      var keynumber = event.which || event.keycode; // Override default action for keys that are used\r\n\r\n      if (config.capturedKeyNumbers.indexOf(keynumber) < 0) return;\r\n      event.preventDefault(); // If escape key is pressed\r\n\r\n      if (keynumber === 27) {\r\n        // If in fullscreen mode\r\n        if (fullscreenActive) {\r\n          toggleFullscreen();\r\n        }\r\n      } else {\r\n        // Change key\r\n        changeKey(keynumber, true);\r\n      }\r\n    }\r\n    /**\r\n     * Clears list of currently pressed keys.\r\n     * @private\r\n     */\r\n\r\n    function clearKeys() {\r\n      for (var i = 0; i < 10; i++) {\r\n        keysDown[i] = false;\r\n      }\r\n    }\r\n    /**\r\n     * Event handler for key releases. Updates list of currently pressed keys.\r\n     * @private\r\n     * @param {KeyboardEvent} event - Document key up event.\r\n     */\r\n\r\n    function onDocumentKeyUp(event) {\r\n      // Record key pressed\r\n      var keynumber = event.which || event.keycode; // Override default action for keys that are used\r\n\r\n      if (config.capturedKeyNumbers.indexOf(keynumber) < 0) return;\r\n      event.preventDefault(); // Change key\r\n\r\n      changeKey(keynumber, false);\r\n    }\r\n    /**\r\n     * Updates list of currently pressed keys.\r\n     * @private\r\n     * @param {number} keynumber - Key number.\r\n     * @param {boolean} value - Whether or not key is pressed.\r\n     */\r\n\r\n    function changeKey(keynumber, value) {\r\n      var keyChanged = false;\r\n\r\n      switch (keynumber) {\r\n        // If minus key is released\r\n        case 109:\r\n        case 189:\r\n        case 17:\r\n        case 173:\r\n          if (keysDown[0] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[0] = value;\r\n          break;\r\n        // If plus key is released\r\n\r\n        case 107:\r\n        case 187:\r\n        case 16:\r\n        case 61:\r\n          if (keysDown[1] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[1] = value;\r\n          break;\r\n        // If up arrow is released\r\n\r\n        case 38:\r\n          if (keysDown[2] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[2] = value;\r\n          break;\r\n        // If \"w\" is released\r\n\r\n        case 87:\r\n          if (keysDown[6] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[6] = value;\r\n          break;\r\n        // If down arrow is released\r\n\r\n        case 40:\r\n          if (keysDown[3] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[3] = value;\r\n          break;\r\n        // If \"s\" is released\r\n\r\n        case 83:\r\n          if (keysDown[7] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[7] = value;\r\n          break;\r\n        // If left arrow is released\r\n\r\n        case 37:\r\n          if (keysDown[4] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[4] = value;\r\n          break;\r\n        // If \"a\" is released\r\n\r\n        case 65:\r\n          if (keysDown[8] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[8] = value;\r\n          break;\r\n        // If right arrow is released\r\n\r\n        case 39:\r\n          if (keysDown[5] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[5] = value;\r\n          break;\r\n        // If \"d\" is released\r\n\r\n        case 68:\r\n          if (keysDown[9] != value) {\r\n            keyChanged = true;\r\n          }\r\n\r\n          keysDown[9] = value;\r\n      }\r\n\r\n      if (keyChanged && value) {\r\n        if (typeof performance !== \"undefined\" && performance.now()) {\r\n          prevTime = performance.now();\r\n        } else {\r\n          prevTime = Date.now();\r\n        }\r\n\r\n        animateInit();\r\n      }\r\n    }\r\n    /**\r\n     * Pans and/or zooms panorama based on currently pressed keys. Also handles\r\n     * panorama \"inertia\" and auto rotation.\r\n     * @private\r\n     */\r\n\r\n    function keyRepeat() {\r\n      // Only do something if the panorama is loaded\r\n      if (!loaded) {\r\n        return;\r\n      }\r\n\r\n      var isKeyDown = false;\r\n      var prevPitch = config.pitch;\r\n      var prevYaw = config.yaw;\r\n      var prevZoom = config.hfov;\r\n      var newTime;\r\n\r\n      if (typeof performance !== \"undefined\" && performance.now()) {\r\n        newTime = performance.now();\r\n      } else {\r\n        newTime = Date.now();\r\n      }\r\n\r\n      if (prevTime === undefined$1) {\r\n        prevTime = newTime;\r\n      }\r\n\r\n      var diff = ((newTime - prevTime) * config.hfov) / 1700;\r\n      diff = Math.min(diff, 1.0); // If minus key is down\r\n\r\n      if (keysDown[0] && config.keyboardZoom === true) {\r\n        setHfov(config.hfov + (speed.hfov * 0.8 + 0.5) * diff);\r\n        isKeyDown = true;\r\n      } // If plus key is down\r\n\r\n      if (keysDown[1] && config.keyboardZoom === true) {\r\n        setHfov(config.hfov + (speed.hfov * 0.8 - 0.2) * diff);\r\n        isKeyDown = true;\r\n      } // If up arrow or \"w\" is down\r\n\r\n      if (keysDown[2] || keysDown[6]) {\r\n        // Pan up\r\n        config.pitch += (speed.pitch * 0.8 + 0.2) * diff;\r\n        isKeyDown = true;\r\n      } // If down arrow or \"s\" is down\r\n\r\n      if (keysDown[3] || keysDown[7]) {\r\n        // Pan down\r\n        config.pitch += (speed.pitch * 0.8 - 0.2) * diff;\r\n        isKeyDown = true;\r\n      } // If left arrow or \"a\" is down\r\n\r\n      if (keysDown[4] || keysDown[8]) {\r\n        // Pan left\r\n        config.yaw += (speed.yaw * 0.8 - 0.2) * diff;\r\n        isKeyDown = true;\r\n      } // If right arrow or \"d\" is down\r\n\r\n      if (keysDown[5] || keysDown[9]) {\r\n        // Pan right\r\n        config.yaw += (speed.yaw * 0.8 + 0.2) * diff;\r\n        isKeyDown = true;\r\n      }\r\n\r\n      if (isKeyDown) latestInteraction = Date.now(); // If auto-rotate\r\n\r\n      if (config.autoRotate) {\r\n        // Pan\r\n        if (newTime - prevTime > 0.001) {\r\n          var timeDiff = (newTime - prevTime) / 1000;\r\n          var yawDiff =\r\n            ((speed.yaw / timeDiff) * diff - config.autoRotate * 0.2) *\r\n            timeDiff;\r\n          yawDiff =\r\n            (-config.autoRotate > 0 ? 1 : -1) *\r\n            Math.min(Math.abs(config.autoRotate * timeDiff), Math.abs(yawDiff));\r\n          config.yaw += yawDiff;\r\n        } // Deal with stopping auto rotation after a set delay\r\n\r\n        if (config.autoRotateStopDelay) {\r\n          config.autoRotateStopDelay -= newTime - prevTime;\r\n\r\n          if (config.autoRotateStopDelay <= 0) {\r\n            config.autoRotateStopDelay = false;\r\n            autoRotateSpeed = config.autoRotate;\r\n            config.autoRotate = 0;\r\n          }\r\n        }\r\n      } // Animated moves\r\n\r\n      if (animatedMove.pitch) {\r\n        animateMove(\"pitch\");\r\n        prevPitch = config.pitch;\r\n      }\r\n\r\n      if (animatedMove.yaw) {\r\n        animateMove(\"yaw\");\r\n        prevYaw = config.yaw;\r\n      }\r\n\r\n      if (animatedMove.hfov) {\r\n        animateMove(\"hfov\");\r\n        prevZoom = config.hfov;\r\n      } // \"Inertia\"\r\n\r\n      if (diff > 0 && !config.autoRotate) {\r\n        // \"Friction\"\r\n        var slowDownFactor = 1 - config.friction; // Yaw\r\n\r\n        if (\r\n          !keysDown[4] &&\r\n          !keysDown[5] &&\r\n          !keysDown[8] &&\r\n          !keysDown[9] &&\r\n          !animatedMove.yaw\r\n        ) {\r\n          config.yaw += speed.yaw * diff * slowDownFactor;\r\n        } // Pitch\r\n\r\n        if (\r\n          !keysDown[2] &&\r\n          !keysDown[3] &&\r\n          !keysDown[6] &&\r\n          !keysDown[7] &&\r\n          !animatedMove.pitch\r\n        ) {\r\n          config.pitch += speed.pitch * diff * slowDownFactor;\r\n        } // Zoom\r\n\r\n        if (!keysDown[0] && !keysDown[1] && !animatedMove.hfov) {\r\n          setHfov(config.hfov + speed.hfov * diff * slowDownFactor);\r\n        }\r\n      }\r\n\r\n      prevTime = newTime;\r\n\r\n      if (diff > 0) {\r\n        speed.yaw = speed.yaw * 0.8 + ((config.yaw - prevYaw) / diff) * 0.2;\r\n        speed.pitch =\r\n          speed.pitch * 0.8 + ((config.pitch - prevPitch) / diff) * 0.2;\r\n        speed.hfov = speed.hfov * 0.8 + ((config.hfov - prevZoom) / diff) * 0.2; // Limit speed\r\n\r\n        var maxSpeed = config.autoRotate ? Math.abs(config.autoRotate) : 5;\r\n        speed.yaw = Math.min(maxSpeed, Math.max(speed.yaw, -maxSpeed));\r\n        speed.pitch = Math.min(maxSpeed, Math.max(speed.pitch, -maxSpeed));\r\n        speed.hfov = Math.min(maxSpeed, Math.max(speed.hfov, -maxSpeed));\r\n      } // Stop movement if opposite controls are pressed\r\n\r\n      if (keysDown[0] && keysDown[1]) {\r\n        speed.hfov = 0;\r\n      }\r\n\r\n      if ((keysDown[2] || keysDown[6]) && (keysDown[3] || keysDown[7])) {\r\n        speed.pitch = 0;\r\n      }\r\n\r\n      if ((keysDown[4] || keysDown[8]) && (keysDown[5] || keysDown[9])) {\r\n        speed.yaw = 0;\r\n      }\r\n    }\r\n    /**\r\n     * Animates moves.\r\n     * @param {string} axis - Axis to animate\r\n     * @private\r\n     */\r\n\r\n    function animateMove(axis) {\r\n      var t = animatedMove[axis];\r\n      var normTime = Math.min(\r\n        1,\r\n        Math.max((Date.now() - t.startTime) / 1000 / (t.duration / 1000), 0)\r\n      );\r\n      var result =\r\n        t.startPosition +\r\n        config.animationTimingFunction(normTime) *\r\n          (t.endPosition - t.startPosition);\r\n\r\n      if (\r\n        (t.endPosition > t.startPosition && result >= t.endPosition) ||\r\n        (t.endPosition < t.startPosition && result <= t.endPosition) ||\r\n        t.endPosition === t.startPosition\r\n      ) {\r\n        result = t.endPosition;\r\n        speed[axis] = 0;\r\n        delete animatedMove[axis];\r\n      }\r\n\r\n      config[axis] = result;\r\n    }\r\n    /**\r\n     * @param {number} t - Normalized time in animation\r\n     * @return {number} Position in animation\r\n     * @private\r\n     */\r\n\r\n    function timingFunction(t) {\r\n      // easeInOutQuad from https://gist.github.com/gre/1650294\r\n      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\r\n    }\r\n    /**\r\n     * Event handler for document resizes. Updates viewer size and rerenders view.\r\n     * @private\r\n     */\r\n\r\n    function onDocumentResize() {\r\n      // Resize panorama renderer (moved to onFullScreenChange)\r\n      //renderer.resize();\r\n      //animateInit();\r\n      // Kludge to deal with WebKit regression: https://bugs.webkit.org/show_bug.cgi?id=93525\r\n      onFullScreenChange(\"resize\");\r\n    }\r\n    /**\r\n     * Initializes animation.\r\n     * @private\r\n     */\r\n\r\n    function animateInit() {\r\n      if (animating) {\r\n        return;\r\n      }\r\n\r\n      animating = true;\r\n      animate();\r\n    }\r\n    /**\r\n     * Animates view, using requestAnimationFrame to trigger rendering.\r\n     * @private\r\n     */\r\n\r\n    function animate() {\r\n      if (destroyed) {\r\n        return;\r\n      }\r\n\r\n      render();\r\n      if (autoRotateStart) clearTimeout(autoRotateStart);\r\n\r\n      if (isUserInteracting || orientation === true) {\r\n        requestAnimationFrame(animate);\r\n      } else if (\r\n        keysDown[0] ||\r\n        keysDown[1] ||\r\n        keysDown[2] ||\r\n        keysDown[3] ||\r\n        keysDown[4] ||\r\n        keysDown[5] ||\r\n        keysDown[6] ||\r\n        keysDown[7] ||\r\n        keysDown[8] ||\r\n        keysDown[9] ||\r\n        config.autoRotate ||\r\n        animatedMove.pitch ||\r\n        animatedMove.yaw ||\r\n        animatedMove.hfov ||\r\n        Math.abs(speed.yaw) > 0.01 ||\r\n        Math.abs(speed.pitch) > 0.01 ||\r\n        Math.abs(speed.hfov) > 0.01\r\n      ) {\r\n        keyRepeat();\r\n\r\n        if (\r\n          config.autoRotateInactivityDelay >= 0 &&\r\n          autoRotateSpeed &&\r\n          Date.now() - latestInteraction > config.autoRotateInactivityDelay &&\r\n          !config.autoRotate\r\n        ) {\r\n          config.autoRotate = autoRotateSpeed;\r\n\r\n          _this.lookAt(origPitch, undefined$1, origHfov, 3000);\r\n        }\r\n\r\n        requestAnimationFrame(animate);\r\n      } else if (\r\n        renderer &&\r\n        (renderer.isLoading() || (config.dynamic === true && update))\r\n      ) {\r\n        requestAnimationFrame(animate);\r\n      } else {\r\n        fireEvent(\"animatefinished\", {\r\n          pitch: _this.getPitch(),\r\n          yaw: _this.getYaw(),\r\n          hfov: _this.getHfov(),\r\n        });\r\n        animating = false;\r\n        prevTime = undefined$1;\r\n        var autoRotateStartTime =\r\n          config.autoRotateInactivityDelay - (Date.now() - latestInteraction);\r\n\r\n        if (autoRotateStartTime > 0) {\r\n          autoRotateStart = setTimeout(function () {\r\n            config.autoRotate = autoRotateSpeed;\r\n\r\n            _this.lookAt(origPitch, undefined$1, origHfov, 3000);\r\n\r\n            animateInit();\r\n          }, autoRotateStartTime);\r\n        } else if (config.autoRotateInactivityDelay >= 0 && autoRotateSpeed) {\r\n          config.autoRotate = autoRotateSpeed;\r\n\r\n          _this.lookAt(origPitch, undefined$1, origHfov, 3000);\r\n\r\n          animateInit();\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Renders panorama view.\r\n     * @private\r\n     */\r\n\r\n    function render() {\r\n      var tmpyaw;\r\n\r\n      if (loaded) {\r\n        var canvas = renderer.getCanvas();\r\n\r\n        if (config.autoRotate !== false) {\r\n          // When auto-rotating this check needs to happen first (see issue #764)\r\n          if (config.yaw > 180) {\r\n            config.yaw -= 360;\r\n          } else if (config.yaw < -180) {\r\n            config.yaw += 360;\r\n          }\r\n        } // Keep a tmp value of yaw for autoRotate comparison later\r\n\r\n        tmpyaw = config.yaw; // Optionally avoid showing background (empty space) on left or right by adapting min/max yaw\r\n\r\n        var hoffcut = 0;\r\n\r\n        if (config.avoidShowingBackground) {\r\n          var hfov2 = config.hfov / 2,\r\n            vfov2 =\r\n              (Math.atan2(\r\n                Math.tan((hfov2 / 180) * Math.PI),\r\n                canvas.width / canvas.height\r\n              ) *\r\n                180) /\r\n              Math.PI,\r\n            transposed = config.vaov > config.haov;\r\n\r\n          if (transposed) {\r\n            vfov2 *\r\n              (1 -\r\n                Math.min(\r\n                  Math.cos(((config.pitch - hfov2) / 180) * Math.PI),\r\n                  Math.cos(((config.pitch + hfov2) / 180) * Math.PI)\r\n                ));\r\n          } else {\r\n            hoffcut =\r\n              hfov2 *\r\n              (1 -\r\n                Math.min(\r\n                  Math.cos(((config.pitch - vfov2) / 180) * Math.PI),\r\n                  Math.cos(((config.pitch + vfov2) / 180) * Math.PI)\r\n                ));\r\n          }\r\n        } // Ensure the yaw is within min and max allowed\r\n\r\n        var yawRange = config.maxYaw - config.minYaw,\r\n          minYaw = -180,\r\n          maxYaw = 180;\r\n\r\n        if (yawRange < 360) {\r\n          minYaw = config.minYaw + config.hfov / 2 + hoffcut;\r\n          maxYaw = config.maxYaw - config.hfov / 2 - hoffcut;\r\n\r\n          if (yawRange < config.hfov) {\r\n            // Lock yaw to average of min and max yaw when both can be seen at once\r\n            minYaw = maxYaw = (minYaw + maxYaw) / 2;\r\n          }\r\n\r\n          config.yaw = Math.max(minYaw, Math.min(maxYaw, config.yaw));\r\n        }\r\n\r\n        if (!(config.autoRotate !== false)) {\r\n          // When not auto-rotating, this check needs to happen after the\r\n          // previous check (see issue #698)\r\n          if (config.yaw > 180) {\r\n            config.yaw -= 360;\r\n          } else if (config.yaw < -180) {\r\n            config.yaw += 360;\r\n          }\r\n        } // Check if we autoRotate in a limited by min and max yaw\r\n        // If so reverse direction\r\n\r\n        if (\r\n          config.autoRotate !== false &&\r\n          tmpyaw != config.yaw &&\r\n          prevTime !== undefined$1\r\n        ) {\r\n          // this condition prevents changing the direction initially\r\n          config.autoRotate *= -1;\r\n        } // Ensure the calculated pitch is within min and max allowed\r\n\r\n        var vfov =\r\n          ((2 *\r\n            Math.atan(\r\n              Math.tan((config.hfov / 180) * Math.PI * 0.5) /\r\n                (canvas.width / canvas.height)\r\n            )) /\r\n            Math.PI) *\r\n          180;\r\n        var minPitch = config.minPitch + vfov / 2,\r\n          maxPitch = config.maxPitch - vfov / 2;\r\n        var pitchRange = config.maxPitch - config.minPitch;\r\n\r\n        if (pitchRange < vfov) {\r\n          // Lock pitch to average of min and max pitch when both can be seen at once\r\n          minPitch = maxPitch = (minPitch + maxPitch) / 2;\r\n        }\r\n\r\n        if (isNaN(minPitch)) minPitch = -90;\r\n        if (isNaN(maxPitch)) maxPitch = 90;\r\n        config.pitch = Math.max(minPitch, Math.min(maxPitch, config.pitch));\r\n        renderer.render(\r\n          (config.pitch * Math.PI) / 180,\r\n          (config.yaw * Math.PI) / 180,\r\n          (config.hfov * Math.PI) / 180,\r\n          {\r\n            roll: (config.roll * Math.PI) / 180,\r\n          }\r\n        );\r\n        renderHotSpots(); // Update compass\r\n\r\n        if (config.compass) {\r\n          compass.style.transform =\r\n            \"rotate(\" + (-config.yaw - config.northOffset) + \"deg)\";\r\n          compass.style.webkitTransform =\r\n            \"rotate(\" + (-config.yaw - config.northOffset) + \"deg)\";\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Creates a new quaternion.\r\n     * @private\r\n     * @constructor\r\n     * @param {Number} w - W value\r\n     * @param {Number} x - X value\r\n     * @param {Number} y - Y value\r\n     * @param {Number} z - Z value\r\n     */\r\n\r\n    function Quaternion(w, x, y, z) {\r\n      this.w = w;\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n    }\r\n    /**\r\n     * Multiplies quaternions.\r\n     * @private\r\n     * @param {Quaternion} q - Quaternion to multiply\r\n     * @returns {Quaternion} Result of multiplication\r\n     */\r\n\r\n    Quaternion.prototype.multiply = function (q) {\r\n      return new Quaternion(\r\n        this.w * q.w - this.x * q.x - this.y * q.y - this.z * q.z,\r\n        this.x * q.w + this.w * q.x + this.y * q.z - this.z * q.y,\r\n        this.y * q.w + this.w * q.y + this.z * q.x - this.x * q.z,\r\n        this.z * q.w + this.w * q.z + this.x * q.y - this.y * q.x\r\n      );\r\n    };\r\n    /**\r\n     * Converts quaternion to Euler angles.\r\n     * @private\r\n     * @returns {Number[]} [phi angle, theta angle, psi angle]\r\n     */\r\n\r\n    Quaternion.prototype.toEulerAngles = function () {\r\n      var phi = Math.atan2(\r\n          2 * (this.w * this.x + this.y * this.z),\r\n          1 - 2 * (this.x * this.x + this.y * this.y)\r\n        ),\r\n        theta = Math.asin(2 * (this.w * this.y - this.z * this.x)),\r\n        psi = Math.atan2(\r\n          2 * (this.w * this.z + this.x * this.y),\r\n          1 - 2 * (this.y * this.y + this.z * this.z)\r\n        );\r\n      return [phi, theta, psi];\r\n    };\r\n    /**\r\n     * Converts device orientation API Tait-Bryan angles to a quaternion.\r\n     * @private\r\n     * @param {Number} alpha - Alpha angle (in degrees)\r\n     * @param {Number} beta - Beta angle (in degrees)\r\n     * @param {Number} gamma - Gamma angle (in degrees)\r\n     * @returns {Quaternion} Orientation quaternion\r\n     */\r\n\r\n    function taitBryanToQuaternion(alpha, beta, gamma) {\r\n      var r = [\r\n        beta ? (beta * Math.PI) / 180 / 2 : 0,\r\n        gamma ? (gamma * Math.PI) / 180 / 2 : 0,\r\n        alpha ? (alpha * Math.PI) / 180 / 2 : 0,\r\n      ];\r\n      var c = [Math.cos(r[0]), Math.cos(r[1]), Math.cos(r[2])],\r\n        s = [Math.sin(r[0]), Math.sin(r[1]), Math.sin(r[2])];\r\n      return new Quaternion(\r\n        c[0] * c[1] * c[2] - s[0] * s[1] * s[2],\r\n        s[0] * c[1] * c[2] - c[0] * s[1] * s[2],\r\n        c[0] * s[1] * c[2] + s[0] * c[1] * s[2],\r\n        c[0] * c[1] * s[2] + s[0] * s[1] * c[2]\r\n      );\r\n    }\r\n    /**\r\n     * Computes current device orientation quaternion from device orientation API\r\n     * Tait-Bryan angles.\r\n     * @private\r\n     * @param {Number} alpha - Alpha angle (in degrees)\r\n     * @param {Number} beta - Beta angle (in degrees)\r\n     * @param {Number} gamma - Gamma angle (in degrees)\r\n     * @returns {Quaternion} Orientation quaternion\r\n     */\r\n\r\n    function computeQuaternion(alpha, beta, gamma) {\r\n      // Convert Tait-Bryan angles to quaternion\r\n      var quaternion = taitBryanToQuaternion(alpha, beta, gamma); // Apply world transform\r\n\r\n      quaternion = quaternion.multiply(\r\n        new Quaternion(Math.sqrt(0.5), -Math.sqrt(0.5), 0, 0)\r\n      ); // Apply screen transform\r\n\r\n      var angle = window.orientation\r\n        ? (-window.orientation * Math.PI) / 180 / 2\r\n        : 0;\r\n      return quaternion.multiply(\r\n        new Quaternion(Math.cos(angle), 0, -Math.sin(angle), 0)\r\n      );\r\n    }\r\n    /**\r\n     * Event handler for device orientation API. Controls pointing.\r\n     * @private\r\n     * @param {DeviceOrientationEvent} event - Device orientation event.\r\n     */\r\n\r\n    function orientationListener(e) {\r\n      if (e.hasOwnProperty(\"requestPermission\")) e.requestPermission();\r\n      var q = computeQuaternion(e.alpha, e.beta, e.gamma).toEulerAngles();\r\n\r\n      if (typeof orientation === \"number\" && orientation < 10) {\r\n        // This kludge is necessary because iOS sometimes provides a few stale\r\n        // device orientation events when the listener is removed and then\r\n        // readded. Thus, we skip the first 10 events to prevent this from\r\n        // causing problems.\r\n        orientation += 1;\r\n      } else if (orientation === 10) {\r\n        // Record starting yaw to prevent jumping\r\n        orientationYawOffset = (q[2] / Math.PI) * 180 + config.yaw;\r\n        orientation = true;\r\n        requestAnimationFrame(animate);\r\n      } else {\r\n        config.pitch = (q[0] / Math.PI) * 180;\r\n        config.roll = (-q[1] / Math.PI) * 180;\r\n        config.yaw = (-q[2] / Math.PI) * 180 + orientationYawOffset;\r\n      }\r\n    }\r\n    /**\r\n     * Initializes renderer.\r\n     * @private\r\n     */\r\n\r\n    function renderInit() {\r\n      try {\r\n        var params = {};\r\n        if (config.horizonPitch !== undefined$1)\r\n          params.horizonPitch = (config.horizonPitch * Math.PI) / 180;\r\n        if (config.horizonRoll !== undefined$1)\r\n          params.horizonRoll = (config.horizonRoll * Math.PI) / 180;\r\n        if (config.backgroundColor !== undefined$1)\r\n          params.backgroundColor = config.backgroundColor;\r\n        renderer.init(\r\n          panoImage,\r\n          config.type,\r\n          config.dynamic,\r\n          (config.haov * Math.PI) / 180,\r\n          (config.vaov * Math.PI) / 180,\r\n          (config.vOffset * Math.PI) / 180,\r\n          renderInitCallback,\r\n          params\r\n        );\r\n\r\n        if (config.dynamic !== true) {\r\n          // Allow image to be garbage collected\r\n          panoImage = undefined$1;\r\n        }\r\n      } catch (event) {\r\n        // Panorama not loaded\r\n        // Display error if there is a bad texture\r\n        if (event.type === \"webgl error\" || event.type === \"no webgl\") {\r\n          anError();\r\n        } else if (event.type === \"webgl size error\") {\r\n          anError(\r\n            config.uiText.textureSizeError\r\n              .replace(\"%s\", event.width)\r\n              .replace(\"%s\", event.maxWidth)\r\n          );\r\n        } else {\r\n          anError(config.uiText.unknownError);\r\n          throw event;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Triggered when render initialization finishes. Handles fading between\r\n     * scenes as well as showing the compass and hotspots and hiding the loading\r\n     * display.\r\n     * @private\r\n     */\r\n\r\n    function renderInitCallback() {\r\n      // Fade if specified\r\n      if (config.sceneFadeDuration && renderer.fadeImg !== undefined$1) {\r\n        renderer.fadeImg.style.opacity = 0; // Remove image\r\n\r\n        var fadeImg = renderer.fadeImg;\r\n        delete renderer.fadeImg;\r\n        setTimeout(function () {\r\n          renderContainer.removeChild(fadeImg);\r\n          fireEvent(\"scenechangefadedone\");\r\n        }, config.sceneFadeDuration);\r\n      } // Show compass if applicable\r\n\r\n      if (config.compass) {\r\n        compass.style.display = \"inline\";\r\n      } else {\r\n        compass.style.display = \"none\";\r\n      } // Show hotspots\r\n\r\n      createHotSpots(); // Hide loading display\r\n\r\n      infoDisplay.load.box.style.display = \"none\";\r\n\r\n      if (preview !== undefined$1) {\r\n        renderContainer.removeChild(preview);\r\n        preview = undefined$1;\r\n      }\r\n\r\n      loaded = true;\r\n      animateInit();\r\n      fireEvent(\"load\");\r\n    }\r\n    /**\r\n     * Creates hot spot element for the current scene.\r\n     * @private\r\n     * @param {Object} hs - The configuration for the hotspot\r\n     */\r\n\r\n    function createHotSpot(hs) {\r\n      // Make sure hot spot pitch and yaw are numbers\r\n      hs.pitch = Number(hs.pitch) || 0;\r\n      hs.yaw = Number(hs.yaw) || 0;\r\n      var div = document.createElement(\"div\");\r\n      div.className = \"pnlm-hotspot-base\";\r\n      if (hs.cssClass) div.className += \" \" + hs.cssClass;\r\n      else\r\n        div.className +=\r\n          \" pnlm-hotspot pnlm-sprite pnlm-\" + escapeHTML(hs.type);\r\n      var span = document.createElement(\"span\");\r\n      if (hs.text) span.innerHTML = escapeHTML(hs.text);\r\n      var a;\r\n\r\n      if (hs.video) {\r\n        var video = document.createElement(\"video\"),\r\n          vidp = hs.video;\r\n        if (config.basePath && !absoluteURL(vidp))\r\n          vidp = config.basePath + vidp;\r\n        video.src = sanitizeURL(vidp);\r\n        video.controls = true;\r\n        video.style.width = hs.width + \"px\";\r\n        renderContainer.appendChild(div);\r\n        span.appendChild(video);\r\n      } else if (hs.image) {\r\n        var imgp = hs.image;\r\n        if (config.basePath && !absoluteURL(imgp))\r\n          imgp = config.basePath + imgp;\r\n        a = document.createElement(\"a\");\r\n        a.href = sanitizeURL(hs.URL ? hs.URL : imgp);\r\n        a.target = \"_blank\";\r\n        span.appendChild(a);\r\n        var image = document.createElement(\"img\");\r\n        image.src = sanitizeURL(imgp);\r\n        image.style.width = hs.width + \"px\";\r\n        image.style.paddingTop = \"5px\";\r\n        renderContainer.appendChild(div);\r\n        a.appendChild(image);\r\n        span.style.maxWidth = \"initial\";\r\n      } else if (hs.URL) {\r\n        a = document.createElement(\"a\");\r\n        a.href = sanitizeURL(hs.URL);\r\n\r\n        if (hs.attributes) {\r\n          for (var key in hs.attributes) {\r\n            a.setAttribute(key, hs.attributes[key]);\r\n          }\r\n        } else {\r\n          a.target = \"_blank\";\r\n        }\r\n\r\n        renderContainer.appendChild(a);\r\n        div.className += \" pnlm-pointer\";\r\n        span.className += \" pnlm-pointer\";\r\n        a.appendChild(div);\r\n      } else {\r\n        if (hs.sceneId) {\r\n          div.onclick = div.ontouchend = function () {\r\n            if (!div.clicked) {\r\n              div.clicked = true;\r\n              dLastPitch = hs.pitch;\r\n              dLastYaw = hs.yaw;\r\n              dLastHfov = _this.getHfov();\r\n              setTimeout(function () {\r\n                lookAndWait(_this.getHfov(), dTimeLookAtHotSpot);\r\n              }, 10); //--- first look directly at the hotspot\r\n              lookAndWait(50, dTimeZoomInHotSpot); //--- then zoom in\r\n              setTimeout(function () {\r\n                _this.loadScene(hs.sceneId, dLastPitch, dLastYaw, 120);\r\n              }, dTimeToLoad); // then load the new scene\r\n              // loadScene(\r\n              //   hs.sceneId,\r\n              //   hs.targetPitch,\r\n              //   hs.targetYaw,\r\n              //   hs.targetHfov\r\n              // );\r\n            }\r\n\r\n            return false;\r\n          };\r\n\r\n          div.className += \" pnlm-pointer\";\r\n          span.className += \" pnlm-pointer\";\r\n        }\r\n\r\n        renderContainer.appendChild(div);\r\n      }\r\n\r\n      if (hs.createTooltipFunc) {\r\n        hs.createTooltipFunc(div, hs.createTooltipArgs);\r\n      } else if (hs.text || hs.video || hs.image) {\r\n        div.classList.add(\"pnlm-tooltip\");\r\n        div.appendChild(span);\r\n        span.style.wordBreak = \"break-word\";\r\n        span.style.width = span.scrollWidth - 20 + \"px\";\r\n        span.style.marginLeft =\r\n          -(span.scrollWidth - div.offsetWidth) / 2 + \"px\";\r\n        span.style.marginTop = -span.scrollHeight - 12 + \"px\";\r\n      }\r\n\r\n      if (hs.clickHandlerFunc) {\r\n        div.addEventListener(\r\n          \"click\",\r\n          function (e) {\r\n            hs.clickHandlerFunc(e, hs.clickHandlerArgs);\r\n          },\r\n          \"false\"\r\n        );\r\n        div.className += \" pnlm-pointer\";\r\n        span.className += \" pnlm-pointer\";\r\n      }\r\n\r\n      hs.div = div;\r\n    }\r\n\r\n    function lookAndWait(dHfov, dTime) {\r\n      // Initiate LookAt / Zoom\r\n      var pZ = dLastPitch; // Or other pan angle to Zoom in on.\r\n      var yZ = dLastYaw; // Or other yaw angle to Zoom in on.\r\n      var vZ = dHfov; // Or other Hfov angle to Zoom in on.\r\n      var pS = dTime; // Or other zoom speed\r\n      _this.lookAt(pZ, yZ, vZ, pS);\r\n      setTimeout(function () {\r\n        waitForView(dLastPitch, dLastYaw, vZ);\r\n      }, 1000);\r\n    }\r\n\r\n    function waitForView(dPitch, dYaw, dHfov) {\r\n      var iCnt = 0;\r\n      let pI = Math.round(_this.getPitch()); // get actual pitch and round\r\n      let yI = Math.round(_this.getYaw()); // get actual yaw and round\r\n      let vI = Math.round(_this.getHfov()); // get actual Hfov and round\r\n\r\n      if (yI > 180) {\r\n        yI = yI - 360;\r\n        _this.setYaw(yI, 0);\r\n      }\r\n      if (yI < -180) {\r\n        yI = yI + 360;\r\n        _this.setYaw(yI, 0);\r\n      }\r\n\r\n      if (pI === dPitch && yI === dYaw && vI === dHfov) {\r\n        // Has LookAt finished\r\n        return true;\r\n      } else {\r\n        setTimeout(function () {\r\n          waitForView(dPitch, dYaw, dHfov);\r\n        }, 10);\r\n      }\r\n    }\r\n\r\n    function sceneLoadListener() {\r\n      //--- zoom a little bit into current viewing direction\r\n      lookAndWait(110, dTimeZoomInAfterLoad);\r\n    }\r\n    /**\r\n     * Creates hot spot elements for the current scene.\r\n     * @private\r\n     */\r\n\r\n    function createHotSpots() {\r\n      if (hotspotsCreated) return;\r\n\r\n      if (!config.hotSpots) {\r\n        config.hotSpots = [];\r\n      } else {\r\n        // Sort by pitch so tooltip is never obscured by another hot spot\r\n        config.hotSpots = config.hotSpots.sort(function (a, b) {\r\n          return a.pitch < b.pitch;\r\n        });\r\n        config.hotSpots.forEach(createHotSpot);\r\n      }\r\n\r\n      hotspotsCreated = true;\r\n      renderHotSpots();\r\n    }\r\n    /**\r\n     * Destroys currently created hot spot elements.\r\n     * @private\r\n     */\r\n\r\n    function destroyHotSpots() {\r\n      var hs = config.hotSpots;\r\n      hotspotsCreated = false;\r\n      delete config.hotSpots;\r\n\r\n      if (hs) {\r\n        for (var i = 0; i < hs.length; i++) {\r\n          var current = hs[i].div;\r\n\r\n          if (current) {\r\n            while (\r\n              current.parentNode &&\r\n              current.parentNode != renderContainer\r\n            ) {\r\n              current = current.parentNode;\r\n            }\r\n\r\n            renderContainer.removeChild(current);\r\n          }\r\n\r\n          delete hs[i].div;\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Renders hot spot, updating its position and visibility.\r\n     * @private\r\n     */\r\n\r\n    function renderHotSpot(hs) {\r\n      var hsPitchSin = Math.sin((hs.pitch * Math.PI) / 180),\r\n        hsPitchCos = Math.cos((hs.pitch * Math.PI) / 180),\r\n        configPitchSin = Math.sin((config.pitch * Math.PI) / 180),\r\n        configPitchCos = Math.cos((config.pitch * Math.PI) / 180),\r\n        yawCos = Math.cos(((-hs.yaw + config.yaw) * Math.PI) / 180);\r\n      var z =\r\n        hsPitchSin * configPitchSin + hsPitchCos * yawCos * configPitchCos;\r\n\r\n      if (\r\n        (hs.yaw <= 90 && hs.yaw > -90 && z <= 0) ||\r\n        ((hs.yaw > 90 || hs.yaw <= -90) && z <= 0)\r\n      ) {\r\n        hs.div.style.visibility = \"hidden\";\r\n      } else {\r\n        var yawSin = Math.sin(((-hs.yaw + config.yaw) * Math.PI) / 180),\r\n          hfovTan = Math.tan((config.hfov * Math.PI) / 360);\r\n        hs.div.style.visibility = \"visible\"; // Subpixel rendering doesn't work in Firefox\r\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=739176\r\n\r\n        var canvas = renderer.getCanvas(),\r\n          canvasWidth = canvas.clientWidth,\r\n          canvasHeight = canvas.clientHeight;\r\n        var coord = [\r\n          ((-canvasWidth / hfovTan) * yawSin * hsPitchCos) / z / 2,\r\n          ((-canvasWidth / hfovTan) *\r\n            (hsPitchSin * configPitchCos -\r\n              hsPitchCos * yawCos * configPitchSin)) /\r\n            z /\r\n            2,\r\n        ]; // Apply roll\r\n\r\n        var rollSin = Math.sin((config.roll * Math.PI) / 180),\r\n          rollCos = Math.cos((config.roll * Math.PI) / 180);\r\n        coord = [\r\n          coord[0] * rollCos - coord[1] * rollSin,\r\n          coord[0] * rollSin + coord[1] * rollCos,\r\n        ]; // Apply transform\r\n\r\n        coord[0] += (canvasWidth - hs.div.offsetWidth) / 2;\r\n        coord[1] += (canvasHeight - hs.div.offsetHeight) / 2;\r\n        var transform =\r\n          \"translate(\" +\r\n          coord[0] +\r\n          \"px, \" +\r\n          coord[1] +\r\n          \"px) translateZ(9999px) rotate(\" +\r\n          config.roll +\r\n          \"deg)\";\r\n\r\n        if (hs.scale) {\r\n          transform += \" scale(\" + origHfov / config.hfov / z + \")\";\r\n        }\r\n\r\n        hs.div.style.webkitTransform = transform;\r\n        hs.div.style.MozTransform = transform;\r\n        hs.div.style.transform = transform;\r\n      }\r\n    }\r\n    /**\r\n     * Renders hot spots, updating their positions and visibility.\r\n     * @private\r\n     */\r\n\r\n    function renderHotSpots() {\r\n      config.hotSpots.forEach(renderHotSpot);\r\n    }\r\n    /**\r\n     * Merges a scene configuration into the current configuration.\r\n     * @private\r\n     * @param {string} sceneId - Identifier of scene configuration to merge in.\r\n     */\r\n\r\n    function mergeConfig(sceneId) {\r\n      config = {};\r\n      var k, s;\r\n      var photoSphereExcludes = [\r\n        \"haov\",\r\n        \"vaov\",\r\n        \"vOffset\",\r\n        \"northOffset\",\r\n        \"horizonPitch\",\r\n        \"horizonRoll\",\r\n      ];\r\n      specifiedPhotoSphereExcludes = []; // Merge default config\r\n\r\n      for (k in defaultConfig) {\r\n        if (defaultConfig.hasOwnProperty(k)) {\r\n          config[k] = defaultConfig[k];\r\n        }\r\n      } // Merge default scene config\r\n\r\n      for (k in initialConfig[\"default\"]) {\r\n        if (initialConfig[\"default\"].hasOwnProperty(k)) {\r\n          if (k === \"uiText\") {\r\n            for (s in initialConfig[\"default\"].uiText) {\r\n              if (initialConfig[\"default\"].uiText.hasOwnProperty(s)) {\r\n                config.uiText[s] = escapeHTML(\r\n                  initialConfig[\"default\"].uiText[s]\r\n                );\r\n              }\r\n            }\r\n          } else {\r\n            config[k] = initialConfig[\"default\"][k];\r\n\r\n            if (photoSphereExcludes.indexOf(k) >= 0) {\r\n              specifiedPhotoSphereExcludes.push(k);\r\n            }\r\n          }\r\n        }\r\n      } // Merge current scene config\r\n\r\n      if (\r\n        sceneId !== null &&\r\n        sceneId !== \"\" &&\r\n        initialConfig.scenes &&\r\n        initialConfig.scenes[sceneId]\r\n      ) {\r\n        var scene = initialConfig.scenes[sceneId];\r\n\r\n        for (k in scene) {\r\n          if (scene.hasOwnProperty(k)) {\r\n            if (k === \"uiText\") {\r\n              for (s in scene.uiText) {\r\n                if (scene.uiText.hasOwnProperty(s)) {\r\n                  config.uiText[s] = escapeHTML(scene.uiText[s]);\r\n                }\r\n              }\r\n            } else {\r\n              config[k] = scene[k];\r\n\r\n              if (photoSphereExcludes.indexOf(k) >= 0) {\r\n                specifiedPhotoSphereExcludes.push(k);\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        config.scene = sceneId;\r\n      } // Merge initial config\r\n\r\n      for (k in initialConfig) {\r\n        if (initialConfig.hasOwnProperty(k)) {\r\n          if (k === \"uiText\") {\r\n            for (s in initialConfig.uiText) {\r\n              if (initialConfig.uiText.hasOwnProperty(s)) {\r\n                config.uiText[s] = escapeHTML(initialConfig.uiText[s]);\r\n              }\r\n            }\r\n          } else {\r\n            config[k] = initialConfig[k];\r\n\r\n            if (photoSphereExcludes.indexOf(k) >= 0) {\r\n              specifiedPhotoSphereExcludes.push(k);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Processes configuration options.\r\n     * @param {boolean} [isPreview] - Whether or not the preview is being displayed\r\n     * @private\r\n     */\r\n\r\n    function processOptions(isPreview) {\r\n      isPreview = isPreview ? isPreview : false; // Process preview first so it always loads before the browser hits its\r\n      // maximum number of connections to a server as can happen with cubic\r\n      // panoramas\r\n\r\n      if (isPreview && \"preview\" in config) {\r\n        var p = config.preview;\r\n        if (config.basePath && !absoluteURL(p)) p = config.basePath + p;\r\n        preview = document.createElement(\"div\");\r\n        preview.className = \"pnlm-preview-img\";\r\n        preview.style.backgroundImage = \"url('\" + sanitizeURLForCss(p) + \"')\";\r\n        renderContainer.appendChild(preview);\r\n      } // Handle different preview values\r\n\r\n      var title = config.title,\r\n        author = config.author,\r\n        description = config.description;\r\n\r\n      if (isPreview) {\r\n        if (\"previewTitle\" in config) config.title = config.previewTitle;\r\n        if (\"previewDescription\" in config)\r\n          config.description = config.previewDescription;\r\n        if (\"previewAuthor\" in config) config.author = config.previewAuthor;\r\n      } // Reset title / author display\r\n\r\n      if (!config.hasOwnProperty(\"title\")) infoDisplay.title.innerHTML = \"\";\r\n      if (!config.hasOwnProperty(\"description\"))\r\n        infoDisplay.description.innerHTML = \"\";\r\n      if (!config.hasOwnProperty(\"author\")) infoDisplay.author.innerHTML = \"\";\r\n      if (\r\n        !config.hasOwnProperty(\"title\") &&\r\n        !config.hasOwnProperty(\"description\") &&\r\n        !config.hasOwnProperty(\"author\")\r\n      )\r\n        infoDisplay.container.style.display = \"none\"; // Fill in load button label and loading box text\r\n\r\n      controls.load.innerHTML = \"<p>\" + config.uiText.loadButtonLabel + \"</p>\";\r\n      infoDisplay.load.boxp.innerHTML = config.uiText.loadingLabel; // Process other options\r\n\r\n      for (var key in config) {\r\n        if (config.hasOwnProperty(key)) {\r\n          switch (key) {\r\n            case \"title\":\r\n              infoDisplay.title.innerHTML = escapeHTML(config[key]);\r\n              infoDisplay.container.style.display = \"inline\";\r\n              break;\r\n\r\n            case \"description\":\r\n              infoDisplay.description.innerHTML = escapeHTML(config[key]);\r\n              infoDisplay.container.style.display = \"inline\";\r\n              break;\r\n\r\n            case \"author\":\r\n              var authorText = escapeHTML(config[key]);\r\n\r\n              if (config.authorURL) {\r\n                var authorLink = document.createElement(\"a\");\r\n                authorLink.href = sanitizeURL(config[\"authorURL\"]);\r\n                authorLink.target = \"_blank\";\r\n                authorLink.innerHTML = escapeHTML(config[key]);\r\n                authorText = authorLink.outerHTML;\r\n              }\r\n\r\n              infoDisplay.author.innerHTML = config.uiText.bylineLabel.replace(\r\n                \"%s\",\r\n                authorText\r\n              );\r\n              infoDisplay.container.style.display = \"inline\";\r\n              break;\r\n\r\n            case \"fallback\":\r\n              var link = document.createElement(\"a\");\r\n              link.href = sanitizeURL(config[key]);\r\n              link.target = \"_blank\";\r\n              link.textContent =\r\n                \"Click here to view this panorama in an alternative viewer.\";\r\n              var message = document.createElement(\"p\");\r\n              message.textContent = \"Your browser does not support WebGL.\";\r\n              message.appendChild(document.createElement(\"br\"));\r\n              message.appendChild(link);\r\n              infoDisplay.errorMsg.innerHTML = \"\"; // Removes all children nodes\r\n\r\n              infoDisplay.errorMsg.appendChild(message);\r\n              break;\r\n\r\n            case \"hfov\":\r\n              setHfov(Number(config[key]));\r\n              break;\r\n\r\n            case \"autoLoad\":\r\n              if (config[key] === true && renderer === undefined$1) {\r\n                // Show loading box\r\n                infoDisplay.load.box.style.display = \"inline\"; // Hide load button\r\n\r\n                controls.load.style.display = \"none\"; // Initialize\r\n\r\n                init();\r\n              }\r\n\r\n              break;\r\n\r\n            case \"showZoomCtrl\":\r\n              if (config[key] && config.showControls != false) {\r\n                // Show zoom controls\r\n                controls.zoom.style.display = \"block\";\r\n              } else {\r\n                // Hide zoom controls\r\n                controls.zoom.style.display = \"none\";\r\n              }\r\n\r\n              break;\r\n\r\n            case \"showFullscreenCtrl\":\r\n              if (\r\n                config[key] &&\r\n                config.showControls != false &&\r\n                (\"fullscreen\" in document ||\r\n                  \"mozFullScreen\" in document ||\r\n                  \"webkitIsFullScreen\" in document ||\r\n                  \"msFullscreenElement\" in document)\r\n              ) {\r\n                // Show fullscreen control\r\n                controls.fullscreen.style.display = \"block\";\r\n              } else {\r\n                // Hide fullscreen control\r\n                controls.fullscreen.style.display = \"none\";\r\n              }\r\n\r\n              break;\r\n\r\n            case \"hotSpotDebug\":\r\n              if (config[key]) hotSpotDebugIndicator.style.display = \"block\";\r\n              else hotSpotDebugIndicator.style.display = \"none\";\r\n              break;\r\n\r\n            case \"showControls\":\r\n              if (!config[key]) {\r\n                controls.orientation.style.display = \"none\";\r\n                controls.zoom.style.display = \"none\";\r\n                controls.fullscreen.style.display = \"none\";\r\n              }\r\n\r\n              break;\r\n\r\n            case \"orientationOnByDefault\":\r\n              if (config[key]) {\r\n                startOrientation();\r\n                break;\r\n              }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (isPreview) {\r\n        // Restore original values if changed for preview\r\n        if (title) config.title = title;\r\n        else delete config.title;\r\n        if (description) config.description = description;\r\n        else delete config.description;\r\n        if (author) config.author = author;\r\n        else delete config.author;\r\n      }\r\n    }\r\n    /**\r\n     * Toggles fullscreen mode.\r\n     * @private\r\n     */\r\n\r\n    function toggleFullscreen() {\r\n      if (loaded && !error) {\r\n        if (!fullscreenActive) {\r\n          try {\r\n            if (container.requestFullscreen) {\r\n              container.requestFullscreen();\r\n            } else if (container.mozRequestFullScreen) {\r\n              container.mozRequestFullScreen();\r\n            } else if (container.msRequestFullscreen) {\r\n              container.msRequestFullscreen();\r\n            } else {\r\n              container.webkitRequestFullScreen();\r\n            }\r\n          } catch (event) {\r\n            // Fullscreen doesn't work\r\n          }\r\n        } else {\r\n          if (document.exitFullscreen) {\r\n            document.exitFullscreen();\r\n          } else if (document.mozCancelFullScreen) {\r\n            document.mozCancelFullScreen();\r\n          } else if (document.webkitCancelFullScreen) {\r\n            document.webkitCancelFullScreen();\r\n          } else if (document.msExitFullscreen) {\r\n            document.msExitFullscreen();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Event handler for fullscreen changes.\r\n     * @private\r\n     */\r\n\r\n    function onFullScreenChange(resize) {\r\n      if (\r\n        document.fullscreenElement ||\r\n        document.fullscreen ||\r\n        document.mozFullScreen ||\r\n        document.webkitIsFullScreen ||\r\n        document.msFullscreenElement\r\n      ) {\r\n        controls.fullscreen.classList.add(\r\n          \"pnlm-fullscreen-toggle-button-active\"\r\n        );\r\n        fullscreenActive = true;\r\n      } else {\r\n        controls.fullscreen.classList.remove(\r\n          \"pnlm-fullscreen-toggle-button-active\"\r\n        );\r\n        fullscreenActive = false;\r\n      }\r\n\r\n      if (resize !== \"resize\") fireEvent(\"fullscreenchange\", fullscreenActive); // Resize renderer (deal with browser quirks and fixes #155)\r\n\r\n      renderer.resize();\r\n      setHfov(config.hfov);\r\n      animateInit();\r\n    }\r\n    /**\r\n     * Increases panorama zoom. For use with zoom button.\r\n     * @private\r\n     */\r\n\r\n    function zoomIn() {\r\n      if (loaded) {\r\n        setHfov(config.hfov - 5);\r\n        animateInit();\r\n      }\r\n    }\r\n    /**\r\n     * Decreases panorama zoom. For use with zoom button.\r\n     * @private\r\n     */\r\n\r\n    function zoomOut() {\r\n      if (loaded) {\r\n        setHfov(config.hfov + 5);\r\n        animateInit();\r\n      }\r\n    }\r\n    /**\r\n     * Clamps horzontal field of view to viewer's limits.\r\n     * @private\r\n     * @param {number} hfov - Input horizontal field of view (in degrees)\r\n     * @return {number} - Clamped horizontal field of view (in degrees)\r\n     */\r\n\r\n    function constrainHfov(hfov) {\r\n      // Keep field of view within bounds\r\n      var minHfov = config.minHfov;\r\n\r\n      if (config.type === \"multires\" && renderer && !config.multiResMinHfov) {\r\n        minHfov = Math.min(\r\n          minHfov,\r\n          renderer.getCanvas().width /\r\n            ((config.multiRes.cubeResolution / 90) * 0.9)\r\n        );\r\n      }\r\n\r\n      if (minHfov > config.maxHfov) {\r\n        // Don't change view if bounds don't make sense\r\n        console.log(\"HFOV bounds do not make sense (minHfov > maxHfov).\");\r\n        return config.hfov;\r\n      }\r\n\r\n      var newHfov = config.hfov;\r\n\r\n      if (hfov < minHfov) {\r\n        newHfov = minHfov;\r\n      } else if (hfov > config.maxHfov) {\r\n        newHfov = config.maxHfov;\r\n      } else {\r\n        newHfov = hfov;\r\n      } // Optionally avoid showing background (empty space) on top or bottom by adapting newHfov\r\n\r\n      if (config.avoidShowingBackground && renderer) {\r\n        var canvas = renderer.getCanvas();\r\n        newHfov = Math.min(\r\n          newHfov,\r\n          (Math.atan(\r\n            (Math.tan(((config.maxPitch - config.minPitch) / 360) * Math.PI) /\r\n              canvas.height) *\r\n              canvas.width\r\n          ) *\r\n            360) /\r\n            Math.PI\r\n        );\r\n      }\r\n\r\n      return newHfov;\r\n    }\r\n    /**\r\n     * Sets viewer's horizontal field of view.\r\n     * @private\r\n     * @param {number} hfov - Desired horizontal field of view in degrees.\r\n     */\r\n\r\n    function setHfov(hfov) {\r\n      config.hfov = constrainHfov(hfov);\r\n      fireEvent(\"zoomchange\", config.hfov);\r\n    }\r\n    /**\r\n     * Stops auto rotation and animated moves.\r\n     * @private\r\n     */\r\n\r\n    function stopAnimation() {\r\n      animatedMove = {};\r\n      autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;\r\n      config.autoRotate = false;\r\n    }\r\n    /**\r\n     * Loads panorama.\r\n     * @private\r\n     */\r\n\r\n    function load() {\r\n      // Since WebGL error handling is very general, first we clear any error box\r\n      // since it is a new scene and the error from previous maybe because of lacking\r\n      // memory etc and not because of a lack of WebGL support etc\r\n      clearError();\r\n      loaded = false;\r\n      controls.load.style.display = \"none\";\r\n      infoDisplay.load.box.style.display = \"inline\";\r\n      init();\r\n    }\r\n    /**\r\n     * Loads scene.\r\n     * @private\r\n     * @param {string} sceneId - Identifier of scene configuration to merge in.\r\n     * @param {number} targetPitch - Pitch viewer should be centered on once scene loads.\r\n     * @param {number} targetYaw - Yaw viewer should be centered on once scene loads.\r\n     * @param {number} targetHfov - HFOV viewer should use once scene loads.\r\n     * @param {boolean} [fadeDone] - If `true`, fade setup is skipped.\r\n     */\r\n\r\n    function loadScene(sceneId, targetPitch, targetYaw, targetHfov, fadeDone) {\r\n      if (!loaded) fadeDone = true; // Don't try to fade when there isn't a scene loaded\r\n\r\n      loaded = false;\r\n      animatedMove = {}; // Set up fade if specified\r\n\r\n      var fadeImg, workingPitch, workingYaw, workingHfov;\r\n\r\n      if (config.sceneFadeDuration && !fadeDone) {\r\n        var data = renderer.render(\r\n          (config.pitch * Math.PI) / 180,\r\n          (config.yaw * Math.PI) / 180,\r\n          (config.hfov * Math.PI) / 180,\r\n          {\r\n            returnImage: true,\r\n          }\r\n        );\r\n\r\n        if (data !== undefined$1) {\r\n          fadeImg = new Image();\r\n          fadeImg.className = \"pnlm-fade-img\";\r\n          fadeImg.style.transition =\r\n            \"opacity \" + config.sceneFadeDuration / 1000 + \"s\";\r\n          fadeImg.style.width = \"100%\";\r\n          fadeImg.style.height = \"100%\";\r\n\r\n          fadeImg.onload = function () {\r\n            loadScene(sceneId, targetPitch, targetYaw, targetHfov, true);\r\n          };\r\n\r\n          fadeImg.src = data;\r\n          renderContainer.appendChild(fadeImg);\r\n          renderer.fadeImg = fadeImg;\r\n          return;\r\n        }\r\n      } // Set new pointing\r\n\r\n      if (targetPitch === \"same\") {\r\n        workingPitch = config.pitch;\r\n      } else {\r\n        workingPitch = targetPitch;\r\n      }\r\n\r\n      if (targetYaw === \"same\") {\r\n        workingYaw = config.yaw;\r\n      } else if (targetYaw === \"sameAzimuth\") {\r\n        workingYaw =\r\n          config.yaw +\r\n          (config.northOffset || 0) -\r\n          (initialConfig.scenes[sceneId].northOffset || 0);\r\n      } else {\r\n        workingYaw = targetYaw;\r\n      }\r\n\r\n      if (targetHfov === \"same\") {\r\n        workingHfov = config.hfov;\r\n      } else {\r\n        workingHfov = targetHfov;\r\n      } // Destroy hot spots from previous scene\r\n\r\n      destroyHotSpots(); // Create the new config for the scene\r\n\r\n      mergeConfig(sceneId); // Stop motion\r\n\r\n      speed.yaw = speed.pitch = speed.hfov = 0; // Reload scene\r\n\r\n      processOptions();\r\n\r\n      if (workingPitch !== undefined$1) {\r\n        config.pitch = workingPitch;\r\n      }\r\n\r\n      if (workingYaw !== undefined$1) {\r\n        config.yaw = workingYaw;\r\n      }\r\n\r\n      if (workingHfov !== undefined$1) {\r\n        config.hfov = workingHfov;\r\n      }\r\n\r\n      fireEvent(\"scenechange\", sceneId);\r\n      load();\r\n    }\r\n    /**\r\n     * Stop using device orientation.\r\n     * @private\r\n     */\r\n\r\n    function stopOrientation() {\r\n      window.removeEventListener(\"deviceorientation\", orientationListener);\r\n      controls.orientation.classList.remove(\"pnlm-orientation-button-active\");\r\n      orientation = false;\r\n    }\r\n    /**\r\n     * Start using device orientation.\r\n     * @private\r\n     */\r\n\r\n    function startOrientation() {\r\n      orientation = 1; // Fix for IOS 13 where the user needs to perform an action i.e click. Then we need to ask permission\r\n\r\n      if (\r\n        DeviceOrientationEvent &&\r\n        typeof DeviceOrientationEvent.requestPermission === \"function\"\r\n      ) {\r\n        DeviceOrientationEvent.requestPermission()\r\n          .then(function (response) {\r\n            if (response === \"granted\") {\r\n              window.addEventListener(\"deviceorientation\", orientationListener);\r\n            }\r\n          })\r\n          [\"catch\"](console.error);\r\n      } else {\r\n        window.addEventListener(\"deviceorientation\", orientationListener);\r\n      } // window.addEventListener('deviceorientation', orientationListener);\r\n\r\n      controls.orientation.classList.add(\"pnlm-orientation-button-active\");\r\n    }\r\n    /**\r\n     * Escapes HTML string (to mitigate possible DOM XSS attacks).\r\n     * @private\r\n     * @param {string} s - String to escape\r\n     * @returns {string} Escaped string\r\n     */\r\n\r\n    function escapeHTML(s) {\r\n      if (!initialConfig.escapeHTML) return String(s).split(\"\\n\").join(\"<br>\");\r\n      return String(s)\r\n        .split(/&/g)\r\n        .join(\"&amp;\")\r\n        .split('\"')\r\n        .join(\"&quot;\")\r\n        .split(\"'\")\r\n        .join(\"&#39;\")\r\n        .split(\"<\")\r\n        .join(\"&lt;\")\r\n        .split(\">\")\r\n        .join(\"&gt;\")\r\n        .split(\"/\")\r\n        .join(\"&#x2f;\")\r\n        .split(\"\\n\")\r\n        .join(\"<br>\"); // Allow line breaks\r\n    }\r\n    /**\r\n     * Removes possibility of XSS attacks with URLs.\r\n     * The URL cannot be of protocol 'javascript'.\r\n     * @private\r\n     * @param {string} url - URL to sanitize\r\n     * @returns {string} Sanitized URL\r\n     */\r\n\r\n    function sanitizeURL(url) {\r\n      if (url.trim().toLowerCase().indexOf(\"javascript:\") === 0) {\r\n        return \"about:blank\";\r\n      }\r\n\r\n      return url;\r\n    }\r\n    /**\r\n     * Removes possibility of XSS atacks with URLs for CSS.\r\n     * The URL will be sanitized with `sanitizeURL()` and single quotes\r\n     * and double quotes escaped.\r\n     * @private\r\n     * @param {string} url - URL to sanitize\r\n     * @returns {string} Sanitized URL\r\n     */\r\n\r\n    function sanitizeURLForCss(url) {\r\n      return sanitizeURL(url).replace(/\"/g, \"%22\").replace(/'/g, \"%27\");\r\n    }\r\n    /**\r\n     * Checks whether or not a panorama is loaded.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {boolean} `true` if a panorama is loaded, else `false`\r\n     */\r\n\r\n    this.isLoaded = function () {\r\n      return Boolean(loaded);\r\n    };\r\n    /**\r\n     * Returns the pitch of the center of the view.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number} Pitch in degrees\r\n     */\r\n\r\n    this.getPitch = function () {\r\n      return config.pitch;\r\n    };\r\n    /**\r\n     * Sets the pitch of the center of the view.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} pitch - Pitch in degrees\r\n     * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\r\n     * @param {function} [callback] - Function to call when animation finishes\r\n     * @param {object} [callbackArgs] - Arguments to pass to callback function\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setPitch = function (pitch, animated, callback, callbackArgs) {\r\n      latestInteraction = Date.now();\r\n\r\n      if (Math.abs(pitch - config.pitch) <= eps) {\r\n        if (typeof callback === \"function\") callback(callbackArgs);\r\n        return this;\r\n      }\r\n\r\n      animated = animated === undefined$1 ? 1000 : Number(animated);\r\n\r\n      if (animated) {\r\n        animatedMove.pitch = {\r\n          startTime: Date.now(),\r\n          startPosition: config.pitch,\r\n          endPosition: pitch,\r\n          duration: animated,\r\n        };\r\n        if (typeof callback === \"function\")\r\n          setTimeout(function () {\r\n            callback(callbackArgs);\r\n          }, animated);\r\n      } else {\r\n        config.pitch = pitch;\r\n      }\r\n\r\n      animateInit();\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the minimum and maximum allowed pitches (in degrees).\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number[]} [minimum pitch, maximum pitch]\r\n     */\r\n\r\n    this.getPitchBounds = function () {\r\n      return [config.minPitch, config.maxPitch];\r\n    };\r\n    /**\r\n     * Set the minimum and maximum allowed pitches (in degrees).\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number[]} bounds - [minimum pitch, maximum pitch]\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setPitchBounds = function (bounds) {\r\n      config.minPitch = Math.max(-90, Math.min(bounds[0], 90));\r\n      config.maxPitch = Math.max(-90, Math.min(bounds[1], 90));\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the yaw of the center of the view.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number} Yaw in degrees\r\n     */\r\n\r\n    this.getYaw = function () {\r\n      return config.yaw;\r\n    };\r\n    /**\r\n     * Sets the yaw of the center of the view.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} yaw - Yaw in degrees [-180, 180]\r\n     * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\r\n     * @param {function} [callback] - Function to call when animation finishes\r\n     * @param {object} [callbackArgs] - Arguments to pass to callback function\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setYaw = function (yaw, animated, callback, callbackArgs) {\r\n      latestInteraction = Date.now();\r\n\r\n      if (Math.abs(yaw - config.yaw) <= eps) {\r\n        if (typeof callback === \"function\") callback(callbackArgs);\r\n        return this;\r\n      }\r\n\r\n      animated = animated === undefined$1 ? 1000 : Number(animated);\r\n      yaw = ((yaw + 180) % 360) - 180; // Keep in bounds\r\n\r\n      if (animated) {\r\n        // Animate in shortest direction\r\n        if (config.yaw - yaw > 180) yaw += 360;\r\n        else if (yaw - config.yaw > 180) yaw -= 360;\r\n        animatedMove.yaw = {\r\n          startTime: Date.now(),\r\n          startPosition: config.yaw,\r\n          endPosition: yaw,\r\n          duration: animated,\r\n        };\r\n        if (typeof callback === \"function\")\r\n          setTimeout(function () {\r\n            callback(callbackArgs);\r\n          }, animated);\r\n      } else {\r\n        config.yaw = yaw;\r\n      }\r\n\r\n      animateInit();\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the minimum and maximum allowed pitches (in degrees).\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number[]} [yaw pitch, maximum yaw]\r\n     */\r\n\r\n    this.getYawBounds = function () {\r\n      return [config.minYaw, config.maxYaw];\r\n    };\r\n    /**\r\n     * Set the minimum and maximum allowed yaws (in degrees [-180, 180]).\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number[]} bounds - [minimum yaw, maximum yaw]\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setYawBounds = function (bounds) {\r\n      config.minYaw = Math.max(-180, Math.min(bounds[0], 180));\r\n      config.maxYaw = Math.max(-180, Math.min(bounds[1], 180));\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the horizontal field of view.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number} Horizontal field of view in degrees\r\n     */\r\n\r\n    this.getHfov = function () {\r\n      return config.hfov;\r\n    };\r\n    /**\r\n     * Sets the horizontal field of view.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} hfov - Horizontal field of view in degrees\r\n     * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\r\n     * @param {function} [callback] - Function to call when animation finishes\r\n     * @param {object} [callbackArgs] - Arguments to pass to callback function\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setHfov = function (hfov, animated, callback, callbackArgs) {\r\n      latestInteraction = Date.now();\r\n\r\n      if (Math.abs(hfov - config.hfov) <= eps) {\r\n        if (typeof callback === \"function\") callback(callbackArgs);\r\n        return this;\r\n      }\r\n\r\n      animated = animated === undefined$1 ? 1000 : Number(animated);\r\n\r\n      if (animated) {\r\n        animatedMove.hfov = {\r\n          startTime: Date.now(),\r\n          startPosition: config.hfov,\r\n          endPosition: constrainHfov(hfov),\r\n          duration: animated,\r\n        };\r\n        if (typeof callback === \"function\")\r\n          setTimeout(function () {\r\n            callback(callbackArgs);\r\n          }, animated);\r\n      } else {\r\n        setHfov(hfov);\r\n      }\r\n\r\n      animateInit();\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the minimum and maximum allowed horizontal fields of view\r\n     * (in degrees).\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number[]} [minimum hfov, maximum hfov]\r\n     */\r\n\r\n    this.getHfovBounds = function () {\r\n      return [config.minHfov, config.maxHfov];\r\n    };\r\n    /**\r\n     * Set the minimum and maximum allowed horizontal fields of view (in degrees).\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number[]} bounds - [minimum hfov, maximum hfov]\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setHfovBounds = function (bounds) {\r\n      config.minHfov = Math.max(0, bounds[0]);\r\n      config.maxHfov = Math.max(0, bounds[1]);\r\n      return this;\r\n    };\r\n    /**\r\n     * Set a new view. Any parameters not specified remain the same.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} [pitch] - Target pitch\r\n     * @param {number} [yaw] - Target yaw\r\n     * @param {number} [hfov] - Target hfov\r\n     * @param {boolean|number} [animated=1000] - Animation duration in milliseconds or false for no animation\r\n     * @param {function} [callback] - Function to call when animation finishes\r\n     * @param {object} [callbackArgs] - Arguments to pass to callback function\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.lookAt = function (\r\n      pitch,\r\n      yaw,\r\n      hfov,\r\n      animated,\r\n      callback,\r\n      callbackArgs\r\n    ) {\r\n      animated = animated === undefined$1 ? 1000 : Number(animated);\r\n\r\n      if (pitch !== undefined$1 && Math.abs(pitch - config.pitch) > eps) {\r\n        this.setPitch(pitch, animated, callback, callbackArgs);\r\n        callback = undefined$1;\r\n      }\r\n\r\n      if (yaw !== undefined$1 && Math.abs(yaw - config.yaw) > eps) {\r\n        this.setYaw(yaw, animated, callback, callbackArgs);\r\n        callback = undefined$1;\r\n      }\r\n\r\n      if (hfov !== undefined$1 && Math.abs(hfov - config.hfov) > eps) {\r\n        this.setHfov(hfov, animated, callback, callbackArgs);\r\n        callback = undefined$1;\r\n      }\r\n\r\n      if (typeof callback === \"function\") callback(callbackArgs);\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the panorama's north offset.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number} North offset in degrees\r\n     */\r\n\r\n    this.getNorthOffset = function () {\r\n      return config.northOffset;\r\n    };\r\n    /**\r\n     * Sets the panorama's north offset.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} heading - North offset in degrees\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setNorthOffset = function (heading) {\r\n      config.northOffset = Math.min(360, Math.max(0, heading));\r\n      animateInit();\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the panorama's horizon roll.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number} Horizon roll in degrees\r\n     */\r\n\r\n    this.getHorizonRoll = function () {\r\n      return config.horizonRoll;\r\n    };\r\n    /**\r\n     * Sets the panorama's horizon roll.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} roll - Horizon roll in degrees [-90, 90]\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setHorizonRoll = function (roll) {\r\n      config.horizonRoll = Math.min(90, Math.max(-90, roll));\r\n      renderer.setPose(\r\n        (config.horizonPitch * Math.PI) / 180,\r\n        (config.horizonRoll * Math.PI) / 180\r\n      );\r\n      animateInit();\r\n      return this;\r\n    };\r\n    /**\r\n     * Returns the panorama's horizon pitch.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {number} Horizon pitch in degrees\r\n     */\r\n\r\n    this.getHorizonPitch = function () {\r\n      return config.horizonPitch;\r\n    };\r\n    /**\r\n     * Sets the panorama's horizon pitch.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} pitch - Horizon pitch in degrees [-90, 90]\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setHorizonPitch = function (pitch) {\r\n      config.horizonPitch = Math.min(90, Math.max(-90, pitch));\r\n      renderer.setPose(\r\n        (config.horizonPitch * Math.PI) / 180,\r\n        (config.horizonRoll * Math.PI) / 180\r\n      );\r\n      animateInit();\r\n      return this;\r\n    };\r\n    /**\r\n     * Start auto rotation.\r\n     *\r\n     * Before starting rotation, the viewer is panned to `pitch`.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {number} [speed] - Auto rotation speed / direction. If not specified, previous value is used.\r\n     * @param {number} [pitch] - The pitch to rotate at. If not specified, inital pitch is used.\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.startAutoRotate = function (speed, pitch) {\r\n      speed = speed || autoRotateSpeed || 1;\r\n      pitch = pitch === undefined$1 ? origPitch : pitch;\r\n      config.autoRotate = speed;\r\n\r\n      _this.lookAt(pitch, undefined$1, origHfov, 3000);\r\n\r\n      animateInit();\r\n      return this;\r\n    };\r\n    /**\r\n     * Stop auto rotation.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.stopAutoRotate = function () {\r\n      autoRotateSpeed = config.autoRotate ? config.autoRotate : autoRotateSpeed;\r\n      config.autoRotate = false;\r\n      config.autoRotateInactivityDelay = -1;\r\n      return this;\r\n    };\r\n\r\n    this.showCompass = function (value) {\r\n      config.compass = value;\r\n      renderInitCallback();\r\n      console.log(config);\r\n      return this;\r\n    };\r\n    /**\r\n     * Stops all movement.\r\n     * @memberof Viewer\r\n     * @instance\r\n     */\r\n\r\n    this.stopMovement = function () {\r\n      stopAnimation();\r\n      speed = {\r\n        yaw: 0,\r\n        pitch: 0,\r\n        hfov: 0,\r\n      };\r\n    };\r\n    /**\r\n     * Returns the panorama renderer.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {Renderer}\r\n     */\r\n\r\n    this.getRenderer = function () {\r\n      return renderer;\r\n    };\r\n    /**\r\n     * Sets update flag for dynamic content.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {boolean} bool - Whether or not viewer should update even when still\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.setUpdate = function (bool) {\r\n      update = bool === true;\r\n      if (renderer === undefined$1) onImageLoad();\r\n      else animateInit();\r\n      return this;\r\n    };\r\n\r\n    this.changeMouseCursor = function (event) {\r\n      return changeMouseCursor(event);\r\n    };\r\n\r\n    this.sceneLoadListener = function () {\r\n      return sceneLoadListener();\r\n    };\r\n    /**\r\n     * Calculate panorama pitch and yaw from location of mouse event.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {MouseEvent} event - Document mouse down event.\r\n     * @returns {number[]} [pitch, yaw]\r\n     */\r\n\r\n    this.mouseEventToCoords = function (event) {\r\n      return mouseEventToCoords(event);\r\n    };\r\n    /**\r\n     * Change scene being viewed.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {string} sceneId - Identifier of scene to switch to.\r\n     * @param {number} [pitch] - Pitch to use with new scene\r\n     * @param {number} [yaw] - Yaw to use with new scene\r\n     * @param {number} [hfov] - HFOV to use with new scene\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.loadScene = function (sceneId, pitch, yaw, hfov) {\r\n      if (loaded !== false) loadScene(sceneId, pitch, yaw, hfov);\r\n      return this;\r\n    };\r\n    /**\r\n     * Get ID of current scene.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {string} ID of current scene\r\n     */\r\n\r\n    this.getScene = function () {\r\n      return config.scene;\r\n    };\r\n    /**\r\n     * Get ID of all scenes.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns [Object] ID of all scenes\r\n     */\r\n\r\n    this.getAllScenes = function () {\r\n      var allScenes = [];\r\n      Object.keys(initialConfig.scenes).forEach(function (scene) {\r\n        allScenes.push(_defineProperty({}, scene, initialConfig.scenes[scene]));\r\n      });\r\n      return allScenes;\r\n    };\r\n    /**\r\n     * Add a new scene.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {string} sceneId - The ID of the new scene\r\n     * @param {string} config - The configuration of the new scene\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.addScene = function (sceneId, config) {\r\n      initialConfig.scenes[sceneId] = config;\r\n      return this;\r\n    };\r\n    /**\r\n     * Remove a scene.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {string} sceneId - The ID of the scene\r\n     * @returns {boolean} False if the scene is the current scene or if the scene doesn't exists, else true\r\n     */\r\n\r\n    this.removeScene = function (sceneId) {\r\n      if (\r\n        config.scene === sceneId ||\r\n        !initialConfig.scenes.hasOwnProperty(sceneId)\r\n      )\r\n        return false;\r\n      delete initialConfig.scenes[sceneId];\r\n      return true;\r\n    };\r\n    /**\r\n     * Toggle fullscreen.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.toggleFullscreen = function () {\r\n      toggleFullscreen();\r\n      return this;\r\n    };\r\n    /**\r\n     * Get configuration of current scene.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {Object} Configuration of current scene\r\n     */\r\n\r\n    this.getConfig = function () {\r\n      return config;\r\n    };\r\n    /**\r\n     * Get viewer's container element.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {HTMLElement} Container `div` element\r\n     */\r\n\r\n    this.getContainer = function () {\r\n      return container;\r\n    };\r\n    /**\r\n     * Add a new hot spot.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {Object} hs - The configuration for the hot spot\r\n     * @param {string} [sceneId] - Adds hot spot to specified scene if provided, else to current scene\r\n     * @returns {Viewer} `this`\r\n     * @throws Throws an error if the scene ID is provided but invalid\r\n     */\r\n\r\n    this.addHotSpot = function (hs, sceneId) {\r\n      if (sceneId === undefined$1 && config.scene === undefined$1) {\r\n        // Not a tour\r\n        config.hotSpots.push(hs);\r\n      } else {\r\n        // Tour\r\n        var id = sceneId !== undefined$1 ? sceneId : config.scene;\r\n\r\n        if (initialConfig.scenes.hasOwnProperty(id)) {\r\n          if (!initialConfig.scenes[id].hasOwnProperty(\"hotSpots\")) {\r\n            initialConfig.scenes[id].hotSpots = []; // Create hot spots array if needed\r\n\r\n            if (id === config.scene)\r\n              config.hotSpots = initialConfig.scenes[id].hotSpots; // Link to current config\r\n          }\r\n\r\n          initialConfig.scenes[id].hotSpots.push(hs); // Add hot spot to config\r\n        } else {\r\n          throw \"Invalid scene ID!\";\r\n        }\r\n      }\r\n\r\n      if (sceneId === undefined$1 || config.scene === sceneId) {\r\n        // Add to current scene\r\n        createHotSpot(hs);\r\n        if (loaded) renderHotSpot(hs);\r\n      }\r\n\r\n      return this;\r\n    };\r\n    /**\r\n     * Remove a hot spot.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {string} hotSpotId - The ID of the hot spot\r\n     * @param {string} [sceneId] - Removes hot spot from specified scene if provided, else from current scene\r\n     * @returns {boolean} True if deletion is successful, else false\r\n     */\r\n\r\n    this.removeHotSpot = function (hotSpotId, sceneId) {\r\n      if (sceneId === undefined$1 || config.scene === sceneId) {\r\n        if (!config.hotSpots) return false;\r\n\r\n        for (var i = 0; i < config.hotSpots.length; i++) {\r\n          if (\r\n            config.hotSpots[i].hasOwnProperty(\"id\") &&\r\n            config.hotSpots[i].id === hotSpotId\r\n          ) {\r\n            // Delete hot spot DOM elements\r\n            var current = config.hotSpots[i].div;\r\n\r\n            while (current.parentNode != renderContainer) {\r\n              current = current.parentNode;\r\n            }\r\n\r\n            renderContainer.removeChild(current);\r\n            delete config.hotSpots[i].div; // Remove hot spot from configuration\r\n\r\n            config.hotSpots.splice(i, 1);\r\n            return true;\r\n          }\r\n        }\r\n      } else {\r\n        if (initialConfig.scenes.hasOwnProperty(sceneId)) {\r\n          if (!initialConfig.scenes[sceneId].hasOwnProperty(\"hotSpots\"))\r\n            return false;\r\n\r\n          for (\r\n            var j = 0;\r\n            j < initialConfig.scenes[sceneId].hotSpots.length;\r\n            j++\r\n          ) {\r\n            if (\r\n              initialConfig.scenes[sceneId].hotSpots[j].hasOwnProperty(\"id\") &&\r\n              initialConfig.scenes[sceneId].hotSpots[j].id === hotSpotId\r\n            ) {\r\n              // Remove hot spot from configuration\r\n              initialConfig.scenes[sceneId].hotSpots.splice(j, 1);\r\n              return true;\r\n            }\r\n          }\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n    };\r\n    /**\r\n     * This method should be called if the viewer's container is resized.\r\n     * @memberof Viewer\r\n     * @instance\r\n     */\r\n\r\n    this.resize = function () {\r\n      if (renderer) onDocumentResize();\r\n    };\r\n    /**\r\n     * Check if a panorama is loaded.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {boolean} True if a panorama is loaded, else false\r\n     */\r\n\r\n    this.isLoaded = function () {\r\n      return loaded;\r\n    };\r\n    /**\r\n     * Check if device orientation control is supported.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {boolean} True if supported, else false\r\n     */\r\n\r\n    this.isOrientationSupported = function () {\r\n      return orientationSupport || false;\r\n    };\r\n    /**\r\n     * Stop using device orientation.\r\n     * @memberof Viewer\r\n     * @instance\r\n     */\r\n\r\n    this.stopOrientation = function () {\r\n      stopOrientation();\r\n    };\r\n    /**\r\n     * Start using device orientation (does nothing if not supported).\r\n     * @memberof Viewer\r\n     * @instance\r\n     */\r\n\r\n    this.startOrientation = function () {\r\n      if (orientationSupport) startOrientation();\r\n    };\r\n    /**\r\n     * Check if device orientation control is currently activated.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @returns {boolean} True if active, else false\r\n     */\r\n\r\n    this.isOrientationActive = function () {\r\n      return Boolean(orientation);\r\n    };\r\n    /**\r\n     * Subscribe listener to specified event.\r\n     * @memberof Viewer\r\n     * @instance\r\n     * @param {string} type - Type of event to subscribe to.\r\n     * @param {Function} listener - Listener function to subscribe to event.\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.on = function (type, listener) {\r\n      externalEventListeners[type] = externalEventListeners[type] || [];\r\n      externalEventListeners[type].push(listener);\r\n      return this;\r\n    };\r\n    /**\r\n     * Remove an event listener (or listeners).\r\n     * @memberof Viewer\r\n     * @param {string} [type] - Type of event to remove listeners from. If not specified, all listeners are removed.\r\n     * @param {Function} [listener] - Listener function to remove. If not specified, all listeners of specified type are removed.\r\n     * @returns {Viewer} `this`\r\n     */\r\n\r\n    this.off = function (type, listener) {\r\n      if (!type) {\r\n        // Remove all listeners if type isn't specified\r\n        externalEventListeners = {};\r\n        return this;\r\n      }\r\n\r\n      if (listener) {\r\n        var i = externalEventListeners[type].indexOf(listener);\r\n\r\n        if (i >= 0) {\r\n          // Remove listener if found\r\n          externalEventListeners[type].splice(i, 1);\r\n        }\r\n\r\n        if (externalEventListeners[type].length === 0) {\r\n          // Remove category if empty\r\n          delete externalEventListeners[type];\r\n        }\r\n      } else {\r\n        // Remove category of listeners if listener isn't specified\r\n        delete externalEventListeners[type];\r\n      }\r\n\r\n      return this;\r\n    };\r\n    /**\r\n     * Fire listeners attached to specified event.\r\n     * @private\r\n     * @param {string} [type] - Type of event to fire listeners for.\r\n     */\r\n\r\n    function fireEvent(type) {\r\n      if (type in externalEventListeners) {\r\n        // Reverse iteration is useful, if event listener is removed inside its definition\r\n        for (var i = externalEventListeners[type].length; i > 0; i--) {\r\n          externalEventListeners[type][\r\n            externalEventListeners[type].length - i\r\n          ].apply(null, [].slice.call(arguments, 1));\r\n        }\r\n      }\r\n    }\r\n    /**\r\n     * Destructor.\r\n     * @instance\r\n     * @memberof Viewer\r\n     */\r\n\r\n    this.destroy = function () {\r\n      destroyed = true;\r\n      clearTimeout(autoRotateStart);\r\n      if (renderer) renderer.destroy();\r\n\r\n      if (listenersAdded) {\r\n        document.removeEventListener(\"mousemove\", onDocumentMouseMove, false);\r\n        document.removeEventListener(\"mouseup\", onDocumentMouseUp, false);\r\n        container.removeEventListener(\r\n          \"mozfullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        container.removeEventListener(\r\n          \"webkitfullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        container.removeEventListener(\r\n          \"msfullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        container.removeEventListener(\r\n          \"fullscreenchange\",\r\n          onFullScreenChange,\r\n          false\r\n        );\r\n        window.removeEventListener(\"resize\", onDocumentResize, false);\r\n        window.removeEventListener(\r\n          \"orientationchange\",\r\n          onDocumentResize,\r\n          false\r\n        );\r\n        container.removeEventListener(\"keydown\", onDocumentKeyPress, false);\r\n        container.removeEventListener(\"keyup\", onDocumentKeyUp, false);\r\n        container.removeEventListener(\"blur\", clearKeys, false);\r\n        document.removeEventListener(\"mouseleave\", onDocumentMouseUp, false);\r\n      }\r\n\r\n      container.innerHTML = \"\";\r\n      container.classList.remove(\"pnlm-container\");\r\n    };\r\n  }\r\n\r\n  return {\r\n    viewer: function viewer(container, config) {\r\n      return new Viewer(container, config);\r\n    },\r\n  };\r\n})(\r\n  typeof window === \"undefined\" ? null : window,\r\n  typeof document === \"undefined\" ? null : document\r\n);\r\n\r\nvar myPromise = function myPromise(condition) {\r\n  for (\r\n    var _len = arguments.length,\r\n      args = new Array(_len > 1 ? _len - 1 : 0),\r\n      _key = 1;\r\n    _key < _len;\r\n    _key++\r\n  ) {\r\n    args[_key - 1] = arguments[_key];\r\n  }\r\n\r\n  var promise = new Promise(function (resolve, reject) {\r\n    if (condition) {\r\n      if (args !== []) {\r\n        resolve.apply(void 0, args);\r\n      } else {\r\n        reject(\"Argruments cannot be empty\");\r\n      }\r\n    } else {\r\n      reject(\"Something when wrong!!!\");\r\n    }\r\n  });\r\n  return promise;\r\n};\r\n\r\nvar configs = {\r\n  uiText: {\r\n    loadButtonLabel: \"Click to<br>Load<br>Panorama\",\r\n    loadingLabel: \"Loading...\",\r\n    bylineLabel: \"by %s\",\r\n    noPanoramaError: \"No panorama image was specified.\",\r\n    fileAccessError: \"The file %s could not be accessed.\",\r\n    malformedURLError: \"There is something wrong with the panorama URL.\",\r\n    iOS8WebGLError:\r\n      \"Due to iOS 8's broken WebGL implementation, only progressive encoded JPEGs work for your device (this panorama uses standard encoding).\",\r\n    genericWebGLError:\r\n      \"Your browser does not have the necessary WebGL support to display this panorama.\",\r\n    textureSizeError:\r\n      \"This panorama is too big for your device! It's %spx wide, but your device only supports images up to %spx wide. Try another device. (If you're the author, try scaling down the image.)\",\r\n    unknownError: \"Unknown error. Check developer console.\",\r\n  },\r\n  styles: {\r\n    width: \"100%\",\r\n    height: \"90%\",\r\n    background: \"#000000\",\r\n  },\r\n  equirectangularOptions: {\r\n    haov: 360,\r\n    vaov: 180,\r\n    vOffset: 0,\r\n    ignoreGPanoXMP: false,\r\n  },\r\n  panoramaConfigs: {\r\n    title: \"\",\r\n    author: \"\",\r\n    description: \"\",\r\n    autoLoad: false,\r\n    autoRotate: 0,\r\n    autoRotateInactivityDelay: 0,\r\n    autoRotateStopDelay: 0,\r\n    preview: \"\",\r\n    showZoomCtrl: true,\r\n    keyboardZoom: true,\r\n    mouseZoom: true,\r\n    doubleClickZoom: false,\r\n    draggable: true,\r\n    friction: 0.15,\r\n    disableKeyboardCtrl: false,\r\n    showFullscreenCtrl: true,\r\n    showControls: true,\r\n    touchPanSpeedCoeffFactor: 1,\r\n    yaw: 0,\r\n    pitch: 0,\r\n    maxPitch: 90,\r\n    minPitch: -90,\r\n    maxYaw: 180,\r\n    minYaw: -180,\r\n    hfov: 100,\r\n    minHfov: 50,\r\n    maxHfov: 120,\r\n    multiResMinHfov: false,\r\n    backgroundColor: [0, 0, 0],\r\n    avoidShowingBackground: false,\r\n    compass: false,\r\n    northOffset: 0,\r\n    hotSpots: [],\r\n    hotSpotDebug: false,\r\n  },\r\n};\r\n\r\nfunction styleInject(css, ref) {\r\n  if (ref === void 0) ref = {};\r\n  var insertAt = ref.insertAt;\r\n\r\n  if (!css || typeof document === \"undefined\") {\r\n    return;\r\n  }\r\n\r\n  var head = document.head || document.getElementsByTagName(\"head\")[0];\r\n  var style = document.createElement(\"style\");\r\n  style.type = \"text/css\";\r\n\r\n  if (insertAt === \"top\") {\r\n    if (head.firstChild) {\r\n      head.insertBefore(style, head.firstChild);\r\n    } else {\r\n      head.appendChild(style);\r\n    }\r\n  } else {\r\n    head.appendChild(style);\r\n  }\r\n\r\n  if (style.styleSheet) {\r\n    style.styleSheet.cssText = css;\r\n  } else {\r\n    style.appendChild(document.createTextNode(css));\r\n  }\r\n}\r\n\r\nvar css_248z = `/* Pannellum 2.4.1, https://github.com/mpetroff/pannellum */\\r\\n\\r\\n.pnlm-container {\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  overflow: hidden;\\r\\n  position: relative;\\r\\n  cursor: default;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  font-family: Helvetica, \\\"Nimbus Sans L\\\", \\\"Liberation Sans\\\", Arial, sans-serif;\\r\\n  background: #f4f4f4 url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2267%22%20height%3D%22100%22%20viewBox%3D%220%200%2067%20100%22%3E%0A%3Cpath%20stroke%3D%22%23ccc%22%20fill%3D%22none%22%20d%3D%22M33.5%2C50%2C0%2C63%2C33.5%2C75%2C67%2C63%2C33.5%2C50m-33.5-50%2C67%2C25m-0.5%2C0%2C0%2C75m-66.5-75%2C67-25m-33.5%2C75%2C0%2C25m0-100%2C0%2C50%22%2F%3E%0A%3C%2Fsvg%3E%0A') repeat;\\r\\n  -webkit-user-select: none;\\r\\n  -khtml-user-select: none;\\r\\n  -moz-user-select: none;\\r\\n  -o-user-select: none;\\r\\n  -ms-user-select: none;\\r\\n  user-select: none;\\r\\n  outline: 0;\\r\\n  line-height: 1.4;\\r\\n  contain: content;\\r\\n}\\r\\n\\r\\n.pnlm-container * {\\r\\n  box-sizing: content-box;\\r\\n  font-family: source sans pro, ui-sans-serif;\\r\\n}\\r\\n\\r\\n.pnlm-ui {\\r\\n  position: absolute;\\r\\n  width: 100%;\\r\\n  height: 100%;\\r\\n  z-index: 1;\\r\\n}\\r\\n\\r\\n.pnlm-custom {\\r\\n  cursor: url(\"data:image/x-icon;base64,AAACAAEAICAAAAAAAACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAUAAAAFAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQFBgYGBzc1ND4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAADwAAABEAAAAKAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAIAAAACAAAAAwAAAAIAAAABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0AAAAcAAAAJAAAABkAAAAMAAAABQAAAAMAAAABAAAAAwAAAAUAAAAHAAAACgAAAAsAAAANAAAACwAAAAkAAAAGAAAAAwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQAAAB8AAAAvAAAAKQAAAB8AAAASAAAADAAAAAcAAAALAAAAEwAAABoAAAAeAAAAIQAAACIAAAAgAAAAHQAAABYAAAAOAAAABgAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFNQTs9TUE7QAAAAFgAAACsAAAAzAAAAMwAAACcAAAAeAAAAGAAAAB8AAAArAAAANQAAADoAAAA8AAAAPQAAADsAAAA4AAAALwAAACMAAAATAAAACAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkI6Mz5COjM9TUE7RAAAAHgAAADEAAAA+AAAAOwAAADUAAAAzAAAAOSSA3/8kgN//JIDf/ySA3/8kgN//AAAATQAAAEsAAABGAAAAOwAAACgAAAAVAAAABwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkI6Mz5COjNBTUE7SU1BO1wAAAD4AAABHAAAARyGR5/8jhuX/I4Lg/ySA3v8kgN//JIDf/yWD4/8hkef/IZHn/wAAAFEAAABLAAAAPgAAACcAAAARAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkI6Mz5COjNFTUE7VU1BO2iGR5/8gj+T/IZHn/yGQ5/8gj+b/IYvk/yKI4v8jg+H/JYDf/yWB4P8kf93/IZHn/wAAAFMAAABNAAAAOgAAACAAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQjozPkI6M0JCOjNUcmOr/HJ3u/xye7v8cn+//HJ7u/x2b7P8dmOr/H5Tp/yGO5f8iieP/I4Lg/ySA4P8hkef/IZHn/wAAAFMAAABJAAAALgAAABQAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQjozRHqf2/xmm8f8YqfP/F6z0/xet9f8XrPX/GKnz/xql8f8boO//HJrr/x+U6f8hjOX/IoTh/yWA3v8jfdv/AAECYQAAAFEAAAA6AAAAHgAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARaZ1uQUsPb/EbT4/xC4+v8Pu/v/D7v7/w+6+/8Rt/r/ErL4/xWs9f8apfH/HJ7v/x6W6v8gjeX/IoXh/ySA3/8hkef/AAAAVAAAAEMAAAAnAAAACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAt1vj/EbP2/w68+/8Mvfz/Db79/w6+/f8Ovv3/Dr7+/w2+/v8Nvvz/D7r6/xOy9/8YqfT/G6Hv/x6W6v8hjeX/I4Th/yGR5/8AAABVAAAASQAAAC0AAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA+27fMNvv3/Dr79/w3B/f8Owfz/D8H8/w/B/f8Pwfz/DsD8/w2//f8Ovf3/DLz8/xG0+f8XqvT/G6Dv/x6V6f8hi+T/I4Hf/yGR5/8AAABNAAAAMQAAABUAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADbz6/w2//f8Pwfv/D8P9/w/F/f8Pxf3/Ecb9/xHG/f8Pw/z/D8L8/w7B/P8Nvfz/Db38/xK0+P8ZqPL/G53u/yCR6P8ihuL/IZHn/wAAAE4AAAA1AAAAGgAAAAUAAAACAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC3W+P8Nv/7/DsH8/xDF/P8Qx/v/Esn7/xLL+/8SzP3/Ecv9/xDI+/8Rxvz/D8P9/w/B/f8Ovf3/Dbz7/xSw9v8bpPD/Hpfq/yGM5P8hkef/AAAAUAAAAD0AAAAmAAAAEgAAAAoAAAAEAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAEs38/w/B/P8PxPz/EMj7/xLL+/8Tz/v/FNH6/xTR+v8U0Pr/Es77/xLK/P8Rx/z/FK7x/yB71v8ZkOP/ELn7/xip8/8dne7/IJDn/yGR5/8AAABSAAAASAAAADoAAAAqAAAAHQAAABEAAAAIAAAAAgAAAAAAAAAAAAAAAAAAAAASzfz/EMP9/xDH+/8RzPv/FND5/xXV+v8Z2fv/Gdr6/xfX+v8U0/r/E9H8/yCN4P8ihtv/I3vW/yVwz/8nYMj/FLD2/xyg7/8elOf/IZHn/wAAAFQAAABRAAAASwAAAEIAAAA2AAAAJwAAABUAAAAIAAAAAQAAAAAAAAAAAAAAABLN/P8Qxfv/Ecr7/xPP+/8V1fr/G9v6/x7h+P8j4vn/Hd/5/xjY+f8XrPH/HJ7r/x6T5P8hid3/In/Y/yVz0f8jf9v/I4vj/yKL4/8kkef/J5j0/iGR5/8AAABUAAAAUAAAAEoAAAA+AAAAKQAAABMAAAAEAAAAAAAAAAAAAAAALdb4/xDF/P8Sy/v/FNH6/xjY+v8d3/n/e+v5/6Hv+v9M5fn/HN75/w+5+v8VrvP/G6Ht/x2W5/8hjOL/Iozk/yyf7P9Cwfz/Qr37/0G8+/9Cuvv/Q7v7/0a69/5Du/r/AAAAUgAAAE0AAAA8AAAAIgAAAAsAAAAAAAAAAAAAAAAAAAAAEMP6/xLL+/8U0fr/GNj6/yHh+f+W7vr/zfb7/2bo+v8c3vr/EMv7/w2+/P8Tsvb/Iovk/yGL4/9Bxfv/QMH7/0DB+/9BwPv/Qb78/0K+/P9CvPv/Q737/0O7+v9Du/r/AAAAUwAAAEoAAAAuAAAAEwAAAAAAAAAAAAAAAAAAAAASzfz/Esv7/xTP+f8W1vr/HN36/zbk+v9a5/n/IOL4/xnZ+v8Y3vn/EdD6/xyb6v8hiuP/Psf7/z/F+v8/w/v/QML7/0HB+/9Awfv/QcD8/0G+/f9Bvvz/Qrz7/0O7+f9Du/r/AAAAUgAAADYAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAARxO7zE877/xTS+v8X1/r/Gtv6/xzc+v8a2vv/Ftb6/xPP+v8a4vn/IYrk/zzM/P88x/z/Psb6/z7F+v8/xPv/QML6/0DC+v9BwPv/QcD7/0G//P9Bvv3/Qr38/0O7+v8AAABUAAAAOAAAABwAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAQt9nfE8/7/y3W+P8V1fv/FdX6/xXU+v8U0Pr/Esv7/xyi7P8vr/D/Osv7/zzK/P88yPz/Pcj7/z7G+/8+xPr/PsT6/0DC+v9Bwvv/QMH7/0HA+/9Bv/z/RMP8/wAAAFMAAAA3AAAAGwAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAt1vj/EtD8/y3W+P8Tzvv/Es38/xHK+/8Rx/v/IYvk/zjO+/85zfv/Osv7/zrL+/87yfv/PMf7/z7H/P89xfr/QMX6/0DD+v9Bwvr/QcH7/0HB/P9Bv/n/AAEBVwAAADEAAAAVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALdb4/xLN/P8Szfz/EMPv8w2w3OEjjuX/NtD6/zbO/P85zfv/Ocz6/znL+v87yvv/Osn8/zzH/P8+xvv/PsX6/z/F+v9Aw/v/QMP6/0LH/P8AAABKAAAAJwAAAA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAASSX2+000fr/NdH8/zbQ+/84zfv/Oc36/znL+v86y/v/O8n7/zvI+/89x/z/Psb7/z7E+v8/xPv/Pbbi8AAAADQAAAAaAAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIYnH3DPT+/8z0vv/NdH8/zbP+/82z/v/OM36/znM+v86y/r/Osr7/zvJ+/88yPz/Pcf7/z7F+v9Du/r/AAAAIQAAAA0AAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAhicfcMNX5/zPT+/8z0/z/NNH8/zTR/P82z/z/N877/znN+v85y/r/Osv6/zvK+/87yfv/Pcf3/C3W+P8AAAARAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAv2vn/L9b7/zLV/P8z1Pz/NNL8/zXR/P820fz/Ns/8/zjO+/86zfv/Ocv6/znJ+f9Du/r/AAAADwAAAAYAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC3W+P8t1vj/Ltf8/zHW/P8z1Pv/M9T8/zPS/P810fv/NtD8/zbO+/84yvj/Q7v6/wAAAA0AAAAEAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEO7+v9Du/r/Ltj7/y/X+/8x1fz/M9T8/zTT+/800vr/NdX3+UO7+v8AAAAHAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABDu/r/LNn6/y/Y+/8w1fv/Q7v6/y3W+P8AAAAGAAAABAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/////////////////////z////8fwf//hwB//8AAP//AAB//4AAf/+AAD//AAA//wAAH/8AAB/+AAAf/gAAH/4AAB/+AAAH/gAAAf8AAAD/AAAAf4AAAH/AAAB/4AAAf/gAAH//wAB//8AAf//AAH//4AD//+AB///wA////A/8=\"), auto;\\r\\n}\\r\\n\\r\\n.pnlm-grab {\\r\\n  cursor: grab;\\r\\n  cursor: ${\"url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2226%22%20width%3D%2226%22%3E%0A%3Cpath%20stroke%3D%22%23000%22%20stroke-width%3D%221px%22%20fill%3D%22%23fff%22%20d%3D%22m15.3%2020.5s6.38-6.73%204.64-8.24-3.47%201.01-3.47%201.01%203.61-5.72%201.41-6.49c-2.2-0.769-3.33%204.36-3.33%204.36s0.873-5.76-1.06-5.76-1.58%205.39-1.58%205.39-0.574-4.59-2.18-4.12c-1.61%200.468-0.572%205.51-0.572%205.51s-1.58-4.89-2.93-3.79c-1.35%201.11%200.258%205.25%200.572%206.62%200.836%202.43%202.03%202.94%202.17%205.55%22%2F%3E%0A%3C%2Fsvg%3E%0A') 12 8, default\"}\\r\\n}\\r\\n\\r\\n.pnlm-grabbing {\\r\\n  cursor: grabbing;\\r\\n  cursor: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2226%22%20width%3D%2226%22%3E%0A%3Cpath%20stroke%3D%22%23000%22%20stroke-width%3D%221px%22%20fill%3D%22%23fff%22%20d%3D%22m15.3%2020.5s5.07-5.29%203.77-6.74c-1.31-1.45-2.53%200.14-2.53%200.14s2.74-3.29%200.535-4.06c-2.2-0.769-2.52%201.3-2.52%201.3s0.81-2.13-1.12-2.13-1.52%201.77-1.52%201.77-0.261-1.59-1.87-1.12c-1.61%200.468-0.874%202.17-0.874%202.17s-0.651-1.55-2-0.445c-1.35%201.11-0.68%202.25-0.365%203.62%200.836%202.43%202.03%202.94%202.17%205.55%22%2F%3E%0A%3C%2Fsvg%3E%0A') 12 8, default\\r\\n}\\r\\n\\r\\n.pnlm-sprite {\\r\\n  background-image: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2226%22%20height%3D%22208%22%3E%0A%3Ccircle%20fill-opacity%3D%22.78%22%20cy%3D%22117%22%20cx%3D%2213%22%20r%3D%2211%22%20fill%3D%22%23fff%22%2F%3E%0A%3Ccircle%20fill-opacity%3D%22.78%22%20cy%3D%22143%22%20cx%3D%2213%22%20r%3D%2211%22%20fill%3D%22%23fff%22%2F%3E%0A%3Ccircle%20cy%3D%22169%22%20cx%3D%2213%22%20r%3D%227%22%20fill%3D%22none%22%20stroke%3D%22%23000%22%20stroke-width%3D%222%22%2F%3E%0A%3Ccircle%20cy%3D%22195%22%20cx%3D%2213%22%20r%3D%227%22%20fill%3D%22none%22%20stroke%3D%22%23000%22%20stroke-width%3D%222%22%2F%3E%0A%3Ccircle%20cx%3D%2213%22%20cy%3D%22195%22%20r%3D%222.5%22%2F%3E%0A%3Cpath%20d%3D%22m5%2083v6h2v-4h4v-2zm10%200v2h4v4h2v-6zm-5%205v6h6v-6zm-5%205v6h6v-2h-4v-4zm14%200v4h-4v2h6v-6z%22%2F%3E%0A%3Cpath%20d%3D%22m13%20110a7%207%200%200%200%20-7%207%207%207%200%200%200%207%207%207%207%200%200%200%207%20-7%207%207%200%200%200%20-7%20-7zm-1%203h2v2h-2zm0%203h2v5h-2z%22%2F%3E%0A%3Cpath%20d%3D%22m5%2057v6h2v-4h4v-2zm10%200v2h4v4h2v-6zm-10%2010v6h6v-2h-4v-4zm14%200v4h-4v2h6v-6z%22%2F%3E%0A%3Cpath%20d%3D%22m17%2038v2h-8v-2z%22%2F%3E%0A%3Cpath%20d%3D%22m12%209v3h-3v2h3v3h2v-3h3v-2h-3v-3z%22%2F%3E%0A%3Cpath%20d%3D%22m13%20136-6.125%206.125h4.375v7.875h3.5v-7.875h4.375z%22%2F%3E%0A%3Cpath%20d%3D%22m10.428%20173.33v-5.77l5-2.89v5.77zm1-1.73%203-1.73-3.001-1.74z%22%2F%3E%0A%3C%2Fsvg%3E%0A')\\r\\n}\\r\\n\\r\\n.pnlm-container:-moz-full-screen {\\r\\n  height: 100% !important;\\r\\n  width: 100% !important;\\r\\n  position: static !important;\\r\\n}\\r\\n\\r\\n.pnlm-container:-webkit-full-screen {\\r\\n  height: 100% !important;\\r\\n  width: 100% !important;\\r\\n  position: static !important;\\r\\n}\\r\\n\\r\\n.pnlm-container:-ms-fullscreen {\\r\\n  height: 100% !important;\\r\\n  width: 100% !important;\\r\\n  position: static !important;\\r\\n}\\r\\n\\r\\n.pnlm-container:fullscreen {\\r\\n  height: 100% !important;\\r\\n  width: 100% !important;\\r\\n  position: static !important;\\r\\n}\\r\\n\\r\\n.pnlm-render-container {\\r\\n  cursor: inherit;\\r\\n\\r\\n  /* Fix display bug in Safari 7 */\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n}\\r\\n\\r\\n.pnlm-controls {\\r\\n  margin-top: 4px;\\r\\n  background-color: #fff;\\r\\n  border: 1px solid #999;\\r\\n  border-color: rgba(0, 0, 0, 0.4);\\r\\n  border-radius: 3px;\\r\\n  cursor: pointer;\\r\\n  z-index: 2;\\r\\n  /* Fix Safari fullscreen bug */\\r\\n  -webkit-transform: translateZ(9999px);\\r\\n  transform: translateZ(9999px);\\r\\n}\\r\\n\\r\\n.pnlm-control:hover {\\r\\n  background-color: #f8f8f8;\\r\\n}\\r\\n\\r\\n.pnlm-controls-container {\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  left: 4px;\\r\\n  z-index: 1;\\r\\n}\\r\\n\\r\\n.pnlm-zoom-controls {\\r\\n  width: 26px;\\r\\n  height: 52px;\\r\\n}\\r\\n\\r\\n.pnlm-zoom-in {\\r\\n  width: 100%;\\r\\n  height: 50%;\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  border-radius: 3px 3px 0 0;\\r\\n}\\r\\n\\r\\n.pnlm-zoom-out {\\r\\n  width: 100%;\\r\\n  height: 50%;\\r\\n  position: absolute;\\r\\n  bottom: 0;\\r\\n  background-position: 0 -26px;\\r\\n  border-top: 1px solid #ddd;\\r\\n  border-top-color: rgba(0, 0, 0, 0.10);\\r\\n  border-radius: 0 0 3px 3px;\\r\\n}\\r\\n\\r\\n.pnlm-fullscreen-toggle-button,\\r\\n.pnlm-orientation-button,\\r\\n.pnlm-hot-spot-debug-indicator {\\r\\n  width: 26px;\\r\\n  height: 26px;\\r\\n}\\r\\n\\r\\n.pnlm-hot-spot-debug-indicator {\\r\\n  position: absolute;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  width: 26px;\\r\\n  height: 26px;\\r\\n  margin: -13px 0 0 -13px;\\r\\n  background-color: rgba(255, 255, 255, 0.5);\\r\\n  border-radius: 13px;\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.pnlm-orientation-button-inactive {\\r\\n  background-position: 0 -156px;\\r\\n}\\r\\n\\r\\n.pnlm-orientation-button-active {\\r\\n  background-position: 0 -182px;\\r\\n}\\r\\n\\r\\n.pnlm-fullscreen-toggle-button-inactive {\\r\\n  background-position: 0 -52px;\\r\\n}\\r\\n\\r\\n.pnlm-fullscreen-toggle-button-active {\\r\\n  background-position: 0 -78px;\\r\\n}\\r\\n\\r\\n.pnlm-panorama-info {\\r\\n  position: absolute;\\r\\n  bottom: 4px;\\r\\n  background-color: rgba(0, 0, 0, 0.7);\\r\\n  border-radius: 0 3px 3px 0;\\r\\n  padding-right: 10px;\\r\\n  color: #fff;\\r\\n  text-align: left;\\r\\n  display: none;\\r\\n  z-index: 2;\\r\\n  /* Fix Safari fullscreen bug */\\r\\n  -webkit-transform: translateZ(9999px);\\r\\n  transform: translateZ(9999px);\\r\\n}\\r\\n\\r\\n.pnlm-title-box {\\r\\n  position: relative;\\r\\n  font-size: 20px;\\r\\n  display: table;\\r\\n  padding-left: 5px;\\r\\n  margin-bottom: 3px;\\r\\n}\\r\\n\\r\\n.pnlm-description-box {\\r\\n  position: relative;\\r\\n  font-size: 18px;\\r\\n  display: table;\\r\\n  padding-left: 5px;\\r\\n  margin-bottom: 3px;\\r\\n}\\r\\n\\r\\n.pnlm-author-box {\\r\\n  position: relative;\\r\\n  font-size: 12px;\\r\\n  display: table;\\r\\n  padding-left: 5px;\\r\\n}\\r\\n\\r\\n.pnlm-load-box {\\r\\n  position: absolute;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  width: 200px;\\r\\n  height: 150px;\\r\\n  margin: -75px 0 0 -100px;\\r\\n  background-color: rgba(0, 0, 0, 0.7);\\r\\n  border-radius: 3px;\\r\\n  text-align: center;\\r\\n  font-size: 20px;\\r\\n  display: none;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.pnlm-load-box p {\\r\\n  margin: 20px 0;\\r\\n}\\r\\n\\r\\n.pnlm-lbox {\\r\\n  position: absolute;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  width: 20px;\\r\\n  height: 20px;\\r\\n  margin: -10px 0 0 -10px;\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.pnlm-loading {\\r\\n  animation-duration: 1.5s;\\r\\n  -webkit-animation-duration: 1.5s;\\r\\n  animation-name: pnlm-mv;\\r\\n  -webkit-animation-name: pnlm-mv;\\r\\n  animation-iteration-count: infinite;\\r\\n  -webkit-animation-iteration-count: infinite;\\r\\n  animation-timing-function: linear;\\r\\n  -webkit-animation-timing-function: linear;\\r\\n  height: 10px;\\r\\n  width: 10px;\\r\\n  background-color: #fff;\\r\\n  position: relative;\\r\\n}\\r\\n\\r\\n@keyframes pnlm-mv {\\r\\n  from {\\r\\n    left: 0;\\r\\n    top: 0;\\r\\n  }\\r\\n\\r\\n  25% {\\r\\n    left: 10px;\\r\\n    top: 0;\\r\\n  }\\r\\n\\r\\n  50% {\\r\\n    left: 10px;\\r\\n    top: 10px;\\r\\n  }\\r\\n\\r\\n  75% {\\r\\n    left: 0;\\r\\n    top: 10px;\\r\\n  }\\r\\n\\r\\n  to {\\r\\n    left: 0;\\r\\n    top: 0;\\r\\n  }\\r\\n}\\r\\n\\r\\n@-webkit-keyframes pnlm-mv {\\r\\n  from {\\r\\n    left: 0;\\r\\n    top: 0;\\r\\n  }\\r\\n\\r\\n  25% {\\r\\n    left: 10px;\\r\\n    top: 0;\\r\\n  }\\r\\n\\r\\n  50% {\\r\\n    left: 10px;\\r\\n    top: 10px;\\r\\n  }\\r\\n\\r\\n  75% {\\r\\n    left: 0;\\r\\n    top: 10px;\\r\\n  }\\r\\n\\r\\n  to {\\r\\n    left: 0;\\r\\n    top: 0;\\r\\n  }\\r\\n}\\r\\n\\r\\n.pnlm-load-button {\\r\\n  position: absolute;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  width: 200px;\\r\\n  height: 100px;\\r\\n  margin: -50px 0 0 -100px;\\r\\n  background-color: rgba(0, 0, 0, .7);\\r\\n  border-radius: 3px;\\r\\n  text-align: center;\\r\\n  font-size: 20px;\\r\\n  display: table;\\r\\n  color: #fff;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.pnlm-load-button:hover {\\r\\n  background-color: rgba(0, 0, 0, .8);\\r\\n}\\r\\n\\r\\n.pnlm-load-button p {\\r\\n  display: table-cell;\\r\\n  vertical-align: middle;\\r\\n}\\r\\n\\r\\n.pnlm-info-box {\\r\\n  font-size: 15px;\\r\\n  position: absolute;\\r\\n  top: 50%;\\r\\n  left: 50%;\\r\\n  width: 200px;\\r\\n  height: 150px;\\r\\n  margin: -75px 0 0 -100px;\\r\\n  background-color: #000;\\r\\n  border-radius: 3px;\\r\\n  display: table;\\r\\n  text-align: center;\\r\\n  color: #fff;\\r\\n  table-layout: fixed;\\r\\n}\\r\\n\\r\\n.pnlm-info-box a,\\r\\n.pnlm-author-box a {\\r\\n  color: #fff;\\r\\n  word-wrap: break-word;\\r\\n  overflow-wrap: break-word;\\r\\n}\\r\\n\\r\\n.pnlm-info-box p {\\r\\n  display: table-cell;\\r\\n  vertical-align: middle;\\r\\n  padding: 0 5px 0 5px;\\r\\n}\\r\\n\\r\\n.pnlm-error-msg {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.pnlm-about-msg {\\r\\n  font-size: 11px;\\r\\n  line-height: 11px;\\r\\n  color: #fff;\\r\\n  padding: 5px 8px 5px 8px;\\r\\n  background: rgba(0, 0, 0, 0.7);\\r\\n  border-radius: 3px;\\r\\n  position: absolute;\\r\\n  top: 50px;\\r\\n  left: 50px;\\r\\n  display: none;\\r\\n  opacity: 0;\\r\\n  -moz-transition: opacity .3s ease-in-out;\\r\\n  -webkit-transition: opacity .3s ease-in-out;\\r\\n  -o-transition: opacity .3s ease-in-out;\\r\\n  -ms-transition: opacity .3s ease-in-out;\\r\\n  transition: opacity .3s ease-in-out;\\r\\n  z-index: 1;\\r\\n}\\r\\n\\r\\n.pnlm-about-msg a:link,\\r\\n.pnlm-about-msg a:visited {\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.pnlm-about-msg a:hover,\\r\\n.pnlm-about-msg a:active {\\r\\n  color: #eee;\\r\\n}\\r\\n\\r\\n.pnlm-hotspot-base {\\r\\n  position: absolute;\\r\\n  visibility: hidden;\\r\\n  cursor: default;\\r\\n  vertical-align: middle;\\r\\n  top: 0;\\r\\n  z-index: 1;\\r\\n}\\r\\n\\r\\n.pnlm-hotspot {\\r\\n  height: 26px;\\r\\n  width: 26px;\\r\\n  border-radius: 13px;\\r\\n}\\r\\n\\r\\n.pnlm-hotspot:hover {\\r\\n  background-color: rgba(255, 255, 255, 0.2);\\r\\n}\\r\\n\\r\\n.pnlm-hotspot.pnlm-info {\\r\\n  background-position: 0 -104px;\\r\\n}\\r\\n\\r\\n.pnlm-hotspot.pnlm-scene {\\r\\n  background-position: 0 -130px;\\r\\n}\\r\\n\\r\\ndiv.pnlm-tooltip span {\\r\\n  visibility: hidden;\\r\\n  position: absolute;\\r\\n  border-radius: 3px;\\r\\n  background-color: rgba(0, 0, 0, 0.7);\\r\\n  color: #fff;\\r\\n  text-align: center;\\r\\n  max-width: 200px;\\r\\n  padding: 5px 10px;\\r\\n  margin-left: -220px;\\r\\n  cursor: default;\\r\\n}\\r\\n\\r\\ndiv.pnlm-tooltip:hover span {\\r\\n  visibility: visible;\\r\\n}\\r\\n\\r\\ndiv.pnlm-tooltip:hover span:after {\\r\\n  content: '';\\r\\n  position: absolute;\\r\\n  width: 0;\\r\\n  height: 0;\\r\\n  border-width: 10px;\\r\\n  border-style: solid;\\r\\n  border-color: rgba(0, 0, 0, 0.7) transparent transparent transparent;\\r\\n  bottom: -20px;\\r\\n  left: -10px;\\r\\n  margin: 0 50%;\\r\\n}\\r\\n\\r\\n.pnlm-compass {\\r\\n  position: absolute;\\r\\n  width: 50px;\\r\\n  height: 50px;\\r\\n  right: 4px;\\r\\n  bottom: 4px;\\r\\n  border-radius: 25px;\\r\\n  background-image: url('data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20height%3D%2250%22%20width%3D%2250%22%3E%0A%3Cpath%20d%3D%22m24.5078%206-3.2578%2018h7.5l-3.25781-18h-0.984376zm-3.2578%2020%203.2578%2018h0.9844l3.2578-18h-7.5zm1.19531%200.9941h5.10938l-2.5547%2014.1075-2.5547-14.1075z%22%2F%3E%0A%3C%2Fsvg%3E%0A');\\r\\n  cursor: default;\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.pnlm-world {\\r\\n  position: absolute;\\r\\n  left: 50%;\\r\\n  top: 50%;\\r\\n}\\r\\n\\r\\n.pnlm-face {\\r\\n  position: absolute;\\r\\n  -webkit-transform-origin: 0 0 0;\\r\\n  transform-origin: 0 0 0;\\r\\n}\\r\\n\\r\\n.pnlm-dragfix,\\r\\n.pnlm-preview-img {\\r\\n  position: absolute;\\r\\n  height: 100%;\\r\\n  width: 100%;\\r\\n}\\r\\n\\r\\n.pnlm-preview-img {\\r\\n  background-size: cover;\\r\\n  background-position: center;\\r\\n}\\r\\n\\r\\n.pnlm-lbar {\\r\\n  width: 150px;\\r\\n  margin: 0 auto;\\r\\n  border: #fff 1px solid;\\r\\n  height: 6px;\\r\\n}\\r\\n\\r\\n.pnlm-lbar-fill {\\r\\n  background: #fff;\\r\\n  height: 100%;\\r\\n  width: 0;\\r\\n}\\r\\n\\r\\n.pnlm-lmsg {\\r\\n  font-size: 12px;\\r\\n}\\r\\n\\r\\n.pnlm-fade-img {\\r\\n  position: absolute;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n}\\r\\n\\r\\n.pnlm-pointer {\\r\\n  cursor: pointer;\\r\\n}\\r\\n`;\r\nstyleInject(css_248z);\r\n\r\nvar myPannellum = null;\r\n\r\nvar ReactPannellum = /*#__PURE__*/ (function (_React$Component) {\r\n  _inherits(ReactPannellum, _React$Component);\r\n\r\n  var _super = _createSuper(ReactPannellum);\r\n\r\n  function ReactPannellum() {\r\n    var _this;\r\n\r\n    _classCallCheck(this, ReactPannellum);\r\n\r\n    for (\r\n      var _len = arguments.length, args = new Array(_len), _key = 0;\r\n      _key < _len;\r\n      _key++\r\n    ) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    _this = _super.call.apply(_super, [this].concat(args));\r\n    _this.state = {\r\n      imageSource: \"\",\r\n      equirectangularOptions: {},\r\n      cubeMap: [],\r\n      multiRes: {},\r\n    };\r\n\r\n    _this.init = function () {\r\n      var _this$state = _this.state,\r\n        imageSource = _this$state.imageSource,\r\n        equirectangularOptions = _this$state.equirectangularOptions,\r\n        cubeMap = _this$state.cubeMap,\r\n        multiRes = _this$state.multiRes;\r\n      var _this$props = _this.props,\r\n        sceneId = _this$props.sceneId,\r\n        config = _this$props.config,\r\n        type = _this$props.type;\r\n      myPannellum = pannellum.viewer(_this.props.id, {\r\n        default: {\r\n          firstScene: sceneId,\r\n        },\r\n        scenes: _defineProperty(\r\n          {},\r\n          sceneId,\r\n          _objectSpread2(\r\n            _objectSpread2(\r\n              _objectSpread2(\r\n                _objectSpread2(\r\n                  _objectSpread2(\r\n                    _objectSpread2({}, configs.panoramaConfigs),\r\n                    configs.equirectangularOptions\r\n                  ),\r\n                  configs.uiText\r\n                ),\r\n                config\r\n              ),\r\n              {},\r\n              {\r\n                type: type,\r\n                imageSource: imageSource,\r\n              },\r\n              equirectangularOptions\r\n            ),\r\n            {},\r\n            {\r\n              cubeMap: cubeMap,\r\n              multiRes: multiRes,\r\n            }\r\n          )\r\n        ),\r\n      });\r\n\r\n      myPannellum &&\r\n        myPannellum.on(\"mousedown\", function (event) {\r\n          return _this.props.onMouseDown(event);\r\n        });\r\n\r\n      myPannellum &&\r\n        myPannellum.on(\"mouseup\", function (event) {\r\n          return _this.props.onMouseUp(event);\r\n        });\r\n\r\n      myPannellum &&\r\n        myPannellum.on(\"mousemove\", function (event) {\r\n          return _this.props.onMouseMove(event);\r\n        });\r\n\r\n      myPannellum &&\r\n        myPannellum.on(\"load\", function () {\r\n          return myPannellum.sceneLoadListener();\r\n        });\r\n\r\n      // _this.props.onPanoramaLoaded &&\r\n      //   myPannellum.on(\"load\", function () {\r\n      //     return _this.props.onPanoramaLoaded();\r\n      //   });\r\n    };\r\n\r\n    return _this;\r\n  }\r\n\r\n  _createClass(\r\n    ReactPannellum,\r\n    [\r\n      {\r\n        key: \"initPanalleum\",\r\n        value: function initPanalleum() {\r\n          var _this2 = this;\r\n\r\n          var _this$props2 = this.props,\r\n            imageSource = _this$props2.imageSource,\r\n            type = _this$props2.type,\r\n            cubeMap = _this$props2.cubeMap,\r\n            multiRes = _this$props2.multiRes,\r\n            equirectangularOptions = _this$props2.equirectangularOptions;\r\n\r\n          switch (type) {\r\n            case \"equirectangular\":\r\n              this.setState(\r\n                {\r\n                  imageSource: imageSource,\r\n                  equirectangularOptions: equirectangularOptions,\r\n                  cubeMap: [],\r\n                },\r\n                function () {\r\n                  return _this2.init();\r\n                }\r\n              );\r\n              break;\r\n\r\n            case \"cubemap\":\r\n              this.setState(\r\n                {\r\n                  cubeMap: cubeMap,\r\n                  imageSource: \"\",\r\n                },\r\n                function () {\r\n                  return _this2.init();\r\n                }\r\n              );\r\n              break;\r\n\r\n            case \"multires\":\r\n              this.setState(\r\n                {\r\n                  cubeMap: [],\r\n                  imageSource: \"\",\r\n                  multiRes: multiRes,\r\n                },\r\n                function () {\r\n                  return _this2.init();\r\n                }\r\n              );\r\n              break;\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"componentDidMount\",\r\n        value: function componentDidMount() {\r\n          this.initPanalleum();\r\n        },\r\n      },\r\n      {\r\n        key: \"componentWillUnmount\",\r\n        value: function componentWillUnmount() {\r\n          myPannellum &&\r\n            this.props.onPanoramaLoaded &&\r\n            myPannellum.off(\"load\", this.props.onPanoramaLoaded);\r\n        },\r\n      },\r\n      {\r\n        key: \"render\",\r\n        value: function render() {\r\n          var _this$props3 = this.props,\r\n            style = _this$props3.style,\r\n            className = _this$props3.className,\r\n            id = _this$props3.id,\r\n            children = _this$props3.children;\r\n          return /*#__PURE__*/ React__default[\"default\"].createElement(\"div\", {\r\n            id: id,\r\n            style: style,\r\n            className: className,\r\n            children: children,\r\n          });\r\n        },\r\n      },\r\n    ],\r\n    [\r\n      {\r\n        key: \"isLoaded\",\r\n        value: function isLoaded() {\r\n          return myPannellum && myPannellum.isLoaded();\r\n        },\r\n      },\r\n      {\r\n        key: \"getPitch\",\r\n        value: function getPitch() {\r\n          return myPannellum && myPannellum.getPitch();\r\n        },\r\n      },\r\n      {\r\n        key: \"setPitch\",\r\n        value: function setPitch(pitch) {\r\n          var animated =\r\n            arguments.length > 1 && arguments[1] !== undefined\r\n              ? arguments[1]\r\n              : 1000;\r\n          var callback = arguments.length > 2 ? arguments[2] : undefined;\r\n          var callbackArgs = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n          if (myPannellum) {\r\n            myPannellum.setPitch(pitch, animated, callback, callbackArgs);\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"getPitchBounds\",\r\n        value: function getPitchBounds() {\r\n          return myPannellum && myPannellum.getPitchBounds();\r\n        },\r\n      },\r\n      {\r\n        key: \"setPitchBounds\",\r\n        value: function setPitchBounds(bounds) {\r\n          if (myPannellum) {\r\n            myPannellum.setPitchBounds(bounds);\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"getYaw\",\r\n        value: function getYaw() {\r\n          return myPannellum && myPannellum.getYaw();\r\n        },\r\n      },\r\n      {\r\n        key: \"setYaw\",\r\n        value: function setYaw(yaw) {\r\n          var animated =\r\n            arguments.length > 1 && arguments[1] !== undefined\r\n              ? arguments[1]\r\n              : 1000;\r\n          var callback = arguments.length > 2 ? arguments[2] : undefined;\r\n          var callbackArgs = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n          if (myPannellum) {\r\n            myPannellum.setYaw(yaw, animated, callback, callbackArgs);\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"getYawBounds\",\r\n        value: function getYawBounds() {\r\n          return myPannellum && myPannellum.getYawBounds();\r\n        },\r\n      },\r\n      {\r\n        key: \"setYawBounds\",\r\n        value: function setYawBounds(bounds) {\r\n          myPromise(myPannellum, {\r\n            bounds: bounds,\r\n          })\r\n            .then(function (_ref) {\r\n              var bounds = _ref.bounds;\r\n              myPannellum.setYawBounds(bounds);\r\n            })\r\n            [\"catch\"](function (err) {\r\n              console.log(err);\r\n            });\r\n        },\r\n      },\r\n      {\r\n        key: \"getHfov\",\r\n        value: function getHfov() {\r\n          return myPannellum && myPannellum.getHfov();\r\n        },\r\n      },\r\n      {\r\n        key: \"setHfov\",\r\n        value: function setHfov(hfov) {\r\n          var animated =\r\n            arguments.length > 1 && arguments[1] !== undefined\r\n              ? arguments[1]\r\n              : 1000;\r\n          var callback = arguments.length > 2 ? arguments[2] : undefined;\r\n          var callbackArgs = arguments.length > 3 ? arguments[3] : undefined;\r\n\r\n          if (myPannellum) {\r\n            myPannellum.setHfov(hfov, animated, callback, callbackArgs);\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"getHfovBounds\",\r\n        value: function getHfovBounds() {\r\n          return myPannellum && myPannellum.getHfovBounds();\r\n        },\r\n      },\r\n      {\r\n        key: \"setHfovBounds\",\r\n        value: function setHfovBounds(bounds) {\r\n          myPromise(myPannellum, {\r\n            bounds: bounds,\r\n          })\r\n            .then(function (_ref2) {\r\n              var bounds = _ref2.bounds;\r\n              myPannellum.setHfovBounds(bounds);\r\n            })\r\n            [\"catch\"](function (err) {\r\n              console.log(err);\r\n            });\r\n        },\r\n      },\r\n      {\r\n        key: \"lookAt\",\r\n        value: function lookAt(pitch, yaw, hfov) {\r\n          var animated =\r\n            arguments.length > 3 && arguments[3] !== undefined\r\n              ? arguments[3]\r\n              : 1000;\r\n          var callback = arguments.length > 4 ? arguments[4] : undefined;\r\n          var callbackArgs = arguments.length > 5 ? arguments[5] : undefined;\r\n\r\n          if (myPannellum) {\r\n            myPannellum.lookAt(\r\n              pitch,\r\n              yaw,\r\n              hfov,\r\n              animated,\r\n              callback,\r\n              callbackArgs\r\n            );\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"getNorthOffset\",\r\n        value: function getNorthOffset() {\r\n          return myPannellum && myPannellum.getNorthOffset();\r\n        },\r\n      },\r\n      {\r\n        key: \"setNorthOffset\",\r\n        value: function setNorthOffset(heading) {\r\n          myPromise(myPannellum, {\r\n            heading: heading,\r\n          })\r\n            .then(function (_ref3) {\r\n              var heading = _ref3.heading;\r\n              myPannellum.setNorthOffset(heading);\r\n            })\r\n            [\"catch\"](function (err) {\r\n              console.log(err);\r\n            });\r\n        },\r\n      },\r\n      {\r\n        key: \"getHorizonRoll\",\r\n        value: function getHorizonRoll() {\r\n          return myPannellum && myPannellum.getHorizonRoll();\r\n        },\r\n      },\r\n      {\r\n        key: \"setHorizonRoll\",\r\n        value: function setHorizonRoll(roll) {\r\n          myPromise(myPannellum, {\r\n            roll: roll,\r\n          })\r\n            .then(function (_ref4) {\r\n              var roll = _ref4.roll;\r\n              myPannellum.setHorizonRoll(roll);\r\n            })\r\n            [\"catch\"](function (err) {\r\n              console.log(err);\r\n            });\r\n        },\r\n      },\r\n      {\r\n        key: \"getHorizonPitch\",\r\n        value: function getHorizonPitch() {\r\n          return myPannellum && myPannellum.getHorizonPitch();\r\n        },\r\n      },\r\n      {\r\n        key: \"setHorizonPitch\",\r\n        value: function setHorizonPitch(pitch) {\r\n          myPromise(myPannellum, {\r\n            pitch: pitch,\r\n          })\r\n            .then(function (_ref5) {\r\n              var pitch = _ref5.pitch;\r\n              myPannellum.setHorizonPitch(pitch);\r\n            })\r\n            [\"catch\"](function (err) {\r\n              console.log(err);\r\n            });\r\n        },\r\n      },\r\n      {\r\n        key: \"startAutoRotate\",\r\n        value: function startAutoRotate(speed, pitch) {\r\n          myPromise(myPannellum, {\r\n            pitch: pitch,\r\n          })\r\n            .then(function (_ref6) {\r\n              var pitch = _ref6.pitch;\r\n              myPannellum.startAutoRotate(speed, pitch);\r\n            })\r\n            [\"catch\"](function (err) {\r\n              console.log(err);\r\n            });\r\n        },\r\n      },\r\n      {\r\n        key: \"stopAutoRotate\",\r\n        value: function stopAutoRotate() {\r\n          if (myPannellum) {\r\n            myPannellum.stopAutoRotate();\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"showCompass\",\r\n        value: function showCompass(value) {\r\n          myPromise(myPannellum, {})\r\n            .then(function () {\r\n              myPannellum.showCompass(value);\r\n            })\r\n            [\"catch\"](function (err) {\r\n              console.log(err);\r\n            });\r\n        },\r\n      },\r\n      {\r\n        key: \"changeMouseCursor\",\r\n        value: function changeMouseCursor(event) {\r\n          return myPannellum && myPannellum.changeMouseCursor(event);\r\n        },\r\n      },\r\n      {\r\n        key: \"mouseEventToCoords\",\r\n        value: function mouseEventToCoords(event) {\r\n          return myPannellum && myPannellum.mouseEventToCoords(event);\r\n        },\r\n      },\r\n      {\r\n        key: \"addScene\",\r\n        value: function addScene(sceneId, config, callback) {\r\n          if (sceneId && sceneId !== \"\" && config && config !== {}) {\r\n            myPromise(myPannellum, {\r\n              sceneId: sceneId,\r\n              config: config,\r\n              callback: callback,\r\n            })\r\n              .then(function (_ref7) {\r\n                var sceneId = _ref7.sceneId,\r\n                  config = _ref7.config,\r\n                  callback = _ref7.callback;\r\n                myPannellum.addScene(sceneId, config);\r\n                callback && callback();\r\n              })\r\n              [\"catch\"](function (err) {\r\n                console.log(err);\r\n              });\r\n          } else {\r\n            console.log(\r\n              \"sceneId cannot be empty and config.imageSource cannot be empty!!\"\r\n            );\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"getCurrentScene\",\r\n        value: function getCurrentScene() {\r\n          return myPannellum && myPannellum.getScene();\r\n        },\r\n      },\r\n      {\r\n        key: \"getAllScenes\",\r\n        value: function getAllScenes() {\r\n          return myPannellum && myPannellum.getAllScenes();\r\n        },\r\n      },\r\n      {\r\n        key: \"removeScene\",\r\n        value: function removeScene(sceneId, callback) {\r\n          if (sceneId && sceneId !== \"\") {\r\n            myPromise(myPannellum, {\r\n              sceneId: sceneId,\r\n            })\r\n              .then(function (_ref8) {\r\n                var sceneId = _ref8.sceneId;\r\n                myPannellum.removeScene(sceneId);\r\n                callback && callback();\r\n              })\r\n              [\"catch\"](function (err) {\r\n                console.log(err);\r\n              });\r\n          } else {\r\n            console.log(\"sceneId cannot be empty\");\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"loadScene\",\r\n        value: function loadScene(\r\n          sceneId,\r\n          targetPitch,\r\n          targetYaw,\r\n          targetHfov,\r\n          fadeDone\r\n        ) {\r\n          if (myPannellum && sceneId && sceneId !== \"\") {\r\n            myPannellum.loadScene(\r\n              sceneId,\r\n              targetPitch,\r\n              targetYaw,\r\n              targetHfov,\r\n              fadeDone\r\n            );\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"toggleFullscreen\",\r\n        value: function toggleFullscreen() {\r\n          return myPannellum && myPannellum.toggleFullscreen();\r\n        },\r\n      },\r\n      {\r\n        key: \"getConfig\",\r\n        value: function getConfig() {\r\n          return myPannellum && myPannellum.getConfig();\r\n        },\r\n      },\r\n      {\r\n        key: \"getContainer\",\r\n        value: function getContainer() {\r\n          return myPannellum && myPannellum.getContainer();\r\n        },\r\n      },\r\n      {\r\n        key: \"addHotSpot\",\r\n        value: function addHotSpot(hotspot, sceneId) {\r\n          if (hotspot !== {}) {\r\n            myPromise(myPannellum, {\r\n              hotspot: hotspot,\r\n              sceneId: sceneId,\r\n            })\r\n              .then(function (_ref9) {\r\n                var hotspot = _ref9.hotspot,\r\n                  sceneId = _ref9.sceneId;\r\n                myPannellum.addHotSpot(hotspot, sceneId);\r\n              })\r\n              [\"catch\"](function (err) {\r\n                console.log(err);\r\n              });\r\n          } else {\r\n            console.log(\r\n              \"hotspot cannot be empty, please check hotspot elements needed in document: config props `hotSpots`.\"\r\n            );\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"removeHotSpot\",\r\n        value: function removeHotSpot(hotSpotId, sceneId) {\r\n          if (hotSpotId !== \"\") {\r\n            myPromise(myPannellum, {\r\n              hotSpotId: hotSpotId,\r\n              sceneId: sceneId,\r\n            })\r\n              .then(function (_ref10) {\r\n                var hotSpotId = _ref10.hotSpotId,\r\n                  sceneId = _ref10.sceneId;\r\n                myPannellum.removeHotSpot(hotSpotId, sceneId);\r\n              })\r\n              [\"catch\"](function (err) {\r\n                console.log(err);\r\n              });\r\n          } else {\r\n            console.log(\"hotspotId cannot be empty!!\");\r\n          }\r\n        },\r\n      },\r\n      {\r\n        key: \"destroy\",\r\n        value: function destroy() {\r\n          return myPannellum && myPannellum.destroy();\r\n        },\r\n      },\r\n      {\r\n        key: \"stopMovement\",\r\n        value: function stopMovement() {\r\n          return myPannellum && myPannellum.stopMovement();\r\n        },\r\n      },\r\n      {\r\n        key: \"resize\",\r\n        value: function resize() {\r\n          return myPannellum && myPannellum.resize();\r\n        },\r\n      },\r\n      {\r\n        key: \"isOrientationSupported\",\r\n        value: function isOrientationSupported() {\r\n          return myPannellum && myPannellum.isOrientationSupported();\r\n        },\r\n      },\r\n      {\r\n        key: \"stopOrientation\",\r\n        value: function stopOrientation() {\r\n          return myPannellum && myPannellum.stopOrientation();\r\n        },\r\n      },\r\n      {\r\n        key: \"startOrientation\",\r\n        value: function startOrientation() {\r\n          return myPannellum && myPannellum.startOrientation();\r\n        },\r\n      },\r\n      {\r\n        key: \"isOrientationActive\",\r\n        value: function isOrientationActive() {\r\n          return myPannellum && myPannellum.isOrientationActive();\r\n        },\r\n      },\r\n      {\r\n        key: \"getViewer\",\r\n        value: function getViewer() {\r\n          return myPannellum;\r\n        },\r\n      },\r\n    ]\r\n  );\r\n\r\n  return ReactPannellum;\r\n})(React__default[\"default\"].Component);\r\n\r\nReactPannellum.propTypes = {\r\n  id: PropTypes__default[\"default\"].string.isRequired,\r\n  sceneId: PropTypes__default[\"default\"].string.isRequired,\r\n  children: PropTypes__default[\"default\"].any,\r\n  type: PropTypes__default[\"default\"].string,\r\n  imageSource: PropTypes__default[\"default\"].string,\r\n  equirectangularOptions: PropTypes__default[\"default\"].shape({}),\r\n  cubeMap: PropTypes__default[\"default\"].arrayOf(\r\n    PropTypes__default[\"default\"].string\r\n  ),\r\n  multiRes: PropTypes__default[\"default\"].shape({\r\n    basePath: PropTypes__default[\"default\"].string,\r\n    path: PropTypes__default[\"default\"].string,\r\n    fallbackPath: PropTypes__default[\"default\"].string,\r\n    extension: PropTypes__default[\"default\"].string,\r\n    tileResolution: PropTypes__default[\"default\"].number,\r\n    maxLevel: PropTypes__default[\"default\"].number,\r\n    cubeResolution: PropTypes__default[\"default\"].number,\r\n  }),\r\n  config: PropTypes__default[\"default\"].shape({}),\r\n  className: PropTypes__default[\"default\"].string,\r\n  style: PropTypes__default[\"default\"].shape({}),\r\n  onPanoramaLoaded: PropTypes__default[\"default\"].func,\r\n  onMouseDown: PropTypes__default[\"default\"].func,\r\n  onMouseUp: PropTypes__default[\"default\"].func,\r\n  onMouseMove: PropTypes__default[\"default\"].func,\r\n};\r\nReactPannellum.defaultProps = {\r\n  type: \"equirectangular\",\r\n  imageSource: \"\",\r\n  equirectangularOptions: {},\r\n  cubeMap: [],\r\n  multiRes: {},\r\n  className: \"\",\r\n  style: configs.styles,\r\n  config: {},\r\n  onMouseDown: () => {},\r\n  onMouseUp: () => {},\r\n  onMouseMove: () => {},\r\n};\r\n\r\nexport const addScene = ReactPannellum.addScene;\r\nexport const getCurrentScene = ReactPannellum.getCurrentScene;\r\nexport const getAllScenes = ReactPannellum.getAllScenes;\r\nexport const removeScene = ReactPannellum.removeScene;\r\nexport const loadScene = ReactPannellum.loadScene;\r\nexport const isLoaded = ReactPannellum.isLoaded;\r\nexport const getPitch = ReactPannellum.getPitch;\r\nexport const setPitch = ReactPannellum.setPitch;\r\nexport const getPitchBounds = ReactPannellum.getPitchBounds;\r\nexport const setPitchBounds = ReactPannellum.setPitchBounds;\r\nexport const getYaw = ReactPannellum.getYaw;\r\nexport const setYaw = ReactPannellum.setYaw;\r\nexport const getYawBounds = ReactPannellum.getYawBounds;\r\nexport const setYawBounds = ReactPannellum.setYawBounds;\r\nexport const getHfov = ReactPannellum.getHfov;\r\nexport const setHfov = ReactPannellum.setHfov;\r\nexport const getHfovBounds = ReactPannellum.getHfovBounds;\r\nexport const setHfovBounds = ReactPannellum.setHfovBounds;\r\nexport const lookAt = ReactPannellum.lookAt;\r\nexport const getNorthOffset = ReactPannellum.getNorthOffset;\r\nexport const setNorthOffset = ReactPannellum.setNorthOffset;\r\nexport const getHorizonRoll = ReactPannellum.getHorizonRoll;\r\nexport const setHorizonRoll = ReactPannellum.setHorizonRoll;\r\nexport const getHorizonPitch = ReactPannellum.getHorizonPitch;\r\nexport const setHorizonPitch = ReactPannellum.setHorizonPitch;\r\nexport const startAutoRotate = ReactPannellum.startAutoRotate;\r\nexport const stopAutoRotate = ReactPannellum.stopAutoRotate;\r\nexport const mouseEventToCoords = ReactPannellum.mouseEventToCoords;\r\nexport const changeMouseCursor = ReactPannellum.changeMouseCursor;\r\nexport const showCompass = ReactPannellum.showCompass;\r\nexport const toggleFullscreen = ReactPannellum.toggleFullscreen;\r\nexport const getConfig = ReactPannellum.getConfig;\r\nexport const getContainer = ReactPannellum.getContainer;\r\nexport const addHotSpot = ReactPannellum.addHotSpot;\r\nexport const removeHotSpot = ReactPannellum.removeHotSpot;\r\nexport const destroy = ReactPannellum.destroy;\r\nexport const stopMovement = ReactPannellum.stopMovement;\r\nexport const resize = ReactPannellum.resize;\r\nexport const isOrientationSupported = ReactPannellum.isOrientationSupported;\r\nexport const stopOrientation = ReactPannellum.stopOrientation;\r\nexport const startOrientation = ReactPannellum.startOrientation;\r\nexport const isOrientationActive = ReactPannellum.isOrientationActive;\r\nexport const getViewer = ReactPannellum.getViewer;\r\nexport default ReactPannellum;\r\n\r\n// exports.addHotSpot = addHotSpot;\r\n// exports.addScene = addScene;\r\n// exports.default = ReactPannellum;\r\n// exports.destroy = destroy;\r\n// exports.getAllScenes = getAllScenes;\r\n// exports.getConfig = getConfig;\r\n// exports.getContainer = getContainer;\r\n// exports.getCurrentScene = getCurrentScene;\r\n// exports.getHfov = getHfov;\r\n// exports.getHfovBounds = getHfovBounds;\r\n// exports.getHorizonPitch = getHorizonPitch;\r\n// exports.getHorizonRoll = getHorizonRoll;\r\n// exports.getNorthOffset = getNorthOffset;\r\n// exports.getPitch = getPitch;\r\n// exports.getPitchBounds = getPitchBounds;\r\n// exports.getViewer = getViewer;\r\n// exports.getYaw = getYaw;\r\n// exports.getYawBounds = getYawBounds;\r\n// exports.isLoaded = isLoaded;\r\n// exports.isOrientationActive = isOrientationActive;\r\n// exports.isOrientationSupported = isOrientationSupported;\r\n// exports.loadScene = loadScene;\r\n// exports.lookAt = lookAt;\r\n// exports.mouseEventToCoords = mouseEventToCoords;\r\n// exports.changeMouseCursor = changeMouseCursor;\r\n// exports.removeHotSpot = removeHotSpot;\r\n// exports.removeScene = removeScene;\r\n// exports.resize = resize;\r\n// exports.setHfov = setHfov;\r\n// exports.setHfovBounds = setHfovBounds;\r\n// exports.setHorizonPitch = setHorizonPitch;\r\n// exports.setHorizonRoll = setHorizonRoll;\r\n// exports.setNorthOffset = setNorthOffset;\r\n// exports.setPitch = setPitch;\r\n// exports.setPitchBounds = setPitchBounds;\r\n// exports.setYaw = setYaw;\r\n// exports.setYawBounds = setYawBounds;\r\n// exports.startAutoRotate = startAutoRotate;\r\n// exports.showCompass = showCompass;\r\n// exports.startOrientation = startOrientation;\r\n// exports.stopAutoRotate = stopAutoRotate;\r\n// exports.stopMovement = stopMovement;\r\n// exports.stopOrientation = stopOrientation;\r\n// exports.toggleFullscreen = toggleFullscreen;\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\editSceneValidation.tsx",["183","184","185"],"import { useEffect, useState } from \"react\";\r\n// import { getCurrentScene } from \"../../libs/react-pannellum\";\r\n\r\nconst PostContactForm = async (\r\n  values: any,\r\n  successCallback: any,\r\n  errorCallback: any\r\n) => {\r\n  // do stuff\r\n  // if successful\r\n  if (true) successCallback();\r\n  else errorCallback();\r\n};\r\n\r\nconst initialFormValues = {\r\n  sceneID: \"\",\r\n  imageSource: \"\",\r\n  sceneName: \"\",\r\n  author: \"\",\r\n  formSubmitted: false,\r\n  success: false,\r\n};\r\n\r\nexport const useFormControls = (props) => {\r\n  const [values, setValues] = useState(initialFormValues);\r\n  const [errors, setErrors] = useState({} as any);\r\n\r\n  useEffect(() => {\r\n    setValues(initialFormValues);\r\n    setErrors({});\r\n  }, [props.open]);\r\n\r\n  useEffect(() => {\r\n    setErrors({});\r\n  }, [props.sceneID]);\r\n\r\n  const validate: any = (fieldValues = values) => {\r\n    let temp: any = { ...errors };\r\n\r\n    if (\"sceneID\" in fieldValues)\r\n      temp.sceneID = fieldValues.sceneID ? \"\" : \"This field is required.\";\r\n\r\n    if (\"imageSource\" in fieldValues) {\r\n      temp.imageSource = fieldValues.imageSource\r\n        ? \"\"\r\n        : \"This field is required.\";\r\n      if (fieldValues.imageSource) {\r\n        temp.imageSource =\r\n          /(http[s]*:\\/\\/)([a-z\\-_0-9\\/.]+)\\.([a-z.]{2,3})\\/([a-z0-9\\-_\\/._~:?#\\[\\]@!$&'()*+,;=%]*)([a-z0-9]+\\.)(jpg|jpeg|png)/i.test(\r\n            fieldValues.imageSource\r\n          )\r\n            ? \"\"\r\n            : \"Image Link is not valid\";\r\n      }\r\n    }\r\n\r\n    if (\"sceneName\" in fieldValues)\r\n      temp.sceneName = fieldValues.sceneName ? \"\" : \"This field is required.\";\r\n\r\n    if (\"author\" in fieldValues)\r\n      temp.author = fieldValues.author ? \"\" : \"This field is required.\";\r\n\r\n    setErrors({\r\n      ...temp,\r\n    });\r\n  };\r\n\r\n  const handleInputValue = (e: any) => {\r\n    const { name, value } = e.target;\r\n    setValues({\r\n      ...values,\r\n      [name]: value,\r\n    });\r\n    validate({ [name]: value });\r\n  };\r\n\r\n  const handleSuccess = () => {\r\n    setValues({\r\n      ...initialFormValues,\r\n      formSubmitted: true,\r\n      success: true,\r\n    });\r\n  };\r\n\r\n  const handleError = () => {\r\n    setValues({\r\n      ...initialFormValues,\r\n      formSubmitted: true,\r\n      success: false,\r\n    });\r\n  };\r\n\r\n  const formIsValid = (fieldValues = values) => {\r\n    const isValid =\r\n      fieldValues.sceneID &&\r\n      fieldValues.sceneName &&\r\n      fieldValues.imageSource &&\r\n      fieldValues.author &&\r\n      Object.values(errors).every((x) => x === \"\");\r\n\r\n    return isValid;\r\n  };\r\n\r\n  const handleFormSubmit = async (e: any) => {\r\n    e.preventDefault();\r\n    const isValid =\r\n      Object.values(errors).every((x) => x === \"\") && formIsValid();\r\n    if (isValid) {\r\n      await PostContactForm(values, handleSuccess, handleError);\r\n    }\r\n  };\r\n\r\n  return {\r\n    values,\r\n    errors,\r\n    handleInputValue,\r\n    handleFormSubmit,\r\n    formIsValid,\r\n  };\r\n};\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\deleteInfoValidation.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\addInfoValidation.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\deleteSceneValidation.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\loadSceneValidation.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\styles\\index.ts",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\validiations\\addSceneValidation.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\views\\app.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Products.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Navbar.tsx",["186"],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Home.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\Services.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\pages\\SignUp.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\Cards.tsx",[],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\Button.tsx",[],["187","188"],"E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\HeroSection.tsx",["189"],"import React from 'react';\r\nimport { Button } from './Button';\r\n\r\nimport '../../views/App.css';\r\nimport './HeroSection.css';\r\n\r\nfunction HeroSection() {\r\n  return (\r\n    <div className=\"hero-container\">\r\n      <video src=\"../videos/video-2.mp4\" autoPlay loop muted />\r\n      <h1>Go Endlessly</h1>\r\n      <p>Ready to explore?</p>\r\n      <div className=\"hero-btns\">\r\n       \r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default HeroSection;\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\Footer.tsx",["190"],"import React from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport { Button } from './Button';\r\n\r\nimport './Footer.css';\r\n\r\nfunction Footer() {\r\n  return (\r\n    <div className=\"footer-container\">\r\n      <section className=\"footer-subscription\">\r\n        <p className=\"footer-subscription-heading\">\r\n          Join the Adventure newsletter to receive our best vacation deals.\r\n        </p>\r\n        <p className=\"footer-subscription-text\">No spam. Just amazing deals.</p>\r\n        <div className=\"input-areas\">\r\n          <form action=\"\">\r\n            <input\r\n              type=\"email\"\r\n              name=\"email\"\r\n              placeholder=\"Your email\"\r\n              className=\"footer-input\"\r\n            />\r\n            {/* <Button buttonStyle=\"btn--outline\">Join</Button> */}\r\n          </form>\r\n        </div>\r\n      </section>\r\n      <div className=\"footer-links\">\r\n        <div className=\"footer-link-wrapper\">\r\n          <div className=\"footer-link-items\">\r\n            <h2>About Us</h2>\r\n            <Link to=\"/sign-up\">How it works</Link>\r\n            <Link to=\"/\">Testimonials</Link>\r\n            <Link to=\"/\">Careers</Link>\r\n            <Link to=\"/\">Investors</Link>\r\n            <Link to=\"/\">Terms of Service</Link>\r\n          </div>\r\n          <div className=\"footer-link-items\">\r\n            <h2>Contact Us</h2>\r\n            <Link to=\"/\">Contact</Link>\r\n            <Link to=\"/\">Support</Link>\r\n            <Link to=\"/\">Destinations</Link>\r\n            <Link to=\"/\">Sponsorships</Link>\r\n          </div>\r\n        </div>\r\n        <div className=\"footer-link-wrapper\">\r\n          <div className=\"footer-link-items\">\r\n            <h2>Videos</h2>\r\n            <Link to=\"/\">Submit Video</Link>\r\n            <Link to=\"/\">Ambassadors</Link>\r\n            <Link to=\"/\">Agency</Link>\r\n            <Link to=\"/\">Influencer</Link>\r\n          </div>\r\n          <div className=\"footer-link-items\">\r\n            <h2>Social Media</h2>\r\n            <Link to=\"/\">Instagram</Link>\r\n            <Link to=\"/\">Facebook</Link>\r\n            <Link to=\"/\">Youtube</Link>\r\n            <Link to=\"/\">Twitter</Link>\r\n          </div>\r\n        </div>\r\n      </div>\r\n      <section className=\"social-media\">\r\n        <div className=\"social-media-wrap\">\r\n          <div className=\"footer-logo\">\r\n            <Link to=\"/\" className=\"social-logo\">\r\n              TRVL <i className=\"fab fa-typo3\" />\r\n            </Link>\r\n          </div>\r\n          <small className=\"website-rights\">TRVL copyright 2021</small>\r\n          <div className=\"social-icons\">\r\n            <Link\r\n              class=\"social-icon-link facebook\"\r\n              to=\"/\"\r\n              target=\"_blank\"\r\n              aria-label=\"Facebook\"\r\n            >\r\n              <i className=\"fab fa-facebook-f\" />\r\n            </Link>\r\n            <Link\r\n              class=\"social-icon-link instagram\"\r\n              to=\"/\"\r\n              target=\"_blank\"\r\n              aria-label=\"Instagram\"\r\n            >\r\n              <i className=\"fab fa-instagram\" />\r\n            </Link>\r\n            <Link\r\n              class=\"social-icon-link youtube\"\r\n              to=\"/\"\r\n              target=\"_blank\"\r\n              aria-label=\"Youtube\"\r\n            >\r\n              <i className=\"fab fa-youtube\" />\r\n            </Link>\r\n            <Link\r\n              class=\"social-icon-link twitter\"\r\n              to=\"/\"\r\n              target=\"_blank\"\r\n              aria-label=\"Twitter\"\r\n            >\r\n              <i className=\"fab fa-twitter\" />\r\n            </Link>\r\n            <Link\r\n              class=\"social-icon-link twitter\"\r\n              to=\"/\"\r\n              target=\"_blank\"\r\n              aria-label=\"LinkedIn\"\r\n            >\r\n              <i className=\"fab fa-linkedin\" />\r\n            </Link>\r\n          </div>\r\n        </div>\r\n      </section>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Footer;\r\n","E:\\project742022\\react\\src\\pages\\pannellum-view\\components\\child_componet\\CardItem.tsx",[],{"ruleId":"191","replacedBy":"192"},{"ruleId":"193","replacedBy":"194"},{"ruleId":"195","severity":1,"message":"196","line":6,"column":8,"nodeType":"197","messageId":"198","endLine":6,"endColumn":14},{"ruleId":"195","severity":1,"message":"199","line":7,"column":8,"nodeType":"197","messageId":"198","endLine":7,"endColumn":15},{"ruleId":"195","severity":1,"message":"200","line":9,"column":8,"nodeType":"197","messageId":"198","endLine":9,"endColumn":18},{"ruleId":"195","severity":1,"message":"201","line":11,"column":8,"nodeType":"197","messageId":"198","endLine":11,"endColumn":18},{"ruleId":"195","severity":1,"message":"202","line":13,"column":8,"nodeType":"197","messageId":"198","endLine":13,"endColumn":16},{"ruleId":"195","severity":1,"message":"203","line":14,"column":8,"nodeType":"197","messageId":"198","endLine":14,"endColumn":23},{"ruleId":"195","severity":1,"message":"204","line":25,"column":10,"nodeType":"197","messageId":"198","endLine":25,"endColumn":13},{"ruleId":"195","severity":1,"message":"205","line":25,"column":15,"nodeType":"197","messageId":"198","endLine":25,"endColumn":21},{"ruleId":"195","severity":1,"message":"206","line":127,"column":7,"nodeType":"197","messageId":"198","endLine":127,"endColumn":12},{"ruleId":"207","severity":1,"message":"208","line":185,"column":6,"nodeType":"209","endLine":185,"endColumn":23,"suggestions":"210"},{"ruleId":"207","severity":1,"message":"211","line":224,"column":6,"nodeType":"209","endLine":224,"endColumn":23,"suggestions":"212"},{"ruleId":"195","severity":1,"message":"213","line":226,"column":9,"nodeType":"197","messageId":"198","endLine":226,"endColumn":25},{"ruleId":"195","severity":1,"message":"214","line":230,"column":9,"nodeType":"197","messageId":"198","endLine":230,"endColumn":26},{"ruleId":"195","severity":1,"message":"215","line":394,"column":9,"nodeType":"197","messageId":"198","endLine":394,"endColumn":25},{"ruleId":"195","severity":1,"message":"216","line":408,"column":9,"nodeType":"197","messageId":"198","endLine":408,"endColumn":21},{"ruleId":"217","severity":1,"message":"218","line":63,"column":29,"nodeType":"197","messageId":"198","endLine":63,"endColumn":45},{"ruleId":"217","severity":1,"message":"218","line":63,"column":29,"nodeType":"197","messageId":"198","endLine":63,"endColumn":45},{"ruleId":"219","severity":1,"message":"220","line":18,"column":7,"nodeType":"197","messageId":"221","endLine":18,"endColumn":21},{"ruleId":"217","severity":1,"message":"218","line":65,"column":29,"nodeType":"197","messageId":"198","endLine":65,"endColumn":45},{"ruleId":"217","severity":1,"message":"218","line":65,"column":29,"nodeType":"197","messageId":"198","endLine":65,"endColumn":45},{"ruleId":"217","severity":1,"message":"218","line":63,"column":29,"nodeType":"197","messageId":"198","endLine":63,"endColumn":45},{"ruleId":"217","severity":1,"message":"218","line":90,"column":29,"nodeType":"197","messageId":"198","endLine":90,"endColumn":45},{"ruleId":"219","severity":1,"message":"220","line":22,"column":7,"nodeType":"197","messageId":"221","endLine":22,"endColumn":21},{"ruleId":"207","severity":1,"message":"222","line":54,"column":7,"nodeType":"223","endLine":54,"endColumn":26},{"ruleId":"217","severity":1,"message":"218","line":85,"column":29,"nodeType":"197","messageId":"198","endLine":85,"endColumn":45},{"ruleId":"191","replacedBy":"192"},{"ruleId":"193","replacedBy":"194"},{"ruleId":"224","severity":1,"message":"225","line":1,"column":1,"nodeType":"226","messageId":"227","endLine":1,"endColumn":16,"fix":"228"},{"ruleId":"229","severity":1,"message":"230","line":72,"column":45,"nodeType":"231","messageId":"232","endLine":74,"endColumn":8},{"ruleId":"229","severity":1,"message":"230","line":78,"column":39,"nodeType":"231","messageId":"232","endLine":84,"endColumn":8},{"ruleId":"233","severity":1,"message":"234","line":107,"column":3,"nodeType":"197","messageId":"235","endLine":107,"endColumn":18},{"ruleId":"233","severity":1,"message":"236","line":116,"column":3,"nodeType":"197","messageId":"235","endLine":116,"endColumn":18},{"ruleId":"237","severity":1,"message":"238","line":49,"column":38,"nodeType":"239","messageId":"240","endLine":49,"endColumn":39,"suggestions":"241"},{"ruleId":"237","severity":1,"message":"238","line":49,"column":72,"nodeType":"239","messageId":"240","endLine":49,"endColumn":73,"suggestions":"242"},{"ruleId":"237","severity":1,"message":"243","line":49,"column":80,"nodeType":"239","messageId":"240","endLine":49,"endColumn":81,"suggestions":"244"},{"ruleId":"217","severity":1,"message":"245","line":9,"column":10,"nodeType":"197","messageId":"198","endLine":9,"endColumn":16},{"ruleId":"191","replacedBy":"246"},{"ruleId":"193","replacedBy":"247"},{"ruleId":"217","severity":1,"message":"205","line":2,"column":10,"nodeType":"197","messageId":"198","endLine":2,"endColumn":16},{"ruleId":"217","severity":1,"message":"205","line":3,"column":10,"nodeType":"197","messageId":"198","endLine":3,"endColumn":16},"no-native-reassign",["248"],"no-negated-in-lhs",["249"],"no-unused-vars","'AppBar' is defined but never used.","Identifier","unusedVar","'Toolbar' is defined but never used.","'Typography' is defined but never used.","'IconButton' is defined but never used.","'MenuIcon' is defined but never used.","'ChevronLeftIcon' is defined but never used.","'Box' is defined but never used.","'Button' is defined but never used.","'types' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'state'. Either include it or remove the dependency array.","ArrayExpression",["250"],"React Hook useEffect has a missing dependency: 'state.fullScenesInformation'. Either include it or remove the dependency array.",["251"],"'handleDrawerOpen' is assigned a value but never used.","'handleDrawerClose' is assigned a value but never used.","'handleFileChosen' is assigned a value but never used.","'exportConfig' is assigned a value but never used.","@typescript-eslint/no-unused-vars","'handleFormSubmit' is assigned a value but never used.","@typescript-eslint/no-redeclare","'types' is already defined.","redeclared","React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","MemberExpression","strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"252","text":"253"},"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'source'.","FunctionExpression","unsafeRefs","no-func-assign","'_getPrototypeOf' is a function.","isAFunction","'_setPrototypeOf' is a function.","no-useless-escape","Unnecessary escape character: \\/.","Literal","unnecessaryEscape",["254","255"],["256","257"],"Unnecessary escape character: \\[.",["258","259"],"'button' is assigned a value but never used.",["248"],["249"],"no-global-assign","no-unsafe-negation",{"desc":"260","fix":"261"},{"desc":"262","fix":"263"},[0,15],"",{"messageId":"264","fix":"265","desc":"266"},{"messageId":"267","fix":"268","desc":"269"},{"messageId":"264","fix":"270","desc":"266"},{"messageId":"267","fix":"271","desc":"269"},{"messageId":"264","fix":"272","desc":"266"},{"messageId":"267","fix":"273","desc":"269"},"Update the dependencies array to be: [state, state.isAddInfo]",{"range":"274","text":"275"},"Update the dependencies array to be: [state.fullScenesInformation, state.loadState]",{"range":"276","text":"277"},"removeEscape",{"range":"278","text":"253"},"Remove the `\\`. This maintains the current functionality.","escapeBackslash",{"range":"279","text":"280"},"Replace the `\\` with `\\\\` to include the actual backslash character.",{"range":"281","text":"253"},{"range":"282","text":"280"},{"range":"283","text":"253"},{"range":"284","text":"280"},[5896,5913],"[state, state.isAddInfo]",[6880,6897],"[state.fullScenesInformation, state.loadState]",[1239,1240],[1239,1239],"\\",[1273,1274],[1273,1273],[1281,1282],[1281,1281]]